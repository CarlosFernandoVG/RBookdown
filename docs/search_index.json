[
["index.html", "Programación en R Prefacio", " Programación en R Sofía Villers Gómez Carlos Fernando Vásquez Guerra David Alberto Mateos Montes de Oca Prefacio Primera edición del bookdown Programación en R para el uso continuo en las materias de Estadística y sus relacionadas impartidas por los autores, así como para aquellos estudiantes que deseen adquirir el conocimiento pertinente del lenguaje de programación R. Objetivos Otorgar el mayor conocimiento posible del lenguaje de programación R a nivel básico-intermedio con el que sea el lector sea capaz de manipular fuentes de información y crear contenido de calidad, que junto al uso del software RStudio, se logren dar soluciones atractivas a problemas que requieran este tipo de herramientas. Como bien se menciono, este material no sólo está dirigido a los estudiantes de la Facultad de Ciencias de la Universidad Nacional Autónoma de México, si no a cualquier lector que desee introducirse y adquirir conocimiento, así como las habilidades pertinentes, sobre el lenguaje de programación R. Estructura Este libro se compone de tres diferentes secciones y a medida que estas son abarcadas, se verán temas generales sobre el lenguaje R y de ciertas librerías especiales diseñadas para problemas específicos, así como funciones especiales que faciliten ciertas tareas. En la primera de ellas se tendrá el contenido referente a las características y funciones por default el R, sin hacer uso de algún paquete exterior a él. En la siguiente se estudiará lo correspondiente al tidyverse para lograr una programación más eficiente y adecuada para el análisis de datos. Finalmente, se cubrirá los conocimientos necesarios para la creación de aplicaciones web interactivas gracias al paquete Shiny. De acuerdo a las necesidades del lector, los capítulos pueden ser estudiados de manera independiente aunque es recomendable tener el conocimiento previo que se tiene en el temario, ya que se puede hacer uso de funciones o conocimiento previo en secciones avanzadas. Gran parte del contenido en este libro esta basado en las publicaciones basicr y EfficientR de Rpubs. Detalles técnicos Este libro fue escrito con bookdown usando RStudio. Esta versión fue escrita con: Finding R package dependencies ... Done! setting value version R version 3.6.2 (2019-12-12) os macOS Catalina 10.15.6 system x86_64, darwin15.6.0 ui X11 language (EN) collate en_US.UTF-8 ctype en_US.UTF-8 tz America/Mexico_City date 2020-09-18 Licencia This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. This is a human-readable summary of (and not a substitute for) the license. Please see https://creativecommons.org/licenses/by-sa/4.0/legalcode for the full legal text. You are free to: Share—copy and redistribute the material in any medium or format Remix—remix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution—You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike—If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions—You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Notices: You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation. No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material. "],
["introducción-e-instalación.html", "Capítulo 1 Introducción e instalación", " Capítulo 1 Introducción e instalación R y RStudio R es un lenguaje de programación interpretado diseñado para la computación estadística y proporcionar un ambiente gráfico. R esta basado en el lenguaje de programación estadístico S, el cual fue desarrollado en los laboratorios Bell por John Chambers, Rick Becker y Allan Willks. Este lenguaje llamaba a subrutinas de FORTRAN aunque después, en 1988, fue reescrito en lenguaje C (Wikipedia contributors 2020). La idea de R nació en Nueva Zelanda por Ross Ihaka y Robert Gentleman con la intención de crear un lenguaje que ayudará en la enseñanza estadística de la Universidad Nueva Zelanda, esto en 1992, y fue hasta 1995 que se lanzo una primera versión estable. Ya mediados de 1997 se creo un grupo para modificar el código fuente de este lenguaje. La mayoría de las funciones en R están escritas en el propio lenguaje pero, gracias al trabajo de la comunidad, se han hecho muchas implementaciones y procedimientos que están escritos en C, C++ y FORTRAN para lograr una mayor eficiencia en cuanto al tiempo y memoria. A partir de 1995 se decide usar la licencia GNU para que R sea un software libre, es decir, que se puede consultar el código fuente, se puede modificar las funciones internas, aunque no es buena idea si no se tiene un conocimiento profundo del lenguaje. R no esta diseñado para ser un lenguaje de programación rápido, si no que su propósito es hacer un análisis de datos interactivo y fácil para humanos. Respecto a RStudio, este es una IDE disponible desde el 2011 que permite trabajar de una manera más fluida con el lenguaje de programación R incluyendo una consola donde se puede trabajar de manera directa con el lenguaje, un editor de textos para guardar nuestro código, crear Scripts, etc, distintos paneles para visualizar gráficas, navegar en los distintos directorios donde estemos posicionados y un gran conjunto de herramientas que facilitan la integración de librerías y la creación de documentos de distintas extensiones. En RStudio también se puede trabajar con otros lenguajes de programación e integrar estos con R, como por ejemplo Python; de hecho, desde el 2019 se tiene soporte para Notebooks de Jupyter. Además de que, como cualquier IDE, se puede personalizar un poco la interfaz para trabajar más cómodamente. Fuentes: RStudio 1.1 Preview - I Only Work in Black; Theme Black. Hay que tener en cuenta los siguientes puntos: Hay una sesión de R corriendo cuando se está en RStudio. La consola de R es la interfaz entre R y el usuario. En la sesión hay objetos. Todo en R es un objeto: vectores, tablas, funciones, etc. Finalmente: Instala R, a free software environment for statistical computing and graphics desde el CRAN de acuerdo a tu sistema operativo; más adelante se verá que es el CRAN. Instala el entorno de desarrollo integrado RStudio Si previamente habías instalado alguna versión de R y RStudio en tu computadora, sugerimos reinstalar ambos para tener las versiones más actualizadas. Recursos adicionales Gran parte de este trabajo esta basado en los libros (Wickham 2019) y (Wickham and Grolemund 2016) entre otros, así como los sitios web oficiales de R Fundation como (The R Fundation, n.d.). Si no estás del todo familiarizado con el lenguaje, te recomendamos lo siguientes recursos donde podrás encontrar información útil sobre R y RStudio. Cómo usar RStudio RStudio para el aprendizaje de R R: Preguntas Frecuentes R: Instalación y administración R-bloggers RPubs References "],
["markdown.html", "Capítulo 2 Markdown", " Capítulo 2 Markdown Antes de comenzar a escribir código creemos que es necesario aprender a como escribir notas a través de un RMarkdown. Markdown es un lenguaje de marcado, así como lo es HTML, creado por John Gruberque donde, mediante una sintaxis fácil de aprender, se pueden crear archivos de texto plano integrando elementos para mejorar el formato de este. En el caso de RMarkdown, además de la sintaxis de Markdown, se pueden integrar elementos de HTML, CSS (Cascading Style Sheets) y \\(\\LaTeX\\), con la finalidad de obtener archivos con distinta extensión, como lo son pdf, html y word. Es cierto que ciertos archivos no se podrán llevar de una manera directa de uno a otro, como html a pdf cuando se tienen gráficas interactivas, pero siempre se tiene la posibilidad de integrar código y resultados del lenguaje de programación con el que se este trabajando en el tipo de archivo de salida. Uno de las primeras herramientas es Zepellin; otras aplicaciones de este estilo son: Jupyter, Typora, etc. La ayuda fundamental para un paquete de R, como generalmente va a ser si se tiene disponible, es una CheetSheet y la correspondiente a RMakdown se puede descargar del siguiente enlace Para facilitar y complementar un poco la sintaxis, aquí se enlistan algunos puntos recurrentes Se pueden agregar comentarios en MarkDown empezando &lt;!– y terminando con –&gt;. Cuando se esta trabajando en \\(\\LaTeX\\), generalmente se agrega algo llamado preámbulo al inicio de los archivos .tex donde se colocan todos los comandos para darle formato al texto, en este caso se podría agregar un preámbulo agregando en el YAML en la sección includes: in_header: o se pueden agregar las librerías de \\(\\LaTeX\\) directamente dentro de header_includes: &quot;usepackage[all]{xy}&quot; &quot;usepackage{enumitem}&quot; &quot;usepackage{caption}&quot; &quot;captionsetup{labelformat=empty}&quot; Es posible agregar bibliografía de un archivo .bib. Esto puede hacerse en la sección bibliography: del YAML, por ejemplo: bibliography:\"bib/library.bib\". El estilo de esta también se puede en la sección csl:, por ejemplo: csl:acm-sig-proceedings-long-author-list.csl Hay muchas opciones que se pueden agregar de acuerdo al tipo de archivo que se este creando. Para el caso un archivo HTML se puede cambiar el tema, agregar una opción para ocultar o desglosar el código adjunto, cambiar ancho y alto de las imágenes, etc. Algunas opciones son las siguientes: html_document: df_print: paged (Formato para tablas) highlight: tango (Diseño) code_folding: hide (Esconder código) theme: flatly (Tema) toc: yes (Tabla de contenidos o un índice) (table of contents) toc_float: yes (TOC con mejor diseño) fig_width: 9 (Ancho) fig_height: 5 (Largo) Donde mínimo se tienen las siguientes opciones: highlight: default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, and textmate theme: default, cerulean, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti. df_print: default, kable, tibble, paged Para un archivo PDF, se tienen también una gran cantidad de opciones para personalizar el documento pdf_document: df_print: kable (Formato para tablas) fig_caption: yes (Etiquetas a las imágenes y gráficas) number_sections: yes (Secciones) toc: yes (Tabla de contenidos o un índice) (table of contents) toc_depth: 5 (Jerarquía de subtitulos) (profundidad del índice) fig_width: 7 (Ancho) fig_height: 4 (Largo) keep_tex: true (Para devolver el archivo .tex) extra_dependencies: [“amsfonts”, “dsfont”, “mathrsfs”, “bbold”] (Para más librerías de \\(\\LaTeX\\)) Sea cual sea formato de salida que se eliga, se pueden generalizar algunas características del archivo documentclass: book (Tipo de documento) classoption: a4paper (Tamaño del documento) fontsize: 12pt (Tamaño de letra) geometry: “top=1in, left=0.9in, right=1.25in, bottom=1in” (Bordes de la página) linkcolor: blue (Color para hipervínculos) urlcolor: blue (Color para enlaces) Como ya se ha mencionado, se puede hacer una integración con el código que se este desarrollando, así que aquí se muestran algunas opciones generales para los bloques donde va contenido el código llamados chunks. #```{r setup, include=FALSE} knitr::opts_chunk$set( echo = FALSE, #sirve para mostrar código y va dentro del chunk fig.pos = &#39;H&#39;, fig.align = &#39;center&#39;, message = FALSE, warning = FALSE ) #``` Para las imágenes se puede usar alguna función establecida en R, o bien hacer uso de lo que MarkDown permite. Véase el siguiente ejemplo para insertar una imagen: ![rain of numbers](source/rain_of_numbers.jpg) Otro punto importante es que la generación de tablas se puede obtener directamente de una “tabla” que se produzca con código, aunque ciertas veces se puede preferir hacer una tabla de manera manual. En la página Tables Generator se pueden crear estas con una interfaz amigable y simplemente copiar y pegar el resultado aquí mismo, ya sea en formato Markdown, HTML o en \\(\\LaTeX\\). La integración del código en R se puede hacer mediante un chunk o mediante un ejecución en linea, para esto hay que seguir la siguiente sintaxis: \\(`\\)r code\\(`\\), por ejemplo, este 🐒 fue generado a través de un comando inline. En el siguiente enlace se ve un poco más sobre la nomenclatura que se tiene en YAML Finalmente, existen muchas fuentes de donde obtener información, aunque una de las más completas es del Bookdown R Markdown: The Definitive Guide y la página oficial de RMarkdown. "],
["conocimientos-básicos-de-r.html", "Capítulo 3 Conocimientos básicos de R", " Capítulo 3 Conocimientos básicos de R Este capítulo este destinado cien por ciento a lenguaje de programación R sin uso de algunas otras funciones que provengan de distintos paquetes. Sí se hará mención de algunos paquetes como una alternativa o mejora a diversas funciones que provengan del paquete base de R. Por lo mismo, se tratarán algunos conceptos teóricos sobre el comportamiento de este lenguaje, así como sus estructuras, su comportamiento y se presentarán funciones para la creación de gráficas. Se asume que previamente se ha tenido un acercamiento al paradigma de programación orienta a objetos por lo que también se añade contenido referente a conceptos relacionados mostrando implementaciones en este lenguaje así como desventajas que puede presentar R fuera del propósito por el que fue creado. "],
["buscando-ayuda.html", "3.1 Buscando ayuda", " 3.1 Buscando ayuda Por sí mismo, R cuenta con funciones que nos permitirán obtener ayuda sobre R en general pero también sobre las diferentes funciones que estemos usando para resolver algún problema. Para mostrar un manual de ayuda general en formato HTML corremos el siguiente código en la consola: help.start() El manual será mostrado en el panel de ayuda dentro de RStudio pero puede abrirse con el navegador en caso de que así lo deseemos. Supongamos ahora que dentro de nuestro flujo de trabajo estamos utilizando la funcíón log() sin embargo no estamos familiarizados con ella y deseamos obtener ayuda sobre el uso de la función. Para a tener acceso a la documentación de la función podemos usar alguna de las siguientes líneas de código: help(log) ?log En el caso particular de RStudio, existe un atajo con el que podemos abrir la documentación de cualquier función sin necesidad de correr alguna de las líneas anteriores en la consola. El atajo consiste de colocar el cursor de texto entre cualesquiera caractéres de la función y presionar el botón F1 de nuestro teclado. Adicionalmente tenemos las siguientes funciones: apropos(&quot;plot&quot;) help.search(&quot;plot&quot;) apropos() nos ayudará a encontrar las funciones que incluyan el texto (en este caso plot) en su nombre. Por otro lado, help.search() nos mostrará la documentación de las funciones que incluyan el texto, en este caso plot. Como se indica, cualquiera de esas opciones te permitirá tener acceso a la documentación de la funciones donde podrás encontrar: para qué se usan, qué argumentos necesitan, lo que regresan y algunos ejemplos del uso de las mismas. En el caso de buscar información sobre algún paquete instalado, se pueden usar los comandos vignette(package = \"some_package\") o vignette(\"some_package\"), al igual que ?library. Algunas veces, una buena opción será consultar información creada por diferentes autores. La siguiente es una lista de varios Bookdowns que les pueden ser de gran utilidad y de constante consulta. Al final también se agrega la liga oficial para consultar las CheatSheets disponibles. R para Ciencia de Datos R para profesionales de los datos: una introducción R for Data Science En general RStudio Cheat Sheets Una buena parte de los errores que podamos encontrarnos en nuestros flujos de trabajo se resolverán al revisar la documentación de la función que esté generando el error, sin embargo habrá ocasiones en las que los errores sean más complejos y la documentación no nos dará una buena pista de cómo remediarlos, en tal caso la mejor estrategia sera utilizar tu buscador favorito para buscar el error. Será tan fácil cómo copiar el error que la consola esté arrojando y ponerlo en la barra de búsqueda de e.g. Google. Muchas veces las soluciones las encontrarás en Stack Overflow o en otros medios; por ejemplo, para un problema relacionado a la estadística bien podrías encontrar información valiosa en Cross Validated. "],
["vectores-y-operaciones.html", "3.2 Vectores y operaciones", " 3.2 Vectores y operaciones Quizá ya hayas escuchado lo siguiente en algún lado: R es un lenguaje vectorial. El comportamiento al que hace referencia esta frase será de mucha ayuda en la construcción de rutinas avanzadas de programación que veremos más adelante, por ahora la implicación más relevante reside en el hecho de que la estructura básica en R serán justamente vectores. 3.2.1 Vectores atómicos En todos los lenguajes de programación se tienen diferentes tipos de datos primitivos; por ejemplo en Java se tiene int, long, char, byte, etc. Para Python: String, Float, Boolean, entre otros. En R se tienen 6 tipos de datos primitivos, también conocidos como “atómicos”. En R, en general todo estará compuesto de vectores o de estructuras hechas con vectores y los datos primitivos no son la excepción, ya que estos también son vectores. Lógicos (boolean): TRUE, FALSE Enteros (integer): 5 Double (doble): 5.54 Es interesante preguntarse el porqué, en general, un valor en coma flotante se le llama (traducido) doble. En el siguiente enlace se hace este interrogante en la página Quora. Los enteros y double son categorizados como vectores numéricos(numeric). Caracteres (character): \"word\" Complejos (complex): 5 + 7i Crudos o sin procesamiento (raw): raw(5) Este tipo de dato se usa para representar una secuencia de bytes. Este tipo de dato, así como los complejos generalmente no se utilizan. En el libro A Data Scientist’s Guide to Acquiring, Cleaning, and Managing Data in R de Buttrey y Whitaker se muestra un ejemplo del uso de este tipo de vectores. NOTA: A partir de aquí, véase el uso de distintas funciones. Existen algunas funciones de R para saber el tipo de dato que se está usando: typeof(), class() y mode(). Las tres funciones tienen diferentes criterios para determinar que tipo de vector atómico es con el que se está tratando; typeof() identifica el tipo de dato visto desde el punto de vista de R y es la función más usada,mode() es compatible con S y class() identifica el tipo de datos visto desde una POO en R (específicamente el sistema S3). cat(paste(class(TRUE), class(5), typeof(5.54), typeof(5L), mode(&quot;word&quot;), class(charToRaw(&quot;5&quot;)), typeof(5 + 7i) ,sep = &quot;\\n&quot;)) logical numeric double integer character raw complex En la siguiente tabla se muestra las posibles salidas con todas las variables de prueba. typeof() class() mode() TRUE logical logical logical 5 double numeric numeric 5.4 double numeric numeric 5L integer integer numeric word character character character charToRaw(“5”) raw raw raw 5 + 7i complex complex complex Con lo anterior surge la siguiente pregunta: ¿Hay alguna diferencia entre un vector de tipo integer y un tipo double? En general, cuando se están trabajando con datos de punto flotante, se esta considerando una aproximación del verdadero número, tanta aproximación como lo permita la memoria, por lo que pueden existir errores de precisión. De hecho, una manera más adecuada de comparar valores con punto decimal sería utilizando la función dplyr::near() en lugar de ==. Después se tratará el tema de las funciones. Otro punto interesante es que, dependiendo del tipo de vector, se tiene un distinto representante para los valores faltantes (Missing values); para un entero se tiene NA pero con un vector tipo double se tienen NA, NaN, Inf y –Inf. Un ejemplo de esto se puede obtener al dividir distintos números entre 0. Para un profundizar en esto, se puede ver la documentación oficial. Algunos enlaces útiles sobre los vectores numéricos: What is the difference between mode and class in R?. What’s the difference between integer class and numeric class in R. 3.2.2 Otros tipos de datos Además de los vectores atómicos, se tienen otro tipo de vector llamado factor. Un factor es un tipo especial de dato en el cual se puede establecer una jerarquía en variables categóricas. Supongase que se tiene una variable correspondiente al tamaño de un objeto donde los posibles valores son “Big”, “Little”, “Medium”, “Jumbo”. Intuitivamente se sabe que esta variable es categórica ordinal por lo que se desearía dejar establecido esta jerarquía en el vector que contenga esta información. factor(c(&quot;Big&quot;, &quot;Little&quot;, &quot;Medium&quot;,&quot;Jumbo&quot;)) [1] Big Little Medium Jumbo Levels: Big Jumbo Little Medium Como se puede observar, se tiene un atributo (más adelante se verán los atributos de un vector) indicando los niveles del factor. Los niveles se establecieron en orden alfabético pero sin ningún orden realmente. Para establecer los niveles se puede dar este atributo directamente desde la creación o modificarlo después de la creación del factor. factor(c(&quot;Big&quot;, &quot;Little&quot;, &quot;Medium&quot;,&quot;Jumbo&quot;), levels = c(&quot;Little&quot;, &quot;Medium&quot;, &quot;Big&quot;, &quot;Jumbo&quot;)) [1] Big Little Medium Jumbo Levels: Little Medium Big Jumbo De manera análoga, se puede dar el orden a los niveles. factor(c(&quot;Big&quot;, &quot;Little&quot;, &quot;Medium&quot;,&quot;Jumbo&quot;), levels = c(&quot;Little&quot;, &quot;Medium&quot;, &quot;Big&quot;, &quot;Jumbo&quot;), ordered = TRUE) [1] Big Little Medium Jumbo Levels: Little &lt; Medium &lt; Big &lt; Jumbo ¿Qué sucede si se agregan más datos pero que pertenecen a los niveles? ¿Qué sucede cuando no se agrega un nivel? ¿Qué pasará con los niveles en datos numéricos? ¿Qué pasará con los niveles en datos numéricos pero dados como caracteres? ¿Qué obtenemos al usar class() y typeof() con un factor? ¿Cómo puede ayudar la función rev() en un factor? En la siguiente liga se puede ver un poco más de información sobre este tipo de datos. En la sección 15 del libro R para ciencia de Datos (traducción al español de R for Data Science de Wickham y Grolemund) se mencionan algunas fuentes para aprender más acerca de los factores, el cual es un tema bastante útil de dominar ya que existe una librería llamada forcats con la que se puede trabajar de manera adecuada estos tipos de datos que son de gran ayuda al momento de hacer algún tipo de análisis descriptivo, graficación y creación de modelos. Aquí se enlistan los artículos correspondientes. Wrangling categorical data in R stringsAsFactors: An unauthorized biography stringsAsFactors = &lt;sigh&gt; Otro tipo de dato con el que se cuenta es aquel que no está definido, es decir, como en Java, un objeto nulo: NULL. En las siguientes líneas de código se muestra como hacer comparaciones con este tipo de dato. is.null(NULL) [1] TRUE 0 == NULL logical(0) NA == NULL logical(0) Otro punto muy común al analizar datos es encontrarse con información faltante. Aquí, como en otros lenguajes, los valores perdidos son distintos a un objeto no definido; ya que un valor perdido bien puede indicar un error humano al momento del registro de la información pero con la característica de que se puede inferir un posible valor para ese registro faltante. Un NA es una constante que puede ser asignada a cualquier tipo de vector a excepción de un vector de tipo raw. Al tener esta ausencia de datos se desea identificarlos de manera rápida y esto puede ser complicado en una base de datos con cientos o miles de registros; al igual que si se tiene el conocimiento de la existencia de estos, se desea que no afecten en operaciones o aplicaciones de funciones en el resto de los datos. Véase lo siguiente sum(c(1,NA,3), c(1,2,3)) [1] NA Es decir, que cuando se tiene algún valor perdido, la operación suma (más adelante se verá a detalle las operaciones en este lenguaje) queda determinada con NA. ¿Sucede lo mismo con otro tipo de operaciones? Como se había mencionado, se desea que si se tiene conocimiento de la existencia de al menos un NA, este no afecte a las operaciones sum(c(1,NA,3), c(1,2,3), na.rm = TRUE) [1] 10 Técnicamente, existen cinco missing values para cada uno de los vectores atómicos (a excepción de raw claro): NA, NA_interger_, NA_real_, NA_character_ y NA_complex_, pero eso solo es de manera interna. 3.2.3 Asignación de nombres y atributos Como en cualquier lenguaje de programación, existen identificadores para guardar o asignar el valor de los tipos de datos primitivos o resultados y así utilizarlos posteriormente. En el caso de R, la asociación de un nombre con un cierto valor se puede realizar mediante la función &lt;-() y gracias a que R es un lenguaje interpretado, no es necesario declarar el tipo de dato antes de darle una instanciación. Por ejemplo, véase que en las siguientes líneas de código se asignan a algunos vectores atómicos un identificador. a &lt;- 5+7i b &lt;- 5L c &lt;- 10 d &lt;- TRUE e &lt;- NA Y en este caso, basta con llamar a la variable por su nombre para poder usarla. a [1] 5+7i c [1] 10 e [1] NA También se puede asignar un valor a una variable con el operador = pero esto no es nada recomendable ya que, por buenas prácticas, en este lenguaje, se acostumbra a usar el igual para dar valores a parámetros. ¿Qué pasará cuando se ejecute x &lt;- NULL? ¿Qué pasará si antes x tenía otro tipo de dato? Aquí se dejan otros ejemplos útiles, más adelante se verá la función assign(). roma &lt;- c(0.1, 0.2, 0.3) assign(&quot;mora&quot;, c(0.4, 0.5, 0.6)) c(0.7, 0.8, 0.9) -&gt; z mora &lt;- c(roma, 0, 0, 0, roma) N.B. Los vectores en R no solo pueden ser numéricos también los hay aquellos con cadenas de texto. mora[3] [1] 0.3 mora[-3] [1] 0.1 0.2 0.0 0.0 0.0 0.1 0.2 0.3 mora[c(1,5,7)] [1] 0.1 0.0 0.1 Algo que hay que entender sobre R es que este lenguaje esta basado en el paradigma de programación orientada a objetos, aunque también tiene ciertas características de un lenguaje funcional. Existen muchos sistemas para hacer todo lo que se tiene conocimiento de POO en R, como lo es el encapsulamiento, herencia y polimorfismo. Aquí se evitará en la mayor medida posible el tema pero se harán menciones en la marcha de esto. Para el caso de los vectores, se tienen ciertos atributos fijos desde su creación: la longitud y el tipo de dato. Más adelante, en las estructuras de datos, se detallará sobre este tema; por el momento, véase lo siguiente a &lt;- c(1,2,3,4,5) paste0(&quot;longitud: &quot;, length(a), &quot;.Tipo de dato: &quot;, typeof(a)) [1] &quot;longitud: 5.Tipo de dato: double&quot; Aclaremos ciertas cosas: La manera más rápida de crear un vector es con el constructor c() y agregando datos del mismo tipo dentro de él separados con una coma. Si v_1 es un vector de un cierto tipo y se desea hacer otro vector v_2 del mismo tipo que contenga el contenido de v_1 más otros elementos ¿Se puede hacer v_2 &lt;- c(v_1,...)? Otra forma de crear cualquier otro vector es con la función vector(\"type\", length). En cierto sentido, usar la última función es una mejor manera de trabajar ya que así se reserva un espacio de memoria para un vector fijo, mientras que con c() este puede ir variando. Para crear un vector vacío de una cierta longitud, la función vector() es la ideal. Se pueden crear vectores atómicos de cierta longitud con sus valores por defecto al usar los constructores double(length), interger(length), character(length), etc. Arriba se creo una secuencia de números de manera rudimentaria, ya que en R se pueden crear secuencias de números con la función :, por ejemplo: 1:5. Con seq_along() se puede crear también una secuencia de números; esta la podemos usar en lugar de 1:length(v) con v un vector. ¿Qué pasa en las siguientes instrucciones? y &lt;- vector(\"double\", 0); seq_along(y); 1:length(y). Finalmente, se pueden hacer secuencias cada \\(n\\) números con la función seq(): seq(1,10,by=2). Ya que R es un lenguaje de código libre y orientado a objetos, podemos ver el contenido de sus funciones. Para las funciones que están escritas en R podemos ejecutar directamente el nombre de la función omitiendo los paréntesis. integer function (length = 0L) .Internal(vector(&quot;integer&quot;, length)) &lt;bytecode: 0x7ffd2a1470f0&gt; &lt;environment: namespace:base&gt; ¿Cómo están hechos los constructores para double, character, boolean y raw? ¿Cómo están hechos los constructores para un complejo y un factor? Muchas veces es útil comparar distintos tipos de variables o verificar si estas son de algún tipo en específico. Para ello existen ciertas funciones como is.character(), is.na(), is.double(), etc. En general se tiene este tipo de funciones para cualquier objeto, incluso se tiene is.function(). En el caso de los posibles valores perdidos de un double, hay que evita usar == para verificar los posibles valores como Inf y –Inf. En su lugar usar las funciones is.finite(), is.infinite(), e is.nan(). 3.2.4 Operaciones básicas en R Es importante que existan operaciones en los lenguajes de programación, y en este caso se tienen las más comunes y algunas especiales. Adición: 5 + 7; sum(5,7). Sustracción: 5 - 7. Multiplicación: 5*7; prod(5,7). División: 5 / 7. Modulo: 5 %% 7 División entera (piso): 5 %/% 7. Potencia: 5 ^ 7; 5 ** 7. Multiplicación Matricial: %*% Al igual que los clásicos operadores booleanos o relacionales TRUE &amp; TRUE. TRUE &amp; FALSE. TRUE | TRUE. TRUE | FALSE. !TRUE. TRUE == FALSE. TRUE != FALSE. En resumen, tenemos la siguiente tabla Aritméticos Comparación Lógicos Suma (+) Menor que (&lt;) NOT (!) Resta (-) Mayor que (&gt;) AND (&amp;) Multiplicación (*) Menor o igual que (&lt;=) OR (|) División (/) Mayor o igual que (&gt;=) Cierto (TRUE) Potencia (^) Igual (==) Falso (FALSE) Modulo (%%) Diferente (!=) División entera (%/%) Ahora, lo poderoso de R es poder trabajar de manera vectorial, por lo que las operaciones actúan también de manera vectorial. Los siguientes ejemplos muestran el comportamiento asociado a un lenguaje vectorial que mencionamos: v &lt;- 2*roma+mora+1 v [1] 1.3 1.6 1.9 1.2 1.4 1.6 1.3 1.6 1.9 1:5 + 2:6 [1] 3 5 7 9 11 1:5 * 2:6 [1] 2 6 12 20 30 ¿Qué pasará con las siguientes operaciones? 1:5 ^ 1:5 (1:6) ^ c(2,3) s &lt;- seq(1,10, by = 2); s + 7 sqrt(s) 1:10 + 1:5 1:10 * 1:5 1:10 * 10 Lo que sucedió arriba se conoce como reciclaje, lo cual tiene el efecto de repetir de manera ordenada los vectores más pequeños para que ambos vectores que se están operando tengan la misma longitud, esto resulta muy útil cuando se quiere repetir ciertos parámetros en una operación cada \\(n\\) cantidad de pasos. Por ejemplo, si se desea obtener el cuadrado de todos los pares de números del \\(1\\) al \\(100\\), no es necesario hacer algún proceso usando condicionales y algún bucle, sino sólo operar de manera vectorial y usar reciclaje. seq(1,100)^c(1,2) [1] 1 4 3 16 5 36 7 64 9 100 11 144 [13] 13 196 15 256 17 324 19 400 21 484 23 576 [25] 25 676 27 784 29 900 31 1024 33 1156 35 1296 [37] 37 1444 39 1600 41 1764 43 1936 45 2116 47 2304 [49] 49 2500 51 2704 53 2916 55 3136 57 3364 59 3600 [61] 61 3844 63 4096 65 4356 67 4624 69 4900 71 5184 [73] 73 5476 75 5776 77 6084 79 6400 81 6724 83 7056 [85] 85 7396 87 7744 89 8100 91 8464 93 8836 95 9216 [97] 97 9604 99 10000 Hay que tener cuidado en algunos casos, por ejemplo 1:4^c(2,4). Ejercicios El siguiente vector contiene una muestra referente al genero en un grupo de personas: c('H','M','M','H','H','M','H','M','H','H','M','M','M','M','M','M','M','M','H','H','H','M','H','M','M','M', 'M','H','H','H','H','M','M','M','H','M','H','H','M','H','M','H','M','H','M','M','H','H','M','H'). Mediante la función table() determina la frecuencia de cada categoría usando un factor. Convierte el siguiente vector de caracteres en un vector numérico y obtén la suma de todos sus elementos. c('7', '50', '7', '18', '42', '37', '20', '11', '33', '38', '28', '3', '16', '40', '3', '40', '36', '37', '1', '6', '8', '23', '25', '48', '5', '22', '21', '21', '1', '5', '8', '48', '34', '16', '4'). Guárdalo con el nombre v. La función table() también funciona con elementos numéricos, así que crea una tabla de frecuencias de v. Ordena el vector v de forma descendente. Se desea categorizar a v en 3 grupos (los menores a 4, los mayores o igual a 4 pero menores a 31 y los restantes), por lo que hay que hacer lo siguiente Crea distintos vectores que contengan sólo los elementos que caen dentro de cada categoría. Agregar nombres a los vectores de acuerdo al grupo que pertenecen. Pueden usar la función rep(). Los nombres serán el número de grupo (Uno, Dos y Tres). Une los anteriores vectores en un nuevo vector (puede ser un factor o no). Obtén una tabla de frecuencias para mostrar la cantidad de elementos por cada categoría. Obtén los nombres del vector que se obtuvo al final del punto 5 y guárdalo como una nueva variable. Crea un vector numérico con los datos 1, 2, 3 y con nombres “Uno”, “Dos” y “Tres”. Utiliza character subsetting para obtener un vector de 1, 2 y 3 con el vector de nombres que se menciono al inicio de este ejercicio. Obtén la raíz cuadrada de los primeros 100 números naturales. Crea un vector numérico y eleva cada elemento a la potencia determinada por la longitud de ese vector. Crea un vector numérico y eleva cada uno de sus elementos al cubo sin usar el operador ^ ni **. Con los datos del inciso 1 y con la función seq_along(), crea un vector con los datos antes mencionados pero que sus nombres sean una indexación de estos. Con los siguientes datos c('14', '1', '12', '27', '5', '38', '9', '29', '21', '19', '34', '18', '22', '1','26', '18','36', '28', '24','39','36', '21', '36', '28', '8', '13'), crea un vector booleano determinando que elementos son menores a 26 y con ese vector booleano concluye cuantos datos son menores a 26 y cuantos no lo son. Crea una lista con cinco elementos donde, al menos dos, deben ser listas que contengan listas a su vez. Se desea crear una lista de 10 elementos con las siguientes secuencias de números: c(1, 2, 3, ..., 10), c(11, 12, ..., 20), ..., c(91, 92, ..., 100). Además cada elemento debe tener nombre. En la lista anterior, cambia el vector c(40, ..., 50) por c(50, 49, ..., 40) sin escribir explícitamente ese vector. Agrega tu nombre como un atributo a cualquier vector anterior y a la lista del punto 13 y convierte la lista a un vector. "],
["estructuras-de-datos.html", "3.3 Estructuras de datos", " 3.3 Estructuras de datos La mayoría de las bases datos contienen más de una variable de acuerdo a una cantidad de observaciones y no necesariamente los datos tiene que ser del mismo tipo de dato. En caso de que se deseara ejecutar algún algoritmo para la manipulación de estos, bien se podría tomar cada variable como un vector y ser ingeniosos y cuidadosos para relacionar todos esos vectores y obtener resultados útiles. Esta manera de trabajar no es eficiente ni la más recomendable, ya que se dedicará una mayor cantidad de tiempo a la programación y una menor a la obtención de resultados. Existen muchas estructuras de datos y aunque todas pueden ser adaptadas a un lenguaje de programación, cada lenguaje tiene estructuras básicas para trabajar. Java tiene los arreglos y otro tipo de estructuras en ciertas librerías como listas, pilas y colas. Python tiene diccionarios y mediante la librería pandas utiliza marcos de datos (data frames). En el caso de R también se tienen esta última y otras más. La siguiente imagen resume las estructuras de datos en R. Fuente: Hands-On Programming with R. 3.3.1 Vectores Ya se ha tratado esta estructura pero faltan algunas cosas por ver. ¿Qué sucede cuando se ejecuta el siguiente código? c(TRUE, 1,2,5,9.4). Lo que sucede aquí es llamado coercion. En otros lenguajes de programación esto puede ser entendido como promoción y casteo, pero en este caso no es necesario hacer una declaración explicita del tipo de dato al que se desea convertir. La coerción se aplicará en cualquier estructura que use vectores. Fuente: Hands-On Programming with R. En la imagen anterior quedan claras las reglas que se tienen al hacer coerción. Por ejemplo, ¿Qué tipo de vector resultará en las siguientes instrucciones? c(&quot;1&quot;, &quot;2&quot;, 3) c(4, &quot;a&quot;, TRUE) 4 == &quot;4&quot; 1 &lt; FALSE &quot;a&quot; != FALSE Así como se tienen funciones para verificar si un vector es de algún tipo, también es fácil recordar las funciones para cambiar un tipo de dato a otro; en este caso en lugar de comenzar con el prefijo is., se usará as. dando así las funciones as.double(), as.character, etc. Y esto no se limita a los vectores atómicos, ya que ciertas estructuras se pueden convertir a otras, aunque hay que tener en cuenta que ciertos atributos pueden eliminarse o que en ciertas ocasiones no será posible hacer la conversión. Finalmente, al tener una estructura que contiene datos, es de esperar una sintaxis para obtener los elementos que la componen. En el caso de los vectores, la obtención de los elementos interiores se puede hacer mediante de diferentes maneras. Posición de un elemento: (1:10)[[3]]. (1:10)[3] ¿Cuál es la diferencia entre [[ o [ ? Hint: ?'[['. Posición mediante un vector: (1:10)[seq(1, 10, by = 2)]; (1:10)[c(4,5)]. Mediante filtros (subsetting) (1:10)[(1:10)&lt;4]. Con nombres. Un atributo que tienen los vectores es llamado names, el cual otorga un nombre a cada uno de los elementos interiores del vector. vec_altura &lt;- c(1.50, 1.60, 1.72, 1.55) names(vec_altura) &lt;- c(&quot;José&quot;, &quot;Raúl&quot;, &quot;Cecilia&quot;, &quot;Camila&quot;) vec_altura[[&quot;José&quot;]] [1] 1.5 Por último, véase la aplicación tablas de búsqueda (Character subsetting) que otorga el subsetting en los vectores. datos_frutas &lt;- c(&quot;M&quot;, &quot;Ma&quot;, &quot;S&quot;, &quot;M&quot;, &quot;S&quot;, &quot;Ma&quot;) frutas &lt;- c(M = &quot;Manzana&quot;, Ma = &quot;Mango&quot;, S = &quot;Sandía&quot;) frutas[datos_frutas] M Ma S M S Ma &quot;Manzana&quot; &quot;Mango&quot; &quot;Sandía&quot; &quot;Manzana&quot; &quot;Sandía&quot; &quot;Mango&quot; unname(frutas[datos_frutas]) [1] &quot;Manzana&quot; &quot;Mango&quot; &quot;Sandía&quot; &quot;Manzana&quot; &quot;Sandía&quot; &quot;Mango&quot; 3.3.2 Listas Las listas son una estructura de datos muy útil por la forma en la que esta codificada, ya que esta nos ayuda a tener vectores en su interior y de diferentes tipos. Comúnmente se le conoce a las listas como vectores recursivos, ya que una lista puede contener listas en su interior (las listas son otro tipo de objeto así que no hay restricciones para hacer listas de listas). Como bien indica una de las imágenes anteriores, las listas tienen una dimensión, lo cual no se debe confundir con su longitud, la cual es la cantidad de elementos que esta contiene. El constructor por defecto es list() y el tipo es list. Se pueden dar nombres a los elementos de las listas de la siguiente manera: list(\"nombre\" = datos) No es necesario dar nombres para construir una lista list(c(1,5), 1:10) [[1]] [1] 1 5 [[2]] [1] 1 2 3 4 5 6 7 8 9 10 Los elementos internos de una lista, al tener la posibilidad de ser diferentes, se pueden tener diferentes tamaños. list(1:2, 1:10, letters[1:5]) [[1]] [1] 1 2 [[2]] [1] 1 2 3 4 5 6 7 8 9 10 [[3]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; Se tiene la función is.list() y as.list() como cualquier otra estructura de datos en R. Esta sería una forma de hacer una lista de listas list(list(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;), &quot;numeros&quot; = list(1:10,1:5, 10:20, -3:-5)) [[1]] [[1]][[1]] [1] &quot;a&quot; [[1]][[2]] [1] &quot;b&quot; [[1]][[3]] [1] &quot;c&quot; $numeros $numeros[[1]] [1] 1 2 3 4 5 6 7 8 9 10 $numeros[[2]] [1] 1 2 3 4 5 $numeros[[3]] [1] 10 11 12 13 14 15 16 17 18 19 20 $numeros[[4]] [1] -3 -4 -5 Como las listas y los vectores son de una dimensión, estas estructuras tiene algunas características en común; ambas tienen una longitud y puede determinarse su tipo (typeof(vector(), typeof(list())). Además en ambas se les puede asignar nombres y otros atributos que se deseen para dar meta data a las estructuras. Para dar un nuevo atributo se puede usar la función attr(). lista_1 &lt;- list(&quot;numeros&quot; = c(1,2,3), &quot;letras&quot; = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), &quot;ambos&quot; = c(1,2,&quot;3&quot;, &quot;4&quot;)) attr(lista_1, &quot;meta&quot;) &lt;- &quot;Más datos&quot; attr(vec_altura, &quot;atributo_extra&quot;) &lt;- &quot;Más datos&quot; attributes(lista_1) $names [1] &quot;numeros&quot; &quot;letras&quot; &quot;ambos&quot; $meta [1] &quot;Más datos&quot; attributes(vec_altura) $names [1] &quot;José&quot; &quot;Raúl&quot; &quot;Cecilia&quot; &quot;Camila&quot; $atributo_extra [1] &quot;Más datos&quot; Al usar la función structure(), no es necesario usar la función attr() para agregar un nuevo atributo. structure(seq(2,20, by = 2), paridad = &quot;Pares&quot;) [1] 2 4 6 8 10 12 14 16 18 20 attr(,&quot;paridad&quot;) [1] &quot;Pares&quot; ¿Qué sucede al hacer structure(seq(2,20, by = 2), comment = \"Pares\")? En general, para ver la composición de una estructura, La función str() es de grán utilidad ya que dará de manera resumida esta composición. str(vec_altura) Named num [1:4] 1.5 1.6 1.72 1.55 - attr(*, &quot;names&quot;)= chr [1:4] &quot;José&quot; &quot;Raúl&quot; &quot;Cecilia&quot; &quot;Camila&quot; - attr(*, &quot;atributo_extra&quot;)= chr &quot;Más datos&quot; str(lista_1) List of 3 $ numeros: num [1:3] 1 2 3 $ letras : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; $ ambos : chr [1:4] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; - attr(*, &quot;meta&quot;)= chr &quot;Más datos&quot; Al poder acceder a los elementos de un vector o una lista, es sencillo cambiar el contenido de estos. lista_1[[&quot;numeros&quot;]] &lt;- 2:4 lista_1 $numeros [1] 2 3 4 $letras [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; $ambos [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; attr(,&quot;meta&quot;) [1] &quot;Más datos&quot; vec_altura[vec_altura&lt;1.60] &lt;- 1.50 vec_altura José Raúl Cecilia Camila 1.50 1.60 1.72 1.50 attr(,&quot;atributo_extra&quot;) [1] &quot;Más datos&quot; El acceso a una lista puede ser de diferentes maneras Mediante el nombre del elemento: lista_1[[\"numeros\"]] o lista_1$numeros. Mediante la posición: lista[[1]] ¿Cuál es la diferencia entre lista[[1]] y lista[1]? lista_1$ambos &lt;- NULL str(lista_1) List of 2 $ numeros: int [1:3] 2 3 4 $ letras : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; - attr(*, &quot;meta&quot;)= chr &quot;Más datos&quot; Lo anterior es un ejemplo de como borrar elementos de una lista. ¿Esto se puede hacer con un vector? ¿Si, no, porqué? 🤷 Hint: ¿Qué sucede al hacer lo siguiente? v &lt;- 1:10; v[5] &lt;- \"5\". ¿Es posible convertir una lista a un vector? Sí, pero ¿Por qué as.vector(lista_1) sigue siendo una lista? ¿Qué hace unlist()? ¿Qué atributos permanecen al hacer hacer una correcta conversión? 3.3.3 Arreglos Todos aquellos que ya hayan tenido algún acercamiento con algún lenguaje de programación como Java, C, C++, Python, etc. conocen lo importante que pueden ser los arreglos, los cuales son una colección de elementos con ciertas posiciones. Además del simple hecho de poder almacenar elementos en un solo objeto, es de gran importancia lograr manejar matrices para realizar distintas operaciones y obtener ciertos resultados para diferentes problemas del ámbito científico. Como bien se indica en el diagrama donde se presentan las diferentes estructuras de datos que tenemos disponibles en R, las matrices y los arreglos solo aceptan un sólo tipo de dato como los vectores. De hecho, véase que internamente, los constructores de una matriz y un arreglo (matrix() y array()) tienen que convertir, en caso de que sea necesario, el input a un vector. #matrix(): . . if (is.object(data) || !is.atomic(data)) data &lt;- as.vector(data) . . } #array(): . . data &lt;- as.vector(data) . . } Por lo que una matriz y un array los podemos considerar vectores, solo que con diferentes dimensiones. Solo para aclarar, al momento de ingresar listas o matrices a estos constructores, todo será llevado a vectores y se realizará, en caso de ser necesario, coerción y reciclaje. ¿Qué sucede al ejecutar matrix(list(1,2,3,4))? Considérese los siguientes puntos cuando se desea construir una matriz o cuando se trabaje con ellas. Se tienen las correspondientes funciones is.matrix() y as.matrix(). El constructor matrix() en su primer argumento solicita los datos los cuales pueden ser cualquier vector. matrix(1:10) [,1] [1,] 1 [2,] 2 [3,] 3 [4,] 4 [5,] 5 [6,] 6 [7,] 7 [8,] 8 [9,] 9 [10,] 10 Automáticamente matrix() dispone de sus elementos en forma columnar. El constructor de las matrices permite agregar el número de renglones y columnas. matrix(1:10, nrow = 5, ncol = 2) [,1] [,2] [1,] 1 6 [2,] 2 7 [3,] 3 8 [4,] 4 9 [5,] 5 10 La matriz se rellena en base a columnas, pero esto puede ser modificado. ¿Cómo? [,1] [,2] [1,] 1 2 [2,] 3 4 [3,] 5 6 [4,] 7 8 [5,] 9 10 Se puede acceder a los elementos de una matriz de manera análoga a los vectores y listas solo que considerando las dos dimensiones. matrix(1:10, nrow = 5, ncol = 2, byrow = TRUE)[1,1] [1] 1 Si no se indica algún valor, o ambos, para alguna dimensión, R entenderá que se desea abarcar toda esa dimensión. matrix(1:10, nrow = 5, ncol = 2, byrow = TRUE)[,2] [1] 2 4 6 8 10 También es posible acceder mediante nombres en una matriz. En este caso existe la distinción entre renglones y columnas, y las correspondientes funciones para obtener y modificar los nombres son rownames() y colnames(). m &lt;- matrix(1:10, nrow = 5, ncol = 2, byrow = TRUE) rownames(m) &lt;- paste(&quot;Row&quot;, 1:5) colnames(m) &lt;- paste(&quot;Column&quot;, 1:2) m Column 1 Column 2 Row 1 1 2 Row 2 3 4 Row 3 5 6 Row 4 7 8 Row 5 9 10 m[&quot;Row 5&quot;,&quot;Column 2&quot;] [1] 10 Al igual que en los vectores, se puede acceder mediante vectores booleanos o expresiones que resulten en vectores booleanos. m[1,m[1,]&lt;2] [1] 1 El equivalente de length() en vectores, se divide en nrow() y ncol(); además de la función dim() para obtener ambos resultados cat(&quot;nrow: &quot;,nrow(m), &quot;\\nncol: &quot;,ncol(m), &quot;\\ndim:&quot;, &quot;c(&quot;,dim(m),&quot;)&quot;) nrow: 5 ncol: 2 dim: c( 5 2 ) La función dim() se puede usar para modificar la estructura de una matriz; aunque esto puede ocasionar una pérdida de atributos. dim(m) &lt;- c(2,5) m [,1] [,2] [,3] [,4] [,5] [1,] 1 5 9 4 8 [2,] 3 7 2 6 10 La función anterior puede usarse también con vectores. Al hacer esto ¿El resultado es una matriz? Compruébelo. vec &lt;- 1:10 dim(vec) &lt;- c(5,2) vec [,1] [,2] [1,] 1 6 [2,] 2 7 [3,] 3 8 [4,] 4 9 [5,] 5 10 Con las funciones cbin() y rbind() se pueden unir matrices por columna o por renglón. first &lt;- 1:10 second &lt;- 2:11 cbind(first, second) first second [1,] 1 2 [2,] 2 3 [3,] 3 4 [4,] 4 5 [5,] 5 6 [6,] 6 7 [7,] 7 8 [8,] 8 9 [9,] 9 10 [10,] 10 11 Las matrices son de uso recurrente en el álgebra lineal, por lo que se desearía realizar algunas operaciones básicas entre ellas; R proporciona estas así como algunas funciones importantes. Supongamos que \\(\\mathcal{A}\\) y \\(\\mathcal{B}\\) son matrices definidas en R. Operaciones básicas Adición:\\(\\mathcal{A}\\)+\\(\\mathcal{B}\\). Sustracción: \\(\\mathcal{A}\\)-\\(\\mathcal{B}\\). Multiplicación por un escalar: \\(c\\)*\\(\\mathcal{A}\\). Producto matricial: \\(\\mathcal{A}\\)%*%\\(\\mathcal{B}\\). Funciones básicas Transpuesta: t(). Diagonal: diag(). Devuelve la diagonal de una matriz o crea una matriz diagonal. Determinante: det(). Inversa: solve(). solve() también resuelve un sistema de ecuaciones dado. Varianza: var(). Vectores y valores propios: eigen(). Hay que tener en cuenta la teoría sobre estas operaciones o funciones ya que será relevante las dimensiones de las matrices; por ejemplo si las matrices son cuadradas para obtener el determinante o la inversa o si las dimensiones de \\(\\mathcal{A}\\) y \\(\\mathcal{B}\\) son adecuadas para aplicar, por ejemplo, la multiplicación entre ellas. Para ver algunas otras funciones que se pueden aplicar en las matrices véase los enlaces 1 y 2. Finalmente, cuando se desea crear un arreglo con un número mayor de dimensiones, se puede utilizar el constructor array() donde se pueden indicar las dimensiones como parámetro, por ejemplo array(1:16, c(2,2,4)). Las operaciones básicas funcionan correctamente en este tipo de estructura pero la mayoría de las funciones, al menos todas las mencionadas, no trabajan bien al tratar con arreglos ya que las funciones anteriores solicitan arreglos de dos dimensiones. ¿Una matriz es un arreglo y un arreglo es una matriz? 3.3.4 Data Frames Al trabajar con matrices se debe estar consciente de que cada uno de sus elementos es de un solo tipo, lo cual puede resultar problemático al tratar con una base de datos donde se tengan datos numéricos y categóricos o incluso cuando se desee agregar una columna de otro tipo de objetos como lo son las gráficas. Aquella estructura de datos que dos dimensiones que acepta diferentes tipos de datos por columna se le llama Data Frame. La mayoría de las bases de datos se trabajan con un data frame y por convención a las columnas se les llama variables y a los renglones observaciones. La construcción de un data frame se puede hacer mediante el constructor por defecto data.frame() donde el contenido de este es similar al de una lista, ya sea dando los nombres desde la creación o posteriormente. Por ejemplo: data.frame(c1 = 1:5, c2 = letters[1:5], c3 = list(1,2,3,4,5), c4 = matrix(0,5,2)) c1 c2 c3.1 c3.2 c3.3 c3.4 c3.5 c4.1 c4.2 1 1 a 1 2 3 4 5 0 0 2 2 b 1 2 3 4 5 0 0 3 3 c 1 2 3 4 5 0 0 4 4 d 1 2 3 4 5 0 0 5 5 e 1 2 3 4 5 0 0 Hay que notar lo siguiente del anterior ejemplo. Los vectores son tomados de manera columnar como en las matrices. Los caracteres son considerados como factores; esto puede cambiar modificando el parámetro stringsAsFactors del constructor. Por cada elemento de la lista se agrego una columna. Las matrices son tomadas con la misma estructura en cuanto a los renglones y columnas. Estos puntos son considerados en cuenta cuando se desea convertir algún otro objeto en data frame con la función as.data.frame(). Se debe ser cuidadoso con el número de observaciones en cada variable, ya que estos deben ser iguales, lo cual puede ser relevante al usar las funciones rbind() y cbind() entre data frames. En general, estas funciones deben usarse si alguno de los objetos implicados es un data frame, en caso de que alguno no lo sea y ambos sean vectores, las funciones crearán primero una matriz aplicando coerción y dando problemas en la construcción del data frame. El constructor de una data frame, data.frame(), es más robusto que el constructor de una matriz, matrix(), ya que aquí se deben mantener las estructuras en las columnas; por ejemplo una columna de listas no deben convertirse en una columna de números como en el caso de una matriz para una sola lista. Si se desea tener una columna de listas y no distribuir los elementos de la lista en las columnas de data frame, se puede utilizar la función I() la cual ayuda a tratar un objeto como el mismo y así no aplicarle algún tipo de transformación. (df &lt;- data.frame(numbers = 1:3, listas= I(list(num_list = 1:10,letras = letters,listas = list(1,2,3,4))))) numbers listas num_list 1 1, 2, 3,.... letras 2 a, b, c,.... listas 3 1, 2, 3, 4 Al igual que las listas, el acceso puede ser mediante los nombres y posición además de vectores booleanos, agregando el acceso que se aplica en las matrices. df$listas$letras [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; df[[&quot;numbers&quot;]] [1] 1 2 3 df[1,2] $num_list [1] 1 2 3 4 5 6 7 8 9 10 df[1,2]$num_list [1] 1 2 3 4 5 6 7 8 9 10 df[2,c(typeof(df$numeros), typeof(df$listas))==&quot;list&quot;] $letras [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; Es posible agregar nombres a los renglones de un data frame como en una matriz. row.names(df) &lt;- 1:3 df numbers listas 1 1 1, 2, 3,.... 2 2 a, b, c,.... 3 3 1, 2, 3, 4 ¿Qué sucede al usar la función as.matrix() con el anterior data frame? ¿Se puede cambiar la dimensión de un data frame como en una matriz usando la función dim()? ¿Se pueden aplicar operaciones básicas entre data frames? ¿Cuáles y en que caso? No esta de más mencionar que hay otro tipo de objeto en R llamado expresiones. Estas son importantes al momento de desarrollar una función a un nivel más profesional. En este libro no se tratará dicho tema pero se puede estudiar a profundidad de esto en el libro Advance R. Aquí se deja un simple ejemplo de tal objeto. x &lt;- 3 y &lt;- 2.5 z &lt;- 1 exp &lt;- expression(x/(y + exp(z))) Ejercicios La siguiente instrucción genera un vector con valores numéricos y NA: sample(c(1:20, rep(NA,15))). El anterior vector se debe guardar con el nombre de random_NA y Usando algún ciclo, determine cuantos valores NA hay en random_NA. Utilizando los conocimientos de coerción, la función sum() y lo que sea necesario, determinar cuantos valores NA existen en random_NA. Crea una función que, dado un vector, se determine la cantidad de valores perdidos en él. Crear un función que, dado un número se cree una matriz que contenga solo ese número. El número de renglones y columnas debe también ser dado en los parámetros de la función. Usando algún ciclo, crear una función llamada suma_gauss en la que se tendrá que simular el proceso para la suma de los primeros \\(n\\) números en \\(\\mathbb{N}\\). No se debe utilizar la formula de manera directa. Crear una matriz, sin tener que usar algún ciclo, de 0s y 1s alternados. Aquí un ejemplo [,1] [,2] [,3] [,4] [1,] 0 1 0 1 [2,] 1 0 1 0 [3,] 0 1 0 1 [4,] 1 0 1 0 [5,] 0 1 0 1 Crear un data frame de la siguiente matriz. [,1] [,2] [,3] [,4] [,5] [1,] 1 25 81 169 289 [2,] 4 36 100 196 324 [3,] 9 49 121 225 361 [4,] 16 64 144 256 400 Crear un data frame con 5 variables y al menos 3 observaciones. La primera variable corresponderá a nombres de una persona, las demás representarán la edad, altura, peso y nacionalidad de cada individuo. Se puede usar la función sample(). En el anterior data frame, agregar una sexta variable que represente los videojuegos que tiene cada usuario. Los datos deben ser los siguientes: list(juegos = c(\"Horizon-Zero-Dawn\", \"bloodborne\")), list(juegos = c(\"Mario-Kart\", \"Mario Maker\", \"Mario Odyssey\")), list(c(\"Halo\", \"Batman Arkham Knight\", \"Injustice\")). Si hacen falta más datos, crearlos o replicar los ya dados. Crear un función que regrese una lista donde cada elemento de la lista tendrá el nombre de cada una de las estructuras y los tipos de datos ya vistos y su contenido será un vector booleano indicando si, de acuerdo al parámetro de la función, se es de alguna clase de las ya vistas. Por ejemplo, si se da como input una matriz de caracteres, la lista resultante en la posición [[\"Matriz\"]] y en [[\"Caracter\"]] deben contener el valor TRUE. Obtener la siguiente matriz usando la función paste(). [,1] [,2] [,3] [,4] [,5] [1,] &quot;a A&quot; &quot;e E&quot; &quot;i I&quot; &quot;m M&quot; &quot;q Q&quot; [2,] &quot;b B&quot; &quot;f F&quot; &quot;j J&quot; &quot;n N&quot; &quot;r R&quot; [3,] &quot;c C&quot; &quot;g G&quot; &quot;k K&quot; &quot;o O&quot; &quot;s S&quot; [4,] &quot;d D&quot; &quot;h H&quot; &quot;l L&quot; &quot;p P&quot; &quot;t T&quot; Del data frame del inciso 22, obtener mediante una expresión lógica las columnas, que de acuerdo al primer renglón, contengan valores menores a 150. Crea una lista que contenga al menos cada una de las estructuras ya vistas. Crear una función que, dadas dos matrices, se verifique si estas son aptas para aplicarles las operaciones fundamentales suma y sustracción y regresar dichos resultados en una lista; en caso de que sean aptas para la multiplicación agregar este resultado a la lista de retorno. Crear un ciclo dentro de una función donde, de acuerdo a un data frame de entrada, y utilizando la primera observación del data frame, se determine el tipo de variable que contiene el data frame en cada columna. Finalmente todos los resultados deben ser devueltos en un vector. "],
["sentencias-de-control-ciclos-y-funciones.html", "3.4 Sentencias de control, ciclos y funciones", " 3.4 Sentencias de control, ciclos y funciones Todo el conocimiento ya obtenido no sería útil a largo plazo si no se tiene alguna manera de controlar el comportamiento del código bajo ciertas circunstancias, ya sea permitiendo ciertos bloques de código, repitiendo o ejecutando una cantidad determinada o indeterminada de veces un cierto proceso o aplicar ciertas transformaciones a los resultados. Por todas estas razones comenzaremos con la estructura de control más básica. 3.4.1 If &amp; If-else La estructura if() permite la ejecución de un cierto bloque de código si el parámetro booleano que recibe tiene por valor TRUE, lo cual indicaría que la condición necesaria para la ejecución del bloque es válida. Recordemos que un valor TRUE, y en general un booleano, se puede obtener mediante diferentes expresiones usando operadores lógicos. if(boolean) { código } Ahora, suponiendo que se desea tratar el simple problema de determinar si un usuario, de acuerdo a su edad, puede ver cierto contenido. Se puede actuar de la siguiente manera if(edad&gt;=18) { Permitir_contenido } if(edad == 17){ No_permitir_contenido } if(edad == 16){ No_permitir_contenido } . . . if(edad == 0){ No_permitir_contenido } O bien de la siguiente manera if(edad&gt;=18) { Permitir_contenido } if(edad &lt; 18){ No_permitir_contenido } En cualquiera de los dos casos es necesario tratar el complemento con otra sentencia if() lo cual no es recomendable cuando no se tenga certeza de todos los casos contrarios a la condición en el primer if. Por lo cual, para tomar el complemento, se tiene la sentencia if-else; donde si sucede la condición, se ejecuta el código dentro de los delimitadores del if y en caso contrario (else) se ejecuta lo correspondiente para el complemento de la condición. if(edad&gt;=18) { Permitir_contenido }else{ No_permitir_contenido } Existe en R la función ifelse() la cual permite trabajar de manera vectorial. Véase el siguiente ejemplo #Se crea un vector con 15 edades de personas de manera &quot;aleatoria&quot; (edades &lt;- sample(1:90, replace = T, size = 15)) [1] 29 59 7 69 30 49 61 13 23 15 28 40 34 63 28 ifelse(edades&lt;18, yes = &quot;Menor de edad&quot;, no = &quot;Mayor de edad&quot;) [1] &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Menor de edad&quot; &quot;Mayor de edad&quot; [5] &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Menor de edad&quot; [9] &quot;Mayor de edad&quot; &quot;Menor de edad&quot; &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; [13] &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; Es decir, que en cada entrada del vector evalúa la expresión dada y en caso de ser cierta la condición, se devuelve, en este caso, el caracter “Menor de edad” y en caso contrario “Mayor de edad”. Véase que la función ifelse() regresa un vector. 3.4.2 For, While y Repeat Cuando un programador ve que un proceso se debe repetir una cantidad de veces, automáticamente piensa en un bucle. En el caso de R se tienen los ciclos for(), while() y repeat(). Recordando que en Java los primeros dos bucles tenían una estructura similar a la siguiente: for(int i = 0; i&lt;n; i++){ Ejecución del código n veces } while(boolean){ Ejecución del código hasta que el booleano sea false } En el caso de R se tendrá una estructura un poco diferente ya que se iterará directamente sobre un objeto y no usando una variable auxiliar que evalué una expresión para obtener un booleano y determine si el ciclo termino. En el caso del ciclo while se tiene la misma sintaxis. for(elementos in objeto){ Ejecución_del_código } while(boolean){ Ejecución_del_código } Véase los siguientes ejemplos for(number in 1:5){ print(number + 1); } [1] 2 [1] 3 [1] 4 [1] 5 [1] 6 Se esta usando directamente cada elemento dentro del vector para ejecutar un cierto bloque de código. Hay que aclarar que no es necesario usar el elemento con el que se está iterando aunque es común hacerlo. ¿Funcionará con una lista o una matriz? for(letra in letters[1:5]){ print(paste(&quot;Letra &quot;, letra)) } [1] &quot;Letra a&quot; [1] &quot;Letra b&quot; [1] &quot;Letra c&quot; [1] &quot;Letra d&quot; [1] &quot;Letra e&quot; En el anterior código se esta usando otro vector, el cual es no numérico, dando un mejor ejemplo de que el iterador no esta dependiendo de valores numéricos. edad &lt;- c(20,24,41,17,20) n_cliente &lt;- 1 control_parental &lt;- TRUE while(control_parental){ if(edad[n_cliente]&gt;=18){ print(&quot;Apto para la película&quot;) n_cliente &lt;- n_cliente+1 }else{ print(&quot;Menor de edad&quot;) control_parental &lt;- F } } [1] &quot;Apto para la película&quot; [1] &quot;Apto para la película&quot; [1] &quot;Apto para la película&quot; [1] &quot;Menor de edad&quot; Aquí se están usando expresiones de control para determinar la salida del bucle. Hay que recordar que en un ciclo while se corre el peligro de entrar en un ciclo infinito, el cual sería lo deseado en algunos casos. Un ciclo que se trata con un bucle tipo for siempre puede ser tratado como uno tipo while pero no siempre el caso contrario. Y que la elección entre un ciclo while y uno for depende de si se conoce el número de veces que se ejecutará un bloque o no. ¿Existe algo equivalente al switch-case visto en Java? Para estos dos ciclos se puede hacer uso de las sentencias break y next, las cuales permiten la interrupción de un ciclo y la exclusión de alguna iteración. for(letra in letters){ if(letra == &quot;f&quot;) break print(letra) } [1] &quot;a&quot; [1] &quot;b&quot; [1] &quot;c&quot; [1] &quot;d&quot; [1] &quot;e&quot; Cuando se ejecuta repeat el ciclo termina sin importar la existencia de más iteraciones sobre el objeto. for(letra in letters){ if(any(letra == letters[4:24])) next print(letra) } [1] &quot;a&quot; [1] &quot;b&quot; [1] &quot;c&quot; [1] &quot;y&quot; [1] &quot;z&quot; Para el caso de next, véase que se saltó ciertas iteraciones más no termino el ciclo. Finalmente, R proporciona la estructura break, en la cual puede encontrarse cierta similitud con un ciclo while o do-while. repeat{ . . ejecución_código . . break } Este bucle se detiene cuando se encuentra a la sentencia break. n_saludos &lt;- 5 repeat{ print(rep(&quot;Hola&quot;, n_saludos)) #Se detiene el repeat cuando n_saludos sea igual a 1 if(n_saludos==1){ break } n_saludos &lt;- n_saludos-1 } [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; Existe un “problema” con los ciclos en R debido a las configuraciones internas para el almacenamiento de objetos. Por el momento es suficiente saber que trabajar de manera vectorial o aplicar funciones que están en R de manera predeterminada es una mejor y más rápida forma de trabajar. Más adelante se verá en que casos los ciclos pueden ser “lentos” además de otros problemas que pueden surgir, por ejemplo en la recursión, y cuando será la mejor opción usar un ciclo que alguna función que trabaje de manera vectorial. 3.4.3 Funciones Como ya se había mencionado, R es un lenguaje de programación orientado a objetos aunque también tiene ciertas características de un lenguaje funcional ya que las funciones en R pueden considerarse funciones de primera clase; es decir que pueden ser asignadas a variables, ser almacenadas en ciertas estructuras como las listas, servir como parámetros de otras funciones y ser el retorno de otras funciones. Aunque estas no pueden ser consideradas, como bien dice Handley Wickham en su libro RAdvance, puras; es decir funciones de orden superior ya que, para que una función sea considerada de orden superior, de acuerdo a un input dado, se debe tener una única salida (inyectividad) lo cual no sucede con muchas funciones en R como sample(), runif(), print() y hasta en &lt;-(). Sin importar que las funciones no sean de orden superior, lo cual otorga cierta flexibilidad, es indudable la importancia de crear funciones para optimizar el trabajo, dar estructura, limpieza e incluso claridad; ya que al usar una función, el resultado será algo esperado sin importar su comportamiento interno; en cambio al visualizar un ciclo, este puede no quedar claro en su funcionamiento. La creación de funciones es sencilla nombre_function &lt;- function(parámetros){ código } Los parámetros pueden ser cualquier objeto e incluso funciones. En este último caso, a estas funciones se les llama funcionales. El retorno de una función puede quedar explícitamente dado con la función return() aunque si no se utiliza esta función, la última línea de código en la función es considerada como el retorno de la función. El retorno puede ser cualquier tipo de objeto e incluso pueden devolver funciones. En este último caso, a estas funciones se les llama function factory. Cuando una función tiene como valor de retorno un booleano, a esta función se le conoce como predicate y cuando una función acepta una o más funciones como parámetros y a su vez regresa funciones, se les conoce a estas funciones como function operator. Los parámetros de una función pueden tener valores por defecto, los cuales pueden ser reescritos cuando se den explícitamente otros valores. suma &lt;- function(v1 = c(1,2), v2 = c(3,4)){ sum(v1, v2) } suma() [1] 10 suma(v1 = 4, v2 = 1:20) [1] 214 Algo interesante de las funciones en R, al igual que en Python, es que se pueden dar una cantidad indeterminada de parámetros si así se indica en la función con el argumento .... Véase el siguiente ejemplo. #v1 y v2 vectores numéricos suma &lt;- function(v1, v2, ...){ sum(v1, v2, ...) } Es decir, que se está considerando ... como un parámetro más de la función aunque nótese que no es necesario agregar más de dos variables en la función. suma(c(1,2), 1:4) [1] 13 suma(c(1,2), 1:4, 1:20) [1] 223 Ejercicios Crear un nuevo operando y utilizarlo con dos vectores. En el siguiente enlace se puede encontrar información sobre la función replicate. Teniendo en mente que la anterior función puede remplazar a un ciclo for, realice el ejercicio 16 utilizando dicha función. Vea que sucede al utilizar el parámetro simplify con los valores FALSE y TRUE. Aplicar las funciones min() y max() en la matriz del ejercicio 22 sobre los renglones y columnas. Con la lista creada al momento de explicar la función lapply(): list(a = seq_matrix, b = seq_matrix+1, c = seq_matrix+3), utilizar tal lista, la función lapply() y una función anónima, para sumarle 5 al elemento [2,3] de cada matriz. Con base en el ejercicio anterior, hacer una función que acepte una lista (como la del anterior ejercicio), un parámetro tipo String; los posibles valores de este serán “suma”, “resta”, “mutl”, “div”; también debe aceptar tres parámetros numéricos, el primero servirá como operando de las operaciones anteriores y los siguientes como coordenadas para ubicar el elemento en las matrices. De acuerdo a las operaciones anteriores, realizar pora cada caso con la función lapply y una función anónima la operación correspondiente al elemento designado por los parámetros de la función. Observese que sucede al ejecutar (1:10)[-1]. Obtener de la lista del ejercicio 13 los últimos 5 elementos de cada vector. Crear una función que, dada una lista, se determine que tipo de datos son sus elementos. Imprimir una sequencia de vectores con sapply(). Crear un nuevo operando que sea capaz de concatenar un número con una letra. Utilizar la función del ejercicio anterior para concatenar a los elementos de una matriz de caracteres un número. Utilizar el operando anterior para concatenar un número a todos los elementos de la matriz del ejercicio 26. Usando la función which(), obtener los resultados solicitados del ejercicio 11. Usando alguna función de la familia apply y una función anónima, obtener los resultados solicitados del ejercicio 11. Obtener el máximo y mínimo de cada uno de los elementos en la lista del ejercicio 13. Crear una función que acepte una matriz y devuleva una lista con dos elementos: “StatsColumns” y “StatsRows”; los cuales deben ser listas y contener los resultados de aplicar las funciones sum(), prod(), sqrt(sum()) y cumsum() por renglones y columnas. "],
["funciones-1.html", "3.5 Funciones", " 3.5 Funciones El tema de las funciones es algo extenso, por lo que se dará de manera resumida el contenido necesario para entender gran parte del funcionamiento de estas en R. Una de las mejores fuentes de información la pueden encontrar en el libro Advance R, específicamente en los capítulos 6 y 7; para explorar más sobre este tema se puede consultar la segunda parte de la misma referencia. Finalmente, se verá como usar vectorización, una de las fuertes habilidades de R, y por último una serie de funciones que podrían ser de gran utilidad en ciertos temas. Particularmente en la programación con R, será de mucha utilidad aprender a crear funciones: funcionfactorial&lt;-function(a){ res &lt;- 1 if(a&lt;0){ return(&quot;No existen factoriales de números negativos.&quot;) } else if(a==0){ return(res) } else{ for(i in 1:a){ res &lt;- res*i } return(res) } } 3.5.1 Funciones Una función que crea el usuario se compone de tres partes: los formales, los cuales son los argumentos o los parámetros de una función y que pueden obtenerse con la función formals(), el cuerpo, es decir el código o las rutinas internas de las funciones que se pueden obtener con la función body(), y un ambiente, el cual se puede obtener con la función environment() y que básicamente es un lugar donde esta almacenada la información necesaria para el correcto uso de las funciones; más adelante se hablará un poco más de este importante concepto. ¿Qué tipo de estructuras o qué tipo de objetos regresan las anteriores funciones? ¿Cuáles son los tres componentes en la siguiente función? myStrangeFunction &lt;- function(a = 1,b = 4,c,...) sum(prod(a,b), c, ...) Como ya se mencionó, este lenguaje toma ciertas características de un lenguaje funcional, por lo que al tratar a las funciones como objetos es de esperarse la incorporación de atributos a estas. Uno de estos atributos es el llamado srcref (source reference), la cual imprime mejor el cuerpo de alguna función. ¿Con qué función se agregaría un atributo a una función? ¿Cómo se puede obtener el atributo srcref de myStrangeFunction? El output es el siguiente function(a = 1,b = 4,c,...) sum(prod(a,b), c, ...) R contiene ciertas funciones que son añadidas al momento de iniciar su interfaz, las cuales se han agregado a las distintas versiones del lenguaje y a medida que R ha evolucionado se han optimizado estas funciones internas dando un buen rendimiento para su uso cotidiano. Estas funciones son llamadas primitivas y ya se han visto algunas de estas: sum(), prod(), [(), sqrt(), etc. Algunas de las funciones primitivas están implementadas y existen en el lenguaje C, lo cual da garantía de un buen rendimiento. Los tres componentes que se mencionaron antes no los tienen este tipo de funciones y así es posible verificar si una función primitiva existe principalmente en C. ¿Cómo se puede ver si una función es primitiva o no? Si las funciones primitivas otorgan un buen rendimiento ¿Porqué no todas las funciones son primitivas? function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) Para utilizar, o mejor dicho llamar, a una función, basta con escribir su nombre, colocar los argumentos separados por coma dentro de unos paréntesis y ¡listo! Aunque se ha mencionado que + también es una función: '+'(), por lo que hay que discernir las diferentes formas de llamar a una función. prefix: myFunction(arguments). infix: a+b. replacement: colnames(df) &lt;- names. special: [[, if, for, etc. Véase que las propias estructuras de control y los bucles también son funciones y R permite modificar todo aquello que sea función, aunque todas las formas especiales son funciones primitivas. No es recomendable sobre escribir alguna función que ya se tenga preestablecida en R o en alguna librería, pero siempre se tiene la libertad de hacerlo en caso de que se tenga el control y la consciencia suficiente de las consecuencias. Solo para aclarar, véase los siguientes puntos. Todas las funciones se pueden llamar a manera de prefijo. myFunction(a,b,c) `+`(a,b) `colnames&lt;-`(df, names) for(name in names) print(name) `for`(name, names, print(name)) Como + es una función, es posible crear operadores usando % al inicio y al final del operador. Todos los operadores de R se pueden encontrar ejecutando ?Syntax. `%mixOperations%` &lt;- function(a,b) a+b*a/b 4 %mixOperations% 5 [1] 8 Algunas funciones útiles de este estilo son %%, %*%, %/%, %in%, %o% y %x%. ¿Qué hacen cada una de ellas? Es análogo la sintaxis para crear funciones de asignación aunque es necesario tener el formal value. `indexNames&lt;-` &lt;- function(a, value) { names(a) &lt;- as.character(seq_along(a)+value) a } x &lt;- 1:20 indexNames(x) &lt;- 3 x 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Ahora, véase la siguiente función ignoringParameters &lt;- function(x) &quot;Hello!&quot; ignoringParameters(1:30) [1] &quot;Hello!&quot; Sea cual sea el objeto que se de como parámetro al llamar la función, se devolverá el mismo resultado. Esto es posible porque las funciones en R trabajan de manera “perezosa” con sus argumentos, a esto se le llama lazy evaluation. Básicamente, si no es llamado en algún momento un argumento de la función, este no es utilizado y solo cuando se llame al argumento, hasta ese momento se hará el acceso a él. Esto es gracias a la técnica de evaluación lazy evaluation que utiliza R al usar una estructura de datos llamada promise donde, básicamente las variables son evaluadas mediante un ambiente hasta que una expresión las utilice y este valor es guardado (cached), por ejemplo y &lt;- 7 lazilyEvaluated &lt;- function(x, lazy_var = y*a){ print(&quot;Hi!&quot;) y &lt;- 50 a &lt;- 3 print(lazy_var) x*2 } doubleVector &lt;- function(x) c(x,x) doubleVector(lazilyEvaluated(y)) [1] &quot;Hi!&quot; [1] 150 [1] 14 14 Dentro del ambiente de la función, el nombre de la variable y tiene asociado un valor distinto y no tiene consciencia de la variable con el nombre y fuera de él. Al utilizar la variable y como argumento de la función, a esta se le da el nombre de x pero se le asocia el mismo valor de y. El parámetro lazy_var es llamado hasta print(lazy_var), donde antes se asignaron valores a las variables y y a, dando así una correcta evaluación a lazy_var; es decir que hasta ese momento fue necesario evaluar lazy_var por lo cual no se genera algún problema. ¿Por qué sólo se imprimió una vez el \"Hi!\" y el valor de lazy_var? Por el valor calculado y guardado en la promise. Otra forma de llamar a una función es usando la función do.call(), la cual permite agregar una lista de parámetros. do.call(myStrangeFunction, args = list(a = 2, b = 3, c = 4, 6,7,8,9)) [1] 40 Los objetos que guardemos o asignemos en nuestros flujos de trabajo serán almacenados en un espacio de memoria que se llama ambiente o en inglés environment. Desde RStudio podremos ver lo que se guardado en este espacio de memoria en el panel Environment. Este tema es un poco extenso por lo que hay que entender sólo algunas cosas. Un ambiente en R es lo que se conoce como una cerradura (closure) en programación. Una cerradura es una técnica para almacenar la información necesaria y permitir la integridad de esta en una función. Un ambiente se encarga de asociar un conjunto de nombres a un conjunto de valores, por lo que los valores no estan directamente almacenados en el ambiente, si no sólo los enlaces identificados por los correspondientes nombres. En un ambiente todos los nombres son únicos y no están ordenados (recordar que los nombres están asociados a las variables o valores para un uso posterior, por ejemplo: var &lt;- c(1,2)). Para crear un ambiente se utiliza la función new.env(). La función ls() permite ver todos los elementos de un ambiente. Se utiliza la función assign() para agregar un nuevo elemento a un ambiente dado y para obtener alguno de los elementos se puede acceder con el operando $, como en una lista o con la función get() (si no se encuentra la variable con el nombre dado, get buscará en los ambientes padres). Para preguntar si existe alguna variale con un nombre dado en un ambiente se utiliza la función exists() y para eliminar una o varias referencias de variables en un ambiente se usa la función rm(). env_test &lt;- new.env() assign(&quot;new_variable&quot;, 1:5, envir = env_test) ls(env_test) [1] &quot;new_variable&quot; env_test$new_variable [1] 1 2 3 4 5 # get(&quot;new_variable&quot;, envir = env_test) exists(&quot;new_variable&quot;, envir = env_test) [1] TRUE rm(&quot;new_variable&quot;, envir = env_test) ls(env_test) character(0) Más ejemplos ## Muestra los nombres de los objetos en memoria ls() ## Muestra las variables con cierta serie de caracteres en su nombre ls(pat=&quot;m&quot;) ## Muestra las variables las cuales su nombre empieza con el caracter dado ls(pat=&quot;^m&quot;) ## Muestra detalles de los objetos en memoria ls.str() ## Eliminar todas las variables de &#39;Global Environment&#39; rm(list=ls()) ## Eliminar únicamente variables que empiezan con la letra m rm(list=ls(pat=&quot;^m&quot;)) ## Tipo de elementos del objeto v mode(v) ## Longitud del objeto v length(v) En un ambiente se pueden acceder a las variables que están enlazas en el mismo mediante su nombre, lo cual garantiza que, si dado una variable en otro ambiente con un mismo nombre a alguna variable en el ambiente actual, estas no sean confundidas y se obtengan resultados inesperados. Cada ambiente tiene un padre, lo cual permite que existan enlaces entre las librerías, permitiendo la inclusión de funciones en distintos paquetes. Para ver el ambiente padre se utiliza la función parent.env() dando como parámetro un ambiente. Véase la siguiente imagen Fuente: Advance R. El ambiente donde regularmente se trabaja es el R_Global_Environment también llamado workspace. Cada vez que se agrega una nueva librería, el environment para esta (package environment) es colocado entre el ambiente de la última librería cargada y el ambiente global. Para ver todos los ambientes activos de este tipo se puede usar la función search(). Cada vez que se crea una función, esta es enlazada con el ambiente global mediante un function environment. Cuando los ambientes son modificados, estos no son copiados; copiados en el sentido que se verá más adelante en la sección Iteración y Recursión. Cada función en un paquete esta asociado con un ambiente del paquete y un ambiente especial llamado namespace environment, el cual contiene todos los enlaces a las variables de la función, y un import environment que contiene todos los enlaces a las funciones que requiera la función del paquete actual. Cada vez que se ejecuta una función, se crea un execution environment donde su padre es el ambiente de la función. Recordando un poco de lo aprendido en programación orientada a objetos, existe la analogía de que las cerraduras son una manera de simular el encapsulamiento en las funciones, y ya que las funciones son de primera clase en R, son tratadas también como objetos. Para más información acerca de los temas anteriores consúltese Advance R. Second Edition y Advance R. First Edition. 3.5.2 Vectorización Desde las estructuras de datos es fácil ver la importancia que tienen los vectores en R y la facilidad de usar funciones y operaciones en ellos, logrando tener un buen rendimiento, evitando ciclos y ganando comprensión en los resultados esperados. La Vectorización significa aplicar funciones optimizadas, en este caso escritas en C, para llegar a una solución del problema a tratar. Esto da soluciones más simples tratando a los vectores como unidad en lugar de pensar en una solución donde se tiene que tratar cada entrada en el vector. En este último caso se tendría que hacer algún tipo de ciclo, en el caso de la vectorización los ciclos son hechos directamente en C, los cuales son más rápidos y con menor sobre carga. Ya se han tratado algunas funciones vectorizadas, como lo son sum(), prod() y sqrt(), las cuales todas sirven con un vector. ¿Qué sucede con sum(list(1,2,3,4,4,5)), sum(matrix(1,ncol = 3,nrow = 6)) y sum(data.frame(x = 1:20, y = 2:21))? Dado lo anterior, ¿Se puede obtener la suma por renglones o columnas en una matriz? ¿Se puede hacer lo mismo en un data frame o una lista? ¿Se puede aplicar una función particular que trabaje de manera vectorial por renglones o columnas en un data frame? La respuesta a todo esto es ¡Sí! y se puede realizar todo con la familia de funciones apply. La familia apply es un conjunto de funciones que ayudan en la aplicación vectorial de funciones sobre ciertas estructuras de datos. Para ver a detalle el funcionamiento de cada una de estas y otras funciones, puede consultarse el tutorial de DataCamp Tutorial on the R Apply Family y los enlaces que se dejan al final de esta sub-sección. Mientras tanto, véase los siguientes ejemplos y funciones. La función apply(X, MARGIN, FUN, ...) ejecuta una función en un arreglo o una matriz X. El atributo MARGIN es utilizado para determinar si la aplicación vectorial será por renglones o columnas (MARGIN = 1 aplicará FUN sobre renglones, MARGIN = 2 sobre columnas y MARGIN=c(1,2) para ambos) seq_matrix &lt;- matrix(1:12, nrow = 4, ncol = 3) sum_n_times &lt;- function(x, n) sum(x*n) apply(seq_matrix, MARGIN = 1, sum) [1] 15 18 21 24 apply(seq_matrix, MARGIN = 2, FUN = sum_n_times, 5) [1] 50 130 210 En el código anterior se utilizó la función sum_n_times, la cual puede solo usarse para este caso y en ninguna otra ocasión. Esto puede suceder cuando se requiera un resultado especial y único, por lo que declarar y reservar un espacio en memoria para una función y todo lo que implica podría ser un uso inadecuado del espacio disponible. Para estos casos se puede utilizar una función anónima, las cuales son conocidas como funciones lambda. seq_data_frame &lt;- data.frame(x = 1:12, y = 2:13) apply(seq_data_frame, MARGIN = 2, FUN = function(x) sum(x*5)) x y 390 450 Véase que se utilizo un data frame en la función apply anterior. Esto funciona pero no es la manera correcta de hacer vectorización con data frames. En otro momento se verá el porqué de esto. La función lapply acepta arreglos, data frames, vectores y listas y tiene la peculiaridad de regresar una lista. lapply(list(a = 1:20, b = 2:30), sum) $a [1] 210 $b [1] 464 lapply(list(a = list(1,2,3), b = list(4,5,6), c = list(7,8,9)), FUN = &quot;[&quot;, 2) $a $a[[1]] [1] 2 $b $b[[1]] [1] 5 $c $c[[1]] [1] 8 lapply(seq_matrix[c(1,2),c(1,2)], &quot;[&quot;, 1) [[1]] [1] 1 [[2]] [1] 2 [[3]] [1] 5 [[4]] [1] 6 lapply(list(a = seq_matrix, b = seq_matrix+1, c = seq_matrix+3), FUN = &quot;[&quot;, 1,2) $a [1] 5 $b [1] 6 $c [1] 8 Véase que se utilizo el operador '[' para extraer elementos de las listas y elementos de las matrices. ¿Qué significa el parámetro 1 en '[ cuando se utilizó para seq_matrix[c(1,2),c(1,2)]? Hint: Véase la descripción del argumento X en la documentación de lapply(). ¿Qué significa el parámetro 2 en '[ cuando se utilizó para el segundo ejemplo? ¿Qué se obtiene en el último ejemplo? Otra de las funciones más utilizadas es sapply(). Esta función devuelve una salida con la estructura más básica posible, por lo que es común obtener vectores con esta función. sapply() es una versión amigable de lapply() por el tipo de salida, aunque modificando el parámetro simplify a FALSE, sapply tiene el mismo comportamiento que lapply(). sapply(list(a = 1:20, b = 2:30), function(x) sqrt(sum(x))) a b 14.49138 21.54066 sapply(list(a = 1:20, b = 2:30), function(x) sqrt(sum(x)) , simplify = FALSE) $a [1] 14.49138 $b [1] 21.54066 Aún falta ver las funciones tapply(), mapply() y vapply(). ¿Qué hace replicate()? ¿Qué hace which()? Aquí se enlistan algunos enlaces útiles sobre este tema: Using apply, sapply, lapply in R. R Programming for Data Science R para principiantes 3.5.3 Paquetes Antes de ver un compendio de funciones útiles, hay que tener en cuenta que reutilizar código es muy importante para no perder tiempo en la resolución de problemas; y antes de instalar librerías o usar otras funciones base de R, hay que hablar sobre el CRAN. El CRAN (Comprehensive R Archive Network) es una red de servidores web y FTP (File Trasnfer Protocol) donde se almacenan versiones de código y documentación de R. Además proporciona los hipervínculos para muchos paquetes con diversos temas (se puede consultar todo esto en el CRAN Task Views). Como es difícil e ineficiente tener todo en un mismo lugar, se crearon copias (mirrors) al rededor del mundo donde se mantiene y da soporte a toda esta información. Se puede consultar en la siguiente enlace la lista de todos estos lugares. Para el caso de México, se tienen dos ubicaciones: Instituto Tecnologico Autonomo de Mexico Colegio de Postgraduados, Texcoco Para instalar paquetes se puede elegir alguna de las siguientes opciones: Instalación directa: install.packages(&quot;tidyverse&quot;) install.packages(&quot;file:///source&quot;, repos=NULL) Mediante RStudio: Tools &gt; Install.Packages … Regularmente, los paquetes usarán en su codificación funciones de otros paquetes, por lo que será necesario instalar todas los paquetes de los que depende para su correcto uso. Para evitar instalar uno por uno los paquetes de los que dependa alguno, se agrega el argumento dependences=TRUE a la función install.packages(): install.packages(...,dependeces = TRUE). Lo anterior sirve para aquellos paquetes que están en el CRAN, pero si no lo están o se desea instalar otra versión de los paquetes, se puede usar devtools, el cual permite instalar un paquete directamente desde su fuente, como es el caso de algunos localizados en github. install.packages(&quot;devtools&quot;) library(&quot;devtools&quot;) install_github(&quot;hadley/emo&quot;) Al instalar un paquete, este es guardado en el ordenador; ya que los paquetes no son más que archivos y carpetas que pueden contener funciones en Scripts, archivos .Rsd (Bases de datos de R) entre otros. Ejemplo para el paquete actuar La ubicación donde el paquete es guardado se le llama library y para identificar donde empieza la busqueda R al cargar un paquete se utiliza el comando .libPaths(). ¿Qué sucede al ejecutar lapply(.libPaths(), dir)? Para cargar un paquete se puede utilizar las funciones library() y require. Ambas funciones cargan lo contenido en los paquetes aunque existen pequeñas diferencias entre ambas. Al querer cargar un paquete que no esta instalado, library devolverá un error y require una advertencia, además require regresa un valor booleano dependiendo si se encuentra o no la librería para cargar dicho paquete; esto puede ser útil dentro de funciones para preparar el workspace y sus enlaces. Por ejemplo, en la siguiente función se instala el paquete dplyr en caso de no se tenga la librería o se carga el paquete en caso contrario. preparation &lt;- function(){ if(!require(&quot;dplyr&quot;)){ install.packages(&quot;dplyr&quot;) } } Al momento de querer usar una función de algún paquete se puede llamar como cualquier función, aunque puede darse el caso de que existan los mismos nombres entre dos o más librerías para una función o hasta el mismo nombre para una función que creó el usuario. En tal caso se puede especificar el paquete con el operador ::; por ejemplo stats::chisq.test(). ¿Para qué sirve la función attach() y detach? 3.5.4 Miscellaneous A continuación se dará una serie de funciones y paquetes con los que se puede trabajar en ciertas ocasiones. Aquí no se mencionarán funciones que “vivan” en el “tidyverse” o funciones dedicadas a elementos gráficos, así como funciones relacionadas a temas avanzados de estadística y probabilidad. 3.5.4.1 Vectores base::cumsum(): Dado un vector, la función cumsum devuelve la suma acumulada de dicho vector. También se tiene base::cummin(), base::cummax() y base::cumprod(). base::unique(): Esta función elimina los elementos duplicados en un vector, data frame o un arreglo. base::sort(): La función sort regresa de manera ordenada su input, el cual debe ser un vector o factor. base::gl(): Genera series regulares de factores dados. Ejemplos: gl(3, 5, length = 30), gl(2, 6, label = c(\"Hombre\",\"Mujer\")). base::union(), base::intersect(), base::setdiff() y base::setequal(): Funciones para realizar operaciones de conjuntos en vectores. package:vctrs: Este paquete ofrece varias funciones útiles en el manejo de vectores, además de que algunas de sus funciones se pueden usar en otro tipo de estructuras de datos. 3.5.4.2 Matrices y Data frames base::rowSums()y base::rowMeans(): Con estas funciones se obtienen la suma o el promedio por renglón en una matriz. Existe el equivalente para las columnas y son más rápidas estas funciones que al aplicar apply. ¿Qué hace base::rowsum()? utils::head() y utils::tail(): Funciones para obtener las primeras o últimas observaciones de un data frame; también funciona con matrices. base::split(): Dicha función separa en grupos de acuerdo a una variable. package:data.table: El paquete data.table contiene varias funciones para manipular data.tables, los cuales pueden obtenerse fácilmente con un data frame. Las funciones en este paquete son eficientes en memoria y muy rápidas. La función base::expand.grid() genera un data frame con todas las posible combinaciones de vectores o factores dados como argumentos. Aquí un ejemplo: expand.grid(h = c(60, 80), w = c(100, 300), sex = c(\"Hombre\", \"Mujer\")). 3.5.4.3 Lectura y escritura En cuanto a archivos externos, en general se utilizan archivos con extensión .csv y .txt; sin embargo R no está limitado a este tipo de archivos. Existen una amplia variedad de formatos que se pueden leer a través de paquetes diseñados específicamente para ese fin. El siguiente ejemplo muestra cómo se haría la lectura de un archivo con extensión .txt: datos&lt;-read.table(&quot;data.txt&quot;, # nombre del archivo (con extensión) entre comillas header = TRUE, # TRUE o FALSE, indicando si el archivo tiene como primer renglón el nombre de las columnas sep=&quot;\\t&quot; # separador de los campos ) Una vez que leemos el archivo externo en R, el objeto donde se almacenará la información será de tipo data.frame. Muchas veces será de nuestro interés exportar objetos data.frame a archivos externos, tal objetivo lo podemos lograr con alguna de las siguientes dos opciones: write.table(datos, &quot;toma.txt&quot;, append=F, sep=&quot;\\t&quot;) write.csv(datos, &quot;toma2.csv&quot;) N:B. Como en la lectura de datos, R no está limitado a exportar archivos .csv o .txt también existe una amplia variedad de formatos que podemos generar. En la siguiente lista se aclaran algunas funciones utilizadas y se añaden otras que pueden ser de interés. base::read.csv(), base::read.delim(), base::read.table() y base::readLines(): Diferentes funciones para leer archivos de texto en distintos formatos. base::write(), base::csv() y base::table(): Funciones para exportar datos, como un data frame o una matriz, en un formato especifico. base::saveRDS(): Función para exportar o guardar algún objeto de R. Se puede leer este objeto con la función base::readRDS(). Estas funciones no están optimizadas y existen algunas variantes para estas funciones como readr::save_rds y qs::qsave(). Aún así, este tipo de almacenamiento de datos (en forma de bytes) es de lo más confiable ya que es serializable. Se recomienda leer el post A better way of saving and loading objects in R. 3.5.4.4 Funciones estadísticas y matemáticas base::sample(): Función para obtener una muestra aleatoria de \\(n\\) números y permutaciones de un conjunto dado. set.seed(): Función para asignar la semilla para los métodos pseudo aleatorios posteriores. base::sd(): desviación estándar. base::var(): varianza. base::min(): mínimo. base::max(): máximo. base::median(): mediana. base::range(): rango. base::quantile(): cuantiles. set.seed(20) data &lt;- data.frame(v = sample(c(1:25, NA), size = 50, replace = T), w = sample(c(1:25, NA), size = 50, replace = T), x = sample(c(1:25, NA), size = 50, replace = T), y = sample(c(1:25, NA), size = 50, replace = T), z = sample(c(1:25, NA), size = 50, replace = T)) head(data) v w x y z 1 6 1 17 NA 13 2 11 15 8 11 22 3 24 6 3 15 21 4 2 2 11 8 20 5 25 6 7 3 19 6 2 10 18 25 24 data.frame(Sd = sapply(data, sd, na.rm = T), Varianza = sapply(data, var, na.rm=TRUE), Min = sapply(data, min, na.rm=TRUE), Max = sapply(data, max, na.rm=TRUE), Mediana = sapply(data, median, na.rm=TRUE), MissingValues = sapply(data, function(x) sum(is.na(x)))) Sd Varianza Min Max Mediana MissingValues v 7.359459 54.16163 2 25 14.0 0 w 7.845289 61.54857 1 25 8.0 3 x 7.646861 58.47449 1 25 10.0 1 y 7.126090 50.78116 1 25 11.0 4 z 7.176597 51.50355 1 25 14.5 2 Lo anterior es un pequeño resumen cuantitativo de los datos generados, pero se pueden obtener con diferentes funciones como base::sumary(), base::fivenum() y Hmisc::describe(). Con los paquetes naniar y visdata se puede dar tratamiento a los valores perdidos, así como elementos gráficos de resumen sobre estos. base::abs(): Valor absoluto. base::sqrt(): Raíz cuadrada. base::exp(): Función exponencial. base::log(): Logaritmo Natural. base::log2(), base::log10(), base::log(base): Logaritmo en diferente base. base::sin(), base::cos(), base::tan(), base::asin(),..: Funciones trigonométricas. base::integrate(): Función para encontrar el área debajo de una curva base::uniroot(): Función para encontrar las raíces de una función. base::optimse(): Función para encontrar el mínimo o máximo de una función. base::lfactorial(): Esta función calcular el logaritmo natural del factorial de un número. base::cut(): Dicha función establece intervalos en todo el rango de valores dados por un vector. ¿El resultado es un factor? base::findInterval(): Misma finalidad de la función cut pero es más rápido que dicha función. 3.5.4.5 Others base::object.size(): Esta función regresa una aproximación de la memoria utilizada por un objeto. base::capture.output(): Dicha función captura la salida de una función en un caracter. base::readlines(): Lectura de una línea que el usuario ingresa desde la terminal. base::invisible() y base::withVisible(): En ciertas ocasiones se desea que el resultado de las funciones no sea impreso, en tal case se utiliza la función invisible y para poder visualizarlo la función withVisible(). try(), suppressWarnnings() y suppressMessages(): Con dichas funciones se puede aplicar el manejo de excepciones. Véase la documentación sobre las funciones base::on.exit() y base::stop(). base::traceback(): Al momento de tener un error en alguna función, la función traceback puede ser utilizada para ver los errores en la pila de ejecución. package:lobstr: Este paquete ofrece varias funciones para el manejo de objetos; como la obtención de un identificador de la dirección de memoria que tiene un objeto, su tamaño en bits, obtener en mejor orden el resultado de ciertas funciones; por ejemplo con lobstr::cst() se obtiene el árbol de la pila de llamadas obtenido por base::traceback() , el tamaño de memoria utilizada en la sesión actual, etc. package:rlang: Las funciones de este paquete están diseñadas para trabajar con ambientes. package:profvis y package:bench: Cuando se desea optimizar el funcionamiento del código, es común utilizar funciones para evaluar la rápidez de las funciones o rutinas con las que se trabaja; estos paquetes ayudan a realizar un perfilamiento del código y a realizar microbenchmark en funciones pequeñas. Véase el siguiente enlace para más funciones. var function (x, y = NULL, na.rm = FALSE, use) { if (missing(use)) use &lt;- if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot; na.method &lt;- pmatch(use, c(&quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;pairwise.complete.obs&quot;, &quot;everything&quot;, &quot;na.or.complete&quot;)) if (is.na(na.method)) stop(&quot;invalid &#39;use&#39; argument&quot;) if (is.data.frame(x)) x &lt;- as.matrix(x) else stopifnot(is.atomic(x)) if (is.data.frame(y)) y &lt;- as.matrix(y) else stopifnot(is.atomic(y)) .Call(C_cov, x, y, na.method, FALSE) } &lt;bytecode: 0x7ffd33de0f58&gt; &lt;environment: namespace:stats&gt; La función anterior calcula la varianza de una variable, en este caso un vector. Véase que al final de la descripción se menciona la palabra bytecode, la cual resulta familiar cuando ya se trabajo en el lenguaje de programación Java. A partir de la versión 2.14 de R, todas las funciones estándar y paquetes fueron pre compilados en bytecode, lo cual otorga rapidez. Si el usuario desea compilar alguna función en bytecode lo puede hacer con la función compiler::cmpfun(). Si existe la inclusión del compilador bytecode en R ¿Existirá algún método para realizar JIT? Sí. Ejercicios Comparar la función del ejercicio 20 con la función sum() con bench::mark(). Obtener la unión, intersección y diferencia del siguiente conjunto de letras. set.seed(20) MixLetters &lt;- sample(c(LETTERS, letters),size = 30) Buscar algún data frame del paquete datasets. Guardar en una variable los primeros 10 registros y en otra los últimos 10. Verifica el siguiente resultado usando la función integrate(). \\[ \\int_0^1sin(\\pi x)dx = \\frac{2}{\\pi} \\] Verifica con la función integrate() que la famosa función de densidad de una normal integra \\(1\\) en todo su rango. A continuación se deja dicha función y si se desea basta con usar los parámetros de una normal estándar (\\(\\sigma = 1\\) y \\(\\mu = 0\\)). \\[ f(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} \\] Utilizar la función bench::mark() para comparar la rapidez entre las funciones rowSums() y apply(sum) en una matriz numérica. Obtener la suma y producto acumulado de los primeros 100 números naturales. Dentro del repositorio de este proyecto se encuentra el archivo Data_fake.csv. Este debe cargarse en la sesión actual de R y guardarse como un data frame con el nombre de Data_fake. Del data frame Data_fake obtener por columna el mínimo, máximo y mediana con alguna función de la familia apply en aquellas columnas que sea posible. Usar alguna de las funciones resumen en Data_fake. Crear una función que acepte un data frame como input y devuelva una lista con dos elementos; el primero será un data frame con solo aquellas variables que sean de tipo categóricas sobre el input y la segunda entrada de la lista de retorno un data frame con las variables numéricas. Utilizando la función anterior sobre Data_fake, obtener el data frame con solo variables numéricas y aplicar la función del inciso 45. Análogo a lo anterior, obtener el data frame con solo variables numéricas de Data_fake y dividir cada variable en 5 intervalos. Utilizar alguna función de la familia apply para aplicar la función table() sobre cada una de las variables del data frame Data_fake. Con los resultados anteriores, obtener aquellos elementos que son más recurrentes. "],
["iteración-y-recursión.html", "3.6 Iteración y Recursión", " 3.6 Iteración y Recursión ¿Los ciclos son lentos en R? Sí y no. Todo depende de como se utilice. Para comprender lo anterior, primero hay que entender como R almacena sus objetos. Para tener un entendimiento completo sobre todas las estructuras, es recomendable leer el capitulo 2 de Advance R; por el momento sólo se dará una introducción sobre como se comportan los vectores y las listas. Como ya se habia mencionado, cuando se hace algún objeto en R, como un vector o una lista, a estos se les asigna un nombre para poder identificarlos posteriormente. Véase los siguientes resultados. x &lt;- 1:5 tracemem(x) [1] &quot;&lt;0x7ffd309ba070&gt;&quot; El resultado anterior es un identificador de la dirección en formato hexadecimal del vector x en memoria. y &lt;- x tracemem(y) [1] &quot;&lt;0x7ffd309ba070&gt;&quot; Ahora el nombre “y” esta asociado con la variable x, aunque en realidad los nombres “y” y “x” apuntan hacia un mismo objeto y eso puede verse con los anteriores resultados. ¿Qué sucederá cuando se modifique algún valor en la variable y? ¿Se modificará en esa posición x? trace_vec &lt;- capture.output(y[[3]] &lt;- 10) cat(paste(c(strsplit(trace_vec[1],&quot;:&quot;)[[1]][1], strsplit(trace_vec[2],&quot;:&quot;)[[1]][1]), collapse = &quot;\\n&quot;)) tracemem[0x7ffd309ba070 -&gt; 0x7ffd31aa0798] tracemem[0x7ffd31aa0798 -&gt; 0x7ffd3191fdf8] cat(paste(c(x[[3]], y[[3]]), collapse = &quot;\\n&quot;)) 3 10 Los valores del vector x no se modificaron, solo los de y y las anteriores salidas al modificar el tercer elemento en el vector y son por lo que en R se conoce como Copy-on-modify donde básicamente los vectores no son copiados hasta que estos sean modificados. La primera salida es debido a que se realizo una copia de todos los elementos de x y posteriormente se modifico en y el tercer elemento. Véase que x no fue alterado en la ubicación o el identificador en memoria de este. tracemem(x) [1] &quot;&lt;0x7ffd309ba070&gt;&quot; tracemem(y) [1] &quot;&lt;0x7ffd3191fdf8&gt;&quot; ¿Si se hubiera modificado algún elemento de x en lugar de y, qué hubiera sucedido? Ahora, véase el caso con las listas list_mem &lt;- list(uno = 1:5, dos = 1:7) list_mem_copy &lt;- list_mem tracemem(list_mem) [1] &quot;&lt;0x7ffd2e038348&gt;&quot; tracemem(list_mem_copy) [1] &quot;&lt;0x7ffd2e038348&gt;&quot; Las listas creadas anteriormente tienen la misma dirección y no sólo eso, si no que cada uno de los elementos de la lista también son los mismos cat(paste(c(tracemem(list_mem[[1]]), tracemem(list_mem_copy[[1]]), tracemem(list_mem[[2]]), tracemem(list_mem_copy[[2]])), collapse = &quot;\\n&quot;)) &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e7b5ab0&gt; &lt;0x7ffd2e7b5ab0&gt; ¿Qué sucedera cuando se modifique algún elemento en list_mem? ¿Sucederá lo mismo que en los vectores? trace_list &lt;- capture.output(list_mem[[2]] &lt;- 2:8) cat(strsplit(trace_list[1],&quot;:&quot;)[[1]][1]) tracemem[0x7ffd2e038348 -&gt; 0x7ffd2f1f1bc8] Solo se hizo un cambio en dirección de memoria, ya que en el caso de las listas no se copia todos los elementos, solo se cambia el puntero hacia otro objeto. Véase que en los elementos que no se realizo algúna modificación se sigue apuntando hacia el mismo objeto. cat(paste(c(tracemem(list_mem[[1]]), tracemem(list_mem_copy[[1]]), tracemem(list_mem[[2]]), tracemem(list_mem_copy[[2]])), collapse = &quot;\\n&quot;)) &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e5237c0&gt; &lt;0x7ffd2e7b5ab0&gt; ¿Las direcciones de las listas list_mem y list_mem_copy ahora son diferentes? En resumen, al modificar algún elemento dentro de un vector, se creó una copia de todos los valores teniendo así dos vectores con diferentes nombres y, cuando se modifica algún elemento en las listas, solo se cambia de dirección el punto correspondiente a ese objeto y los demás enlaces permanecen. Cuando se hace algún ciclo donde se este agregando o modificando algún vector, internamente se realizarán copias de todo el vector aunque sólo un elemento sea alterado; en ese caso los ciclos iterativos son lentos, pero cuando se utiliza una lista en lugar de un vector el rendimiento mejora bastante. Hay que recordar que R no fue diseñado para ser rápido, aunque usando listas el rendimiento obtenido será mejor al usar un ciclo. library(bench) library(knitr) data &lt;- data.frame(matrix(1:100000, ncol = 100)) plus2_byVector &lt;- function(x){ #Al usar m[[n]] cuando m es un data.frame, véase que se estan tomando vectores for(item in 1:length(x)){ x[[item]] &lt;- x[[item]]+2 } x } kable(bench::mark(plus2_byVector(data))[c(&quot;min&quot;, &quot;median&quot;, &quot;mem_alloc&quot;, &quot;total_time&quot;)], format = &quot;markdown&quot;) min median mem_alloc total_time 1.37ms 1.64ms 1.3MB 353ms plus2_byList &lt;- function(x){ #Al convertir un data.frame en una lista, se agrega un elemento por columna x &lt;- as.list(x) for(item in 1:length(x)){ x[[item]] &lt;- x[[item]]+2 } x } kable(bench::mark(plus2_byList(data))[c(&quot;min&quot;, &quot;median&quot;, &quot;mem_alloc&quot;, &quot;total_time&quot;)], format = &quot;markdown&quot;) min median mem_alloc total_time 149µs 185µs 813KB 291ms Otro punto que hay que considerar es que no siempre existirá una manera sencilla de usar algún funcional para remplazar a un ciclo, ya sea al modificar en algún lugar un objeto o al usar recursión, ya que en este último caso se depende de índices o de elementos anteriores que con un funcional no sería sencillo de resolver. En general, hay ocasiones en las que un ciclo debe permanecer explícitamente para dar solución a un problema, tal es el caso de un modificación en una estructura en cada iteración; esto se puede remplazar con algún funcional aunque el código puede perder legibilidad. Otra circunstancia donde los ciclos no deben ser remplazados por un funcional son las relaciones recursivas ya que estas dependen de las posiciones dentro de una estructura, lo cual si puede ser difícil de plasmar en un funcional. Finalmente, cuando se tenga una solución implementada con un ciclo while, será complicado remplazar este por funciones como de la familia apply. En el ámbito de la recursión, se pueden tener varios problemas y uno de los principales son la manera en que estos son tratados dentro de los lenguajes no funcionales, ya que el almacenamiento en este tipo de instrucciones puede ser demasiado. La manera en que trabajan las funciones recursivas es llamando internamente a las mismas funciones hasta llegar a un caso base, y mientras se opere con los resultados de las funciones internas, estos deben ser almacenados en la memoria y la forma en que estos son almacenados es en una pila conocida como Call Stack. Dependiendo del lenguaje de programación la administración de la pila de llamadas puede cambiar, aunque esta siempre tendrá un límite de almacenamiento. En el caso de la recursión puede ser sencillo llenar esta y obtener una excepción indicando esta situación. Para tales casos, se puede remplazar la implementación de las funciones con diferentes técnicas; una de ellas se llama Memoization en la cual se guarda, en un ambiente fuera de la pila de llamadas, los resultados que se han obtenido de las funciones recursivas. Por ejemplo, si se esta tratando el problema de tener los primeros \\(n\\) números de fibonacci y previamente se corrió fibonacci(m) donde \\(m&lt;n\\), al momento de hacer fibonacci(n) está buscará si existen registros de llamadas previas y comenzará desde ese punto, por lo que fibonacci(n) no tendrá que calcular los \\(n-1\\) nuevamente, si no, solo los faltantes; por lo que, si se tiene el suficiente espacio, el problema del límite de memoria en la Call Stack quedará resuelto. En los siguientes enlaces se dejan algunos ejemplos de esto. Optimize your R Code using Memoization StackOverFlow:Factorial Memoization in R Otra forma de solucionar el problema de la recursión, es llevar un proceso recursivo a uno iterativo, esto puede ser complicado algunas veces y más aún cuando ya se tenga el proceso de manera recursiva implementado, por lo que una solución es tomar dicha implementación y tratarla de manera iterativa dentro de una función, a dicha técnica se le conoce como trampoline. Este término esta relacionado con el lenguaje Lisp, pero se utiliza para identificar dicha técnica. En el siguiente enlace se deja un ejemplo de esto en R. Tail Recursion in R with Trampolines Finalmente, hay que tener en cuenta que el almacenamiento de llamadas de una función se hace en la Call Stack por que se opera con dichos resultados, por ejemplo en fibonacci(n) se debe realizar fibonacci(n-1)+fibonacci(n-2). Si de alguna manera se implementa un método recursivo sin operar con los resultados previos se podría evitar dicho problema, a esto se le conoce como Tail Call Optimization. "],
["graficación.html", "3.7 Graficación", " 3.7 Graficación La comunicación visual siempre será un recurso muy importante para presentar y aclarar la información con la que se esta trabajando así como los resultados obtenidos. R cuenta con una gran cantidad de funciones para crear elementos gráficos, principalmente en el ámbito estadístico, a partir de ciertas estructuras u objetos, las cuales se pueden personalizar y dar un mejor formato a gusto del programador. En esta sección sólo se verán algunas funciones y estrategias para crear objetos gráficos usando las funciones que proporciona R por defecto, así como funciones de ciertos paquetes a excepción de paquetes y funciones relacionados con ggplot. Una de las funciones más importantes es la función plot(), la cual es una función genérica por lo que dependiendo del tipo de objeto u objetos que se den como parámetros se comporta de manera distinta, esta función devolverá un gráfico relacionando dos variables (\\(x\\) y \\(y\\)) en un plano cartesiano. Tómese como ejemplo los datos pressure del paquete datasets. ¿Qué dice la documentación acerca de estos datos? head(pressure) temperature pressure 1 0 0.0002 2 20 0.0012 3 40 0.0060 4 60 0.0300 5 80 0.0900 6 100 0.2700 plot(pressure) El anterior gráfico también pudo obtenerse especificando lo que se considerará como variable \\(x\\) y \\(y\\) o dando una formula: plot(pressure$temperature, pressure$pressure) plot(pressure ~ temperature, data=pressure) La anterior gráfica contiene muchos elementos gráficos, como títulos para los ejes y hasta los propios ejes, además las observaciones en los datos son dibujados como circunferencias. Véase en la siguiente gráfica que se puede modificar todo esto y agregar unos cuantos elementos gráficos más .scroll-300 { max-height: 300px; } plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presión&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes col.axis = &quot;#284c73&quot;, # Color para las anotaciones en los ejes fg = &quot;#9fb3c9&quot;, # Color para otros elementos gráficos como los ejes type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título cex.lab = 1.1, # Tamaño para los títulos en los ejes cex.axis = .8 # Tamaño para los ejes #cex haría proporcional el tamaño en todo. ) También pueden eliminarse los ejes y el marco plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título axes = FALSE, #Eliminando ejes xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presión&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título cex.lab = 1.1 # Tamaño para los títulos en los ejes ) Para solo eliminar el marco se puede usar frame=FALSE y para eliminar alguno de los ejes con xaxt=\"n\" o yaxt=\"n\". Aún se puede dar una mejor presentación modificando el tipo de fuente plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presión&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes col.axis = &quot;#284c73&quot;, # Color para las anotaciones en los ejes fg = &quot;#9fb3c9&quot;, # Color para otros elementos gráficos como los ejes type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título cex.lab = 1.1, # Tamaño para los títulos en los ejes cex.axis = .8, # Tamaño para los ejes font.axis = 1, # Formato para los ejes font.lab = 3, # Formato para los títulos en los ejes font.main = 4, # Formato para el título font.sub = 3, # Formato para el sub título family = &quot;Fira Sans Condensed&quot; ) Muchos de los argumentos anteriores no son específicamente de la función plot(), ya que dicha función solo solicita la información para los ejes \\(x\\) y \\(y\\) y lo demás es opcional mediante el argumento ... en el cual se pueden agregar opciones de texto y parámetros gráficos. De los anteriores las opciones de texto son los parámetros main, sub, xlab y ylab. El tipo de gráfico no es exclusivamente un graphical parameter para todas las gráficas, si no que es para la función plot() en general. Los demás argumentos son graphical parameters los cuales pueden ser usados en otros tipos de gráficos. La gráfica se ve bien aunque se puede mejorar el aspecto de los ejes con la función axis(). Para usar la función axis primero se deben eliminar los ejes. plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presión&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título cex.lab = 1.1, # Tamaño para los títulos en los ejes font.lab = 3, # Formato para los títulos en los ejes font.main = 4, # Formato para el título font.sub = 3, # Formato para el sub título family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) Para aclarar, el argumento side hace referencia al eje que se esta modificando, 1-below, 2-left, 3-above y 4-right. La función axis tiene más argumentos como lyt para indicar el tipo de línea sobre el eje y col para el color del eje. ¿Qué pasa cuando en tck se da un valor negativo? Ahora, si se desea agregar texto en la gráfica se puede usar la función text() plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presión&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título cex.lab = 1.1, # Tamaño para los títulos en los ejes font.lab = 3, # Formato para los títulos en los ejes font.main = 4, # Formato para el título font.sub = 3, # Formato para el sub título family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,810, #Posición para el texto &quot;Presión máxima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot; ) La función tex() tiene otro argumento, pos, que modifican la posición del texto de acuerdo a las coordenadas dadas. Con la función mtext() se puede modificar el título de los ejes o mejor dicho en cada margen de la gráfica con la ventaja de manipular el margen entre los ejes y los correspondientes títulos. plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título font.main = 4, # Formato para el título font.sub = 3, # Formato para el sub título family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,810, #Posición para el texto &quot;Presión máxima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot; ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presión&quot;, line=2.4, #Agregar margen family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Ahora, se desearía que la etiqueta de “Presión máxima” apuntará hacia el valor máximo con una flecha, además de agregar lineas para ubicar mejor las proyecciones en los ejes de dicho valor. Esto se puede lograr con las funciones arrow() y abline() plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título font.main = 4, # Formato para el título font.sub = 3, # Formato para el sub título family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,810, #Posición para el texto &quot;Presión máxima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posición dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presión&quot;, line=2.4, #Agregar margen family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) arrows(270,810, #Posición de inicio max(pressure$temperature)-5, max(pressure$pressure), #Posición de término col = &quot;grey50&quot;, lwd = 1.2 #Ancho de la línea ) abline(h = max(pressure$pressure), #h es especial para líneas horizontales col = &quot;gray73&quot;, lty = 3) abline(v = max(pressure$temperature),#v es especial para líneas horizontales col = &quot;gray73&quot;, lty = 3) A la función abline() también se le puede dar la información en la forma \\(ax+b\\) donde el argumento a sirve para establecer la pendiente y b para el intercepto. Véase que las rectas dibujadas con la función abline() cubren todo el rango de ambos ejes y en este caso se desea que estas terminen cuando lleguen a la coordenada específica, para eso se utilizará la función segments() donde sus argumentos indican las coordenadas de inicio y de final. Además el diseño de la flecha puede mejorar con shape::Arrows. library(shape) plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal col.main = &quot;#0e608f&quot;, # Color para el título sub=&quot;Ejemplo 1&quot;, # Sub título col.sub= &quot;grey50&quot;, # Color para el sub título xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título font.main = 4, # Formato para el título font.sub = 3, # Formato para el sub título family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,648, #Posición para el texto &quot;Presión máxima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posición dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presión&quot;, line=2.4, #Agregar margen family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posición de inicio max(pressure$temperature), max(pressure$pressure), #Posición de término arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) Todos los parámetros gráficos se podrían haber incluido directamente con la función par(). En el siguiente ejemplo se ve como dicha función ahorra código. Hay que tener en cuenta que aveces es bueno hacer una copia donde no se tengan los parámetros gráficos alterados, esto guardando el estado actual de estos: par_default &lt;- par()y después llamando par(par_default). par(col.main = &quot;#0e608f&quot;, col.sub= &quot;grey50&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8 ) plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal sub=&quot;Ejemplo 1&quot;, # Sub título xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posición para el texto &quot;Presión máxima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posición dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presión&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posición de inicio max(pressure$temperature), max(pressure$pressure), #Posición de término arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) Se puede utilizar la función par() para algunas características especiales como cambiar el color de fondo (background) de la gráfica con bg par(bg=&quot;#daeff5&quot;, col.main = &quot;#0e608f&quot;, col.sub= &quot;grey50&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8 ) plot(pressure ~ temperature, data=pressure, main = &quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, # Título principal sub=&quot;Ejemplo 1&quot;, # Sub título xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.main = 1.3, # Tamaño para el título cex.sub = .8, # Tamaño para el sub título axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posición para el texto &quot;Presión máxima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posición dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presión&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posición de inicio max(pressure$temperature), max(pressure$pressure), #Posición de término arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) Si se desea solo colorear el fondo del plano coordenado, véase el ejemplo que se da en el siguiente link. También se pueden crear matrices de gráficas, esto gracias al parámetro mfrow par(mfrow=c(1,2), oma = c(0, 0, 2, 0)) par(bg=&quot;#daeff5&quot;, col.sub= &quot;grey50&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8 ) plot(pressure ~ temperature, data=pressure, sub=&quot;Ejemplo 1&quot;, # Sub título xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.sub = .8, # Tamaño para el sub título axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posición para el texto &quot;Presión máxima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posición dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presión&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posición de inicio max(pressure$temperature), max(pressure$pressure), #Posición de término arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) plot(pressure ~ temperature, data=pressure, sub=&quot;Ejemplo 1&quot;, # Sub título xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gráfico pch= 24, # símbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores símbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de líneas lwd = 2, # Ancho de las líneas cex.sub = .8, # Tamaño para el sub título axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicará diseño at = c(-15,seq(0, 360, 45), 380), #Se indica donde se darán las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicará diseño at = c(-40, seq(0,810, 162), 840), #Se indica donde se darán las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan explícitamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posición para el texto &quot;Presión máxima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posición dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presión&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posición de inicio max(pressure$temperature), max(pressure$pressure), #Posición de término arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) mtext(&quot;Gráfico de dispersión y Lineas: Presión VS Temperatura&quot;, outer = TRUE, cex= 1.3,col = &quot;#0e608f&quot;,font = 4 ) El parámetro oma es para modificar el margen exterior de la gráfica. Puede verse más de esto y del argumento mar en los siguientes enlaces: Graph-gallery YaRrr Finalmente, un conjunto de funciones comunes para crear una matriz de dispersión par(bg = &quot;#e3e9ff&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8) pairs(iris, col = c(&quot;#865fd4&quot;, &quot;#b34769&quot;, &quot;#a19f4c&quot;)[ifelse(iris$Species==&quot;setosa&quot;, yes = 1, no = ifelse(iris$Species==&quot;versicolor&quot;, yes = 2, no = 3))]) Histograma, Gráfico de densidad, Pie Chart y Boxplot library(wesanderson) set.seed(20) datos_fic &lt;- c(sample(seq(1,2,by = 0.01), replace = T, size = 1000)) datos_fic_1 &lt;- sample(1:5, replace = T, size = 100) par(mfrow=c(2,2), bg = &quot;#e3e9ff&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8) hist(datos_fic, freq=TRUE, col = &quot;#2241b5&quot;, ylab = &quot;Frecuencia&quot;, main = &quot;Histograma de datos_fic&quot;) plot(density(datos_fic), col=&quot;#2241b5&quot;, main = &quot;Densidad de datos_fic&quot;, xlab = &quot;datos_fic&quot;, ylab = &quot;Densidad&quot;) pie(table(datos_fic_1), col=wes_palette(&quot;Rushmore1&quot;), clockwise=TRUE, main = &quot;Gráfico de pastel&quot;) boxplot(iris$Sepal.Length~iris$Species, col = c(&quot;#865fd4&quot;, &quot;#b34769&quot;, &quot;#a19f4c&quot;), xlab = &quot;Especies&quot;, ylab = &quot;Longitud del Sépalo&quot;, main = &quot;Boxplots por especie&quot;) 3.7.0.1 Comentarios finales Aún falta mucho por ver. Existen paquetes especiales para obtener colores. Se pueden agregar colores de tipo gradiente. Se pueden crear mapas. Existen muchas más gráficas estadísticas. Se pueden crear gráficas en 3D. Se pueden crear gráficas interactivas. Se pueden crear animaciones. investíguese el paquete manipulate para poder manipular las gráficas base de R de manera más interactiva. Además de saber crear gráficas, hay que tener conocimiento sobre cuando y cuales usar. Aquí se dejan algunos enlaces que pueden ser de interés: 15 questions about r plots. RGraphics-Paul Murell. Rgraphics-Chapter1. Advance graphics with R. Ejercicios Es algo tedioso estar copiando y pegando el mismo contenido para hacer una gráfica. Investiga una forma para guardar una gráfica como las vistas en esta sección como un objeto para usarlo posteriormente. Investiga como agregar una leyenda en la siguiente gráfica x&lt;-1:40; square = x^2; fourth = x^4 plot(x, square, type=&quot;b&quot;, col=&quot;#cc5252&quot;, xlab=&quot;x&quot;, ylab=&quot;y&quot;, pch=19) lines(x, fourth, pch=19, col=&quot;#e0773f&quot;, type=&quot;b&quot;) Investiga la función expression() para agregar en la anterior gráfica las respectivas ecuaciones (\\(y = x^2\\), \\(y = x^4\\)). Crear una gráfica donde se tenga el histograma y la gráfica de densidad para el siguiente vector numérico: rnorm(1000, 5, 0.4). En la gráfica anterior, agrega con la función curve() la ecuación del ejercicio 50 con \\(\\mu = 5\\) y \\(\\sigma = 0.4\\) Se puede agregar texto en una gráfica con el estilo de Latex, es decir, en \\(esta \\ forma \\ junto \\ con \\ ecuaciones \\ como \\sum_{x = 20}^{40}x^2\\cdot\\log(x)\\). Lee el siguiente post y crea una gráfica agregando alguna ecuación en ella. Escribe el código necesario para crear la siguiente gráfica Escribe el código necesario para crear la siguiente gráfica. Hint: Utiliza alguna de las funciones que se explican en Low-level plotting functions: YaRrr! The Pirate’s Guide to R Utiliza la función curve para gráficar la función \\(sin(x)\\), \\(cos(x)\\) y \\(tan(x)\\) en una sola gráfica. El rango debe abarcar tanto números negativos como positivos. Con las funciones rect(), polygon() y symbol(), crea la siguiente gráfica. Crea una gráfica con las siguientes ecuaciones parámetricas con \\(t\\in[0,2\\pi]\\) \\[ \\begin{split} x &amp;= 16 cos^3(t)\\\\ y &amp;= 13 cos(t)-5cos(2t)-2cos(3t)-cos(4t) \\end{split} \\] Grafica 1000 puntos con dos vectores de números pseudo aleatorios entre 0 y 1 y utiliza la función rainbow para otorgarles color. Crea una representación geométricas de la integral \\(\\int_0^\\pi sen(x)dx\\) Crea una gráfica del las funciones \\(sen(x)\\) y \\(cos(x)\\) agregando anotaciones cada \\(\\frac{\\pi}{2}\\) e indicando que ecuación corresponde a cada gráfica. Crea una gráfica para comparar las funciones \\(sen(x)\\), \\(2sen(x)\\) y \\(sen(\\frac{x}{2})\\). Crea una representación geométrica de la función \\(sen(x)\\) y \\(cos(x)\\) en una circunferencia. Referencias y bibliografía adicional Wickham and Grolemund. 2017. R for Data Science. https://r4ds.had.co.nz Versión en español: https://es.r4ds.hadley.nz Grolemund, Garrett.2014. Hands-On Programming with R. https://rstudio-education.github.io/hopr/ Mendoza, Vega. R para principiantes. https://bookdown.org/jboscomendoza/r-principiantes4/ Wickham and Grolemund. 2019. Advanced R. Second Edition. https://adv-r.hadley.nz Chang, W. (2012). R graphics cookbook: practical recipes for visualizing data. \" O’Reilly Media, Inc.\". Rahlf, T. (2019). Data Visualisation with R: 111 Examples. Springer Nature. Murrell, P. (2018). R graphics. CRC Press. "],
["tidyverse.html", "Capítulo 4 Tidyverse", " Capítulo 4 Tidyverse La mayoría del contenido visto en Introducción a R se ha enfocado al uso del lenguaje R y al uso de ciertas funciones sin considerar su rendimiento. Como bien se menciono en su momento, R no esta diseñado para ser rápido; lo que a través de los años ha sido un tema de interés a medida que la información aumenta y las necesidades por analizar y ejecutar procesos que traten con grandes cantidades de datos. Por tales razones, el uso de paquetes que estén diseñados para trabajar de manera eficiente ha sido fundamental en la mayoría de lenguajes de programación; tal es el caso del Tidyverse. Como bien se especifica en su página oficial, “The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures”. Estos paquetes están enfocados a tener un mejor flujo de escritura, a tener un mejor entendimiento de la estructura de los procesos, dar funciones que solucionen problemas comunes y, como ya se menciono, mejorar el rendimiento de las funciones. Dentro de este conjunto de paquetes se encuentran funciones para leer distintos tipos de archivos como aquellos con extensión .csv y .xls, además aquellas para reconocer archivos dados por SPSS, Stata y SAS, manipular archivos JSON, XML, dar una interfaz para trabajar con APIs, hacer web scraping y tener comunicación con diferentes administradores de bases de datos como SQL, MariaDB, etc. Se tienen paquetes especializados en la manipulación y limpieza de datos, también para crear modelos con estos, dar características especiales como catalogar y tratar a ciertas variables como fechas y factores, aplicar técnicas de expresiones regulares en dichos datos, aplicar funciones optimizadas que pueden remplazar a las de la familia apply y crear gráficas profesionales con una mayor fluidez. Aquí se verán solo algunos de los paquetes que componen todo este “universo limpio” y se comenzará con un operador fundamental proporcionado por el paquete magritt: %&gt;%, el cual se podrá utilizar casi siempre en R. Dicho operador tiene por nombre pipe, el cual tiene un uso similar al dado en otros lenguajes de programación como Python: . y bash: |. Este tiene como objetivo encadenar procesos de tal forma que el resultado dado en la cadena sirve como input del siguiente eslabón en dicha cadena, lo cual ayuda a evitar el anidamiento de funciones, minimizar la cantidad de objetos locales y facilitar la lectura e implementación de una secuencia de operaciones. Supongase que se desea resolver la tarea sencilla de aplicar una cantidad definida de operaciones sobre un número; por ejemplo, obtener la raíz cuadrada del logaritmo natural de un número multiplicado por el cuadrado de otro, a dicho valor sumarlo con los primeros 10 naturales y, finalmente, obtener la raíz cuadrada de dicho resultado. Esto se puede resolver de la siguiente manera; supongamos que los números son 10 y 20. sqrt(sum(sqrt(log(prod(10, 20^2))), 1:10)) [1] 7.607887 En tal caso se tuvo que anidar las funciones para aplicar estas cada resultado obtenido. Con %&gt;% la solución se ve de esta forma library(magrittr) 10 %&gt;% # 10 prod(20^2) %&gt;% #se multiplica por 20^2 log() %&gt;% #se obtiene el logaritmo de dicho número sqrt() %&gt;% #Se obtiene la raíz cuadrada sum(1:10) %&gt;% #A eso se le suman los primeros 10 naturales sqrt() #Se obtiene la raíz cuadrada. [1] 7.607887 La anterior solución tiene una estructura más fiel a como se fue resolviendo el problema poco a poco sin tiene que escribir hacia la izquierda para aplicar resultados de funciones anidadas. Más adelante se verá que el uso de dicho operador resulta fundamental para ahorra tiempo al momento de escribir código. Otro ejemplo: matrix(1:100, ncol = 5, byrow = 20) %&gt;% #Creación de una matriz con los primeros 100 naturales. rowSums(10) %&gt;% #Se suma por renglón añadiendo 10 unidades a dicho resultado. as.matrix() %&gt;% #Se convierte dicho resultado a matriz. scale() %&gt;% #Se normalizan los datos. sum() #Se comprueba que estos sumen media cero. [1] 0 Como la mayoría de la información que se utilizará se tendrá que cargar con alguna librería, aquí se dejan algunos ejemplos de algunas funciones útiles en la lectura de información. La función read_csv() es una de las más comunes para leer archivos separados por comas, en la cual se puede dar el path del archivo o la dirección URL de dichos datos. En este caso se esta utilizando unos datos donde se relaciona la información sobre exceso de velocidad de ciertos automóviles y señales de advertencia. Para más información consúltese el siguiente enlace. .scroll-300 { max-height: 300px; } library(readr) library(tibble) (amis &lt;- readr::read_csv(&quot;Data/amis.csv&quot;) %&gt;% head(10)) # A tibble: 10 x 5 X1 speed period warning pair &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 26 1 1 1 2 2 26 1 1 1 3 3 26 1 1 1 4 4 26 1 1 1 5 5 27 1 1 1 6 6 28 1 1 1 7 7 28 1 1 1 8 8 28 1 1 1 9 9 28 1 1 1 10 10 29 1 1 1 readr::read_csv(&quot;https://vincentarelbundock.github.io/Rdatasets/csv/boot/amis.csv&quot;) %&gt;% head(10) # A tibble: 10 x 5 X1 speed period warning pair &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 26 1 1 1 2 2 26 1 1 1 3 3 26 1 1 1 4 4 26 1 1 1 5 5 27 1 1 1 6 6 28 1 1 1 7 7 28 1 1 1 8 8 28 1 1 1 9 9 28 1 1 1 10 10 29 1 1 1 En caso de que se desee leer un archivo por algún otro delimitador, se puede usar la función read_delim() y en el caso de tener archivos donde el delimitador sea “\\t” usar la función read_tsv(). Los datos que se utilizan son proporcionados por el US Census Bureau, los cuales fueron indirectamente obtenidos del siguiente enlance. library(readxl) (US_Census_Bureau &lt;- readr::read_delim(&quot;Data/US Census Bureau.txt&quot;, delim = &quot;|&quot;)) # A tibble: 54 x 11 X1 `1900` `1901` `1902` `1903` `1904` `1905` `1906` `1907` `1908` `1909` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 U.S. 76094 77585 79160 80632 82165 83820 85437 87000 88709 90,492 2 Northe… 21059 21401 21815 22248 22716 23214 23769 24320 24879 25,440 3 North_… 26359 26722 27126 27446 27830 28203 28524 28868 29187 29,530 4 South 24565 25114 25599 26055 26492 27003 27475 27879 28406 28,963 5 West 4112 4351 4620 4882 5127 5398 5671 5934 6234 6,557 6 AL 1830 1907 1935 1957 1978 2012 2045 2058 2070 2,108 7 AR 1314 1341 1360 1384 1419 1447 1465 1484 1513 1,545 8 AZ 124 131 138 144 151 158 167 176 186 196 9 CA 1490 1550 1623 1702 1792 1893 1976 2054 2161 2,282 10 CO 543 581 621 652 659 680 707 733 757 775 # … with 44 more rows read_tsv(&quot;Data/US Census Bureautsv.txt&quot;) # A tibble: 54 x 11 X1 `1900` `1901` `1902` `1903` `1904` `1905` `1906` `1907` `1908` `1909` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 U.S. 76094 77585 79160 80632 82165 83820 85437 87000 88709 90,492 2 Northe… 21059 21401 21815 22248 22716 23214 23769 24320 24879 25,440 3 North_… 26359 26722 27126 27446 27830 28203 28524 28868 29187 29,530 4 South 24565 25114 25599 26055 26492 27003 27475 27879 28406 28,963 5 West 4112 4351 4620 4882 5127 5398 5671 5934 6234 6,557 6 AL 1830 1907 1935 1957 1978 2012 2045 2058 2070 2,108 7 AR 1314 1341 1360 1384 1419 1447 1465 1484 1513 1,545 8 AZ 124 131 138 144 151 158 167 176 186 196 9 CA 1490 1550 1623 1702 1792 1893 1976 2054 2161 2,282 10 CO 543 581 621 652 659 680 707 733 757 775 # … with 44 more rows El paquete readxl esta diseño para leer archivos excel. La siguiente información proporciona la población por sexo y entidad federativa según grupos de edad quinquenales de acuerdo a los tabulados básicos de la CONAPO. (Population_FEntity &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B5:Q38&quot;)) # A tibble: 33 x 16 ...1 ...2 `0 a 4` `5 a 9` `10 a 14` `15 a 19` `20 a 24` `25 a 29` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Repú… 1.03e8 9.31 10.4 11.2 10.1 8.33 7.33 2 Agua… 1.07e6 10.3 11.0 11.1 10.9 8.27 7.34 3 Baja… 2.86e6 9.41 10.3 11.1 10.7 8.43 7.82 4 Baja… 5.12e5 9.00 8.44 10.1 10.8 8.75 7.37 5 Camp… 7.56e5 8.34 10.4 12.7 9.52 9.23 7.74 6 Coah… 2.50e6 9.78 10.1 10.6 9.96 8.31 7.11 7 Coli… 5.69e5 8.09 8.43 10.0 11.0 9.29 7.11 8 Chia… 4.29e6 11.4 11.8 13.2 11.0 9.16 7.15 9 Chih… 3.24e6 7.83 10.2 11.0 9.49 7.71 6.03 10 Dist… 8.74e6 7.82 8.82 8.09 8.19 7.86 7.89 # … with 23 more rows, and 8 more variables: `30 a 34` &lt;dbl&gt;, `35 a 39` &lt;dbl&gt;, # `40 a 44` &lt;dbl&gt;, `45 a 49` &lt;dbl&gt;, `50 a 54` &lt;dbl&gt;, `55 a 59` &lt;dbl&gt;, `60 y # más` &lt;dbl&gt;, NE &lt;dbl&gt; Algo que hay que tener en cuenta al trabajar con los paquetes del tidyverse es el uso de tibbles en lugar de data frames. class(amis) [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Un tibble es una versión moderna de un data frame que trabaja de manera perezosa (es decir, que realiza menos operaciones) evitando problemas comunes y supuestos que un data frame puede llegar a asumir. Por ejemplo, los tibbles no coercionan automáticamente los caracteres a factores, no crean nombres para las observaciones y no cambia los nombres de columnas que sean nombres no sintácticos, por ejemplo tibble(&quot;:)&quot; = &quot;feliz&quot;, &quot;:(&quot;=&quot;triste&quot;) # A tibble: 1 x 2 `:)` `:(` &lt;chr&gt; &lt;chr&gt; 1 feliz triste data.frame(&quot;:)&quot; = &quot;feliz&quot;, &quot;:(&quot;=&quot;triste&quot;) X.. X...1 1 feliz triste Se pueden utilizar variables desde la construcción del tibble (t &lt;- tibble(x = 1:20, y = x-1)) # A tibble: 20 x 2 x y &lt;int&gt; &lt;dbl&gt; 1 1 0 2 2 1 3 3 2 4 4 3 5 5 4 6 6 5 7 7 6 8 8 7 9 9 8 10 10 9 11 11 10 12 12 11 13 13 12 14 14 13 15 15 14 16 16 15 17 17 16 18 18 17 19 19 18 20 20 19 ¿Qué sucede al ejecutar data.frame(x = 1:20, y = x-1)? Además se tienen diferencias respecto a la impresión entre un tibble y un data frame, un tibble permite agregar listas directamente sin tener que usar la función I() y los tibbles nunca hacen emparejamiento parcial. t2 &lt;- tibble(xy=1:20, z = 1:20) d2 &lt;- data.frame(xy = 1:20, z = 1:20) str(t2$x) NULL str(d2$x) int [1:20] 1 2 3 4 5 6 7 8 9 10 ... Finalmente, los tibbles permiten hacer substracciones con el operador pipe. #t$x t %&gt;% .$x [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #t[[&quot;x&quot;]] t %&gt;% .[[&quot;x&quot;]] [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ¿Qué hace la función tribble()? "],
["limpieza-de-datos-tidyr.html", "Capítulo 5 Limpieza de datos: Tidyr", " Capítulo 5 Limpieza de datos: Tidyr En un análisis de datos, gran parte del tiempo que se utiliza es dando un grado de limpieza a estos, para así ya solo obtener información resumen, aplicar modelos o manipularlos para descubrir algo en ellos. De acuerdo a las fuentes que se consulten, esto puede tomar hasta un 80% del tiempo que se dispone, por lo que es evidente la necesidad de tener funciones que ayuden con dicha tarea. La limpieza de datos varía dependiendo de los fines, pero para Hadley Wickham (Chief Scientist en RStudio y alguien importante en desarrollo y mantenimiento del tidyverse) tener una limpieza en los datos requiere de ciertas características. La información completa se puede encontrar en artículo de Hadley, Tidy Data, pero básicamente se tienen 3 puntos importantes para considerar que los datos son limpios. Cada variable forma una columna. Cada observación forma un renglón. Cada valor debe tener su propia celda. Las siguientes gráficas representan dichos puntos sobre un subconjunto de Iris. * { box-sizing: border-box; } .column { float: left; width: 33.33%; padding: 5px; } /* Clearfix (clear floats) */ .row::after { content: \"\"; clear: both; display: table; } Con lo anterior establecido y suponiendo que se esta analizando una pequeña base de datos correspondientes a las calificaciones de ciertos alumnos ¿Cuál de las siguientes estructuras es correcta? Colocando las observaciones respecto a los nombres Matemáticas Química Juan 8 9 Carlos 9 7 Luis 7 8 Allison 9 9 Leticia 8 9 Colocando las observaciones respecto a la materia Juan Carlos Luis Allison Leticia Matemáticas 8 9 7 9 8 Química 9 7 8 9 9 De hecho, ninguna de las dos opciones anteriores es correcta. De acuerdo a los principios anteriores para tener datos limpios, cada variable debe formar una columna, lo cual no sucede en este caso, ya que las variables aquí son estudiante o el nombre, la materia y las calificaciones. Es decir, que las configuración correcta es la siguiente Nombre Asignatura Calificaciones Juan Matemáticas 8 Carlos Matemáticas 9 Luis Matemáticas 7 Allison Matemáticas 9 Leticia Matemáticas 8 Juan Química 9 Carlos Química 7 Luis Química 8 Allison Química 9 Leticia Química 9 Esto es uno de los tantos ejemplos que se pueden dar cuando se trabajando con datos. En el momento en que se identifican estos problemas, se deberá usar toda la creatividad para resolverlos y obtener una estructura con la que ya se pueda trabajar. El paquete tidyr ayudará con la mayoría de estos. Como recomendación, se aconseja tener a la mano siempre la respectiva Cheat Sheet que pueda ser de utilidad, en este caso de la librería tidyr se pueden consultar Data import y Data Wrangling; las respectivas traducciones al español se pueden encontrar en la página oficial de Cheat Sheets de RStudio. Como bien dice Hadley en Tidy Data, hay cinco problemas comunes en los messy datasets: Los encabezados son valores y no nombres de dichas variables. Múltiples variables están contenidas en una sola. Existen variables que están almacenadas tanto en renglones como columnas. Múltiples tipos de observaciones están en la misma tabla. Una sola observación esta en múltiples tablas. En la sección anterior se presentaron los datos para la población por sexo y entidad federativa según grupos de edad quinquenales de acuerdo a los tabulados básicos de la CONAPO .scroll-300 { max-height: 300px; } colnames(Population_FEntity)[1:2] &lt;- c(&quot;Entidad Federativa&quot;, &quot;Población Total&quot;) Population_FEntity # A tibble: 33 x 16 `Entidad Federa… `Población Tota… `0 a 4` `5 a 9` `10 a 14` `15 a 19` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 República Mexic… 103498524 9.31 10.4 11.2 10.1 2 Aguascalientes 1066233 10.3 11.0 11.1 10.9 3 Baja California 2856361 9.41 10.3 11.1 10.7 4 Baja California… 512030 9.00 8.44 10.1 10.8 5 Campeche 755703 8.34 10.4 12.7 9.52 6 Coahuila 2501413 9.78 10.1 10.6 9.96 7 Colima 568642 8.09 8.43 10.0 11.0 8 Chiapas 4293414 11.4 11.8 13.2 11.0 9 Chihuahua 3241513 7.83 10.2 11.0 9.49 10 Distrito Federal 8737172 7.82 8.82 8.09 8.19 # … with 23 more rows, and 10 more variables: `20 a 24` &lt;dbl&gt;, `25 a 29` &lt;dbl&gt;, # `30 a 34` &lt;dbl&gt;, `35 a 39` &lt;dbl&gt;, `40 a 44` &lt;dbl&gt;, `45 a 49` &lt;dbl&gt;, `50 a # 54` &lt;dbl&gt;, `55 a 59` &lt;dbl&gt;, `60 y más` &lt;dbl&gt;, NE &lt;dbl&gt; En las primeras dos columnas se cambiaron los nombres con las herramientas que hasta este momento se tienen. Véase que las demás columnas representan rangos de edad, por lo que se tiene el primer problema en los messy datasets. De hecho, en estos datos las variables son la Entidad Federativa, la Población Total, el Rango de Edad y el Porcentaje de la población total en ese rango de edad. En estos casos se dice los datos son anchos, y lo que se desea es que estos estén en un formato largo (ancho por la cantidad de columnas y largo por la cantidad de observaciones). Para tales casos se utiliza la función tidyr::gather() la cual recibe como parámetros múltiples columnas y colapsa la información de estas en dos variables. (Population_FEntity &lt;- gather(data = Population_FEntity, key = &quot;Rango_edad&quot;, value = &quot;Porcentaje&quot;, -c(&quot;Entidad Federativa&quot;, &quot;Población Total&quot;))) # A tibble: 462 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 República Mexicana 103498524 0 a 4 9.31 2 Aguascalientes 1066233 0 a 4 10.3 3 Baja California 2856361 0 a 4 9.41 4 Baja California Sur 512030 0 a 4 9.00 5 Campeche 755703 0 a 4 8.34 6 Coahuila 2501413 0 a 4 9.78 7 Colima 568642 0 a 4 8.09 8 Chiapas 4293414 0 a 4 11.4 9 Chihuahua 3241513 0 a 4 7.83 10 Distrito Federal 8737172 0 a 4 7.82 # … with 452 more rows Con lo anterior se logro tener una mejor estructura en los datos, con lo cual fácilmente se podrían crear gráficas, modelos y estadísticas de resumen por Entidad Federativa o por rango de edad. Después de tener la información con una estructura adecuada, la imaginación es el único limitante. En el siguiente capítulo se verá como manipular internamente los datos para que se tenga una mejor semántica en ellos. Si se desea por algún motivo, lo cual puede suceder, tener los datos en formato ancho, se puede usar la función complementaria la cual es tidyr::spread() Population_FEntity %&gt;% spread(key = &quot;Rango_edad&quot;,value = &quot;Porcentaje&quot;) # A tibble: 33 x 16 `Entidad Federa… `Población Tota… `0 a 4` `10 a 14` `15 a 19` `20 a 24` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 10.3 11.1 10.9 8.27 2 Baja California 2856361 9.41 11.1 10.7 8.43 3 Baja California… 512030 9.00 10.1 10.8 8.75 4 Campeche 755703 8.34 12.7 9.52 9.23 5 Chiapas 4293414 11.4 13.2 11.0 9.16 6 Chihuahua 3241513 7.83 11.0 9.49 7.71 7 Coahuila 2501413 9.78 10.6 9.96 8.31 8 Colima 568642 8.09 10.0 11.0 9.29 9 Distrito Federal 8737172 7.82 8.09 8.19 7.86 10 Durango 1509025 9.97 11.8 10.3 8.11 # … with 23 more rows, and 10 more variables: `25 a 29` &lt;dbl&gt;, `30 a 34` &lt;dbl&gt;, # `35 a 39` &lt;dbl&gt;, `40 a 44` &lt;dbl&gt;, `45 a 49` &lt;dbl&gt;, `5 a 9` &lt;dbl&gt;, `50 a # 54` &lt;dbl&gt;, `55 a 59` &lt;dbl&gt;, `60 y más` &lt;dbl&gt;, NE &lt;dbl&gt; Finalmente: Un equivalente de la función tidyr:: gather() la proporciona el paquete reshape con su función melt(). Para la función tidyr:: spread() se tiene la función reshape::dcast(). Depende de la versión que se utilice, las funciones gather() y spread() podrían haber sido remplazadas por las funciones tidyr::pivot_longer() y pivot_wider() respectivamente. En otros lenguajes de programación, a estas técnicas se les conoce como pivoteo. Para ver un ejemplo del segundo punto, supóngase que los datos vistos al inicio donde se relacionaban las calificaciones de ciertos alumnos tienen originalmente la siguiente estructura # A tibble: 10 x 2 Nombre `A/C` &lt;chr&gt; &lt;chr&gt; 1 Juan M8 2 Carlos M9 3 Luis M7 4 Allison M9 5 Leticia M8 6 Juan Q9 7 Carlos Q7 8 Luis Q8 9 Allison Q9 10 Leticia Q9 En tal caso, la segunda variable contiene la información tanto de la materia como de la calificación. Aquí la función tidyr::separate() es de gran ayuda (Student_grades &lt;- Student_grades %&gt;% separate(col = &quot;A/C&quot;, into = c(&quot;Asignatura&quot;, &quot;Calificaciones&quot;), sep = 1)) # A tibble: 10 x 3 Nombre Asignatura Calificaciones &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Juan M 8 2 Carlos M 9 3 Luis M 7 4 Allison M 9 5 Leticia M 8 6 Juan Q 9 7 Carlos Q 7 8 Luis Q 8 9 Allison Q 9 10 Leticia Q 9 En el argumento sep se da la posición dentro del texto para separar los datos. En el caso en que se desee tener el caso inverso, se utiliza la función tidyr::unite() Student_grades %&gt;% unite(&quot;A/C&quot;, c(&quot;Asignatura&quot;, &quot;Calificaciones&quot;), sep = &quot;&quot;) # A tibble: 10 x 2 Nombre `A/C` &lt;chr&gt; &lt;chr&gt; 1 Juan M8 2 Carlos M9 3 Luis M7 4 Allison M9 5 Leticia M8 6 Juan Q9 7 Carlos Q7 8 Luis Q8 9 Allison Q9 10 Leticia Q9 Otro ejemplo lo proporciona la Cheat Sheet Data Wrangling. # A tibble: 10,010 x 11 name date hour lat long status category wind pressure ts_diameter &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 Amy 1975… 0 27.5 -79 tropi… -1 25 1013 NA 2 Amy 1975… 6 28.5 -79 tropi… -1 25 1013 NA 3 Amy 1975… 12 29.5 -79 tropi… -1 25 1013 NA 4 Amy 1975… 18 30.5 -79 tropi… -1 25 1013 NA 5 Amy 1975… 0 31.5 -78.8 tropi… -1 25 1012 NA 6 Amy 1975… 6 32.4 -78.7 tropi… -1 25 1012 NA 7 Amy 1975… 12 33.3 -78 tropi… -1 25 1011 NA 8 Amy 1975… 18 34 -77 tropi… -1 30 1006 NA 9 Amy 1975… 0 34.4 -75.8 tropi… 0 35 1004 NA 10 Amy 1975… 6 34 -74.8 tropi… 0 40 1002 NA # … with 10,000 more rows, and 1 more variable: hu_diameter &lt;dbl&gt; separate(storms, col = date ,into = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), sep = c(4, 5)) # A tibble: 10,010 x 13 name year month day hour lat long status category wind pressure &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; 1 Amy 1975 6 27 0 27.5 -79 tropi… -1 25 1013 2 Amy 1975 6 27 6 28.5 -79 tropi… -1 25 1013 3 Amy 1975 6 27 12 29.5 -79 tropi… -1 25 1013 4 Amy 1975 6 27 18 30.5 -79 tropi… -1 25 1013 5 Amy 1975 6 28 0 31.5 -78.8 tropi… -1 25 1012 6 Amy 1975 6 28 6 32.4 -78.7 tropi… -1 25 1012 7 Amy 1975 6 28 12 33.3 -78 tropi… -1 25 1011 8 Amy 1975 6 28 18 34 -77 tropi… -1 30 1006 9 Amy 1975 6 29 0 34.4 -75.8 tropi… 0 35 1004 10 Amy 1975 6 29 6 34 -74.8 tropi… 0 40 1002 # … with 10,000 more rows, and 2 more variables: ts_diameter &lt;dbl&gt;, # hu_diameter &lt;dbl&gt; Se tiene un equivalente para separar en renglones: tidyr::separate_rows() Un equivalente la función separate() esta dada por reshape::colsplit(). En el caso que se tenga el problema donde algunas variables esten almacenadas tanto en renglones como columnas se debe tratar el problema como lo anterior visto, primero abstraerse al problema de juntar las columnas necesarias en dos variables con la función gather() para posteriormente separar las variables que lo requieran con la función separate(). Para los últimos dos casos se necesita hacer uso de unas funciones del paquete dplyr, el cual ser verá en la siguiente sección. Por el momento, se pueden ver otras funciones útiles de tidyr, como aquellas que ayudan en la obtención de diferentes operaciones de conjuntos en los datos. df &lt;- data_frame(x = 1:2, y = 2:1) tidyr::expand_grid(df, z = 1:3) # A tibble: 6 x 3 x y z &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 1 2 1 2 1 2 2 3 1 2 3 4 2 1 1 5 2 1 2 6 2 1 3 La función tidyr::expand_grid() crea un tibble de todas las combinaciones de sus inputs, estos pueden ser data frames o tibbles, matrices y hasta vectores. Se puede entender a esta función como el producto cartesiano de dos conjuntos. x &lt;- data_frame(x = letters[5:7]) y &lt;- data_frame(c(3,3,1)) crossing(x, y) # A tibble: 6 x 2 x `c(3, 3, 1)` &lt;chr&gt; &lt;dbl&gt; 1 e 1 2 e 3 3 f 1 4 f 3 5 g 1 6 g 3 La función tidyr::crossing() regresa un tibble y tiene un comportamiento similar a expand_grid() con la diferencia de eliminar registros duplicados. set.seed(20) x &lt;- data_frame(sample(letters[1:3], size = 5, replace = T)) y &lt;- data_frame(y = sample(1:3, size = 5, replace = T)) tidyr::nesting(x, y) # A tibble: 4 x 2 `sample(letters[1:3], size = 5, replace = T)` y &lt;chr&gt; &lt;int&gt; 1 a 1 2 b 2 3 c 1 4 c 2 La función tidyr::nesting() encuentra las posibles combinaciones entre los datos, es decir, las combinaciones entre los datos de entrada si estos se unieran en uno solo. set.seed(20) reduced_iris &lt;- iris %&gt;% head() df &lt;- reduced_iris[sample(1:6, size = 10, replace = T),] df %&gt;% tidyr::expand(Petal.Length) # A tibble: 3 x 1 Petal.Length &lt;dbl&gt; 1 1.3 2 1.4 3 1.7 La función tidyr::expand() genera todas las combinaciones de variables que se encuentran en un data set. ¿Qué sucede al ejecutar df %&gt;% tidyr::expand(Sepal.Width, Petal.Width)? ¿Y al ejecutar df %&gt;% tidyr::expand(nesting(Sepal.Width, Petal.Width))? Otras funciones útiles son las siguientes tidyr::nest(). Dicha función anida un data frame o un subconjunto de este en listas y coloca estos como observaciones; esto puede ser muy útil en la aplicación de modelos. tidyr::unnest(). Función inversa a tidyr::nest(). tidyr::replace_na(). Dicha función encuentra los valores perdidos en un data set y los cambia por un valor dado. Ejercicios En la sección Limpieza de datos: Tidyr se vieron varios ejemplos donde se mencionaba que estos venían como sugerencias de las respectivas Cheat Sheets. Dichos datos fueron manipulados para ver el uso de las funciones que se estaban presentando. Obtén la estructura de los datos a los cuales se les aplicaron dichas funciones. Investigar otras funciones de tidyr como chop(), complete() y pack(). "],
["manipulación-de-datos-dplyr.html", "Capítulo 6 Manipulación de datos: Dplyr", " Capítulo 6 Manipulación de datos: Dplyr Así como es de importante la limpieza en un análisis de datos, lo es la manipulación de estos, ya que la información que contienen debe ser extraída y será poco probable que se vean a simple vista. Para dichas tareas el paquete dplyr, parte del tidyverse, es una de las mejores opciones. dplyr tiene tres metas principales: Identificar los verbos de manipulación más importantes en la manipulación de datos y hacerlos fácil de usar en R. Esto mediante un conjunto de funciones que se verán en esta sección. Proporcionar un gran rendimiento en datos alojados en memoria utilizando código en C++ mediante la librería Rcpp en sus funciones. Usar la misma interfaz para trabajar con los datos sin importar cuando y como estén almacenados (data frame, data table o en una base de datos). Para este paquete se puede obtener su Cheat Sheet oficial y es mencionada en otras como Data import y Data Wrangling. También se puede usar el comando vignette(\"dplyr\", package=\"dplyr\") para ver una guía con ejemplos de este paquete donde utilizan una base de datos de Star Wars obtenida directamente de su API. Para este caso, se tomará las bases de datos que ya se utilizaron en la sección anterior para ver el funcionamiento de algunas de las funciones de dplyr. "],
["dplyrfilter.html", "6.1 dplyr::filter()", " 6.1 dplyr::filter() Las funciones en dplyr son vectorizadas, por lo que podemos estar seguros que se esta trabajando de manera adecuada. Es común pensar en una función vectorizada como un remplazo eficiente de un ciclo con una operación dada; para este caso, filtrar un conjunto de datos puede ser tedioso mediante ciclos anidados y es lo que se puede remplazar con la función dplyr::filter(). En la base de datos donde se reúne la información correspondiente a la población de México por rangos de edad quinquenales, es evidente que se puede obtener la población total de todo el territorio con la suma de las cantidades dadas por cada estado, así que este registro será eliminado. .scroll-300 { max-height: 300px; } (Population_FEntity &lt;- Population_FEntity %&gt;% filter(`Entidad Federativa`!=&quot;República Mexicana&quot;)) # A tibble: 448 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 10.3 2 Baja California 2856361 0 a 4 9.41 3 Baja California Sur 512030 0 a 4 9.00 4 Campeche 755703 0 a 4 8.34 5 Coahuila 2501413 0 a 4 9.78 6 Colima 568642 0 a 4 8.09 7 Chiapas 4293414 0 a 4 11.4 8 Chihuahua 3241513 0 a 4 7.83 9 Distrito Federal 8737172 0 a 4 7.82 10 Durango 1509025 0 a 4 9.97 # … with 438 more rows Véase que dplyr::filter() utilizó la variable Entidad Federativa y elimino los registros que no cumplieran con la condición dada: !=\"República Mexicana\", al igual que se hubiera hecho con un condicional if() en ciclos anidados. En esta función se pueden aplicar los operados lógicos conocidos ==, &lt;=, %in%, etc. Además de los operados de conjuntos como |, &amp; y xor(). En el siguiente ejemplo solo se toman aquellos estados donde el rango de edad sea 25 a 29 años y tengan un porcentaje de su población total en dicha edad entre 7.5 y 8.5. Population_FEntity %&gt;% filter(Rango_edad == &quot;25 a 29&quot; &amp; Porcentaje &gt;= 7.5 &amp; Porcentaje &lt; 8.5) # A tibble: 9 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Baja California 2856361 25 a 29 7.82 2 Campeche 755703 25 a 29 7.74 3 Distrito Federal 8737172 25 a 29 7.89 4 Jalisco 6754506 25 a 29 7.80 5 México 14174039 25 a 29 8.42 6 Nuevo León 4199361 25 a 29 7.74 7 Quintana Roo 1135436 25 a 29 8.45 8 Tabasco 1991059 25 a 29 7.65 9 Yucatán 1820537 25 a 29 7.98 Como el resultado es un tibble, bien podría utilizarse las veces que se desee la función utilizando %&gt;% a los resultados previos. En este caso no se tienen valores perdidos pero es bueno recordar que la función is.na() regresa un vector booleano indicando si en el input dado se tienen valores perdidos, por lo que podría usarse con la función filter() para detectar dichos valores de una manera rápida. Además de obtener un subconjunto de los datos con filter(), dplyr ofrece otras funciones útiles para obtener un subconjunto específico de datos. Obtener valores distintos en toda la base o por algunas variables específicas: Population_FEntity %&gt;% distinct(`Entidad Federativa`) # A tibble: 32 x 1 `Entidad Federativa` &lt;chr&gt; 1 Aguascalientes 2 Baja California 3 Baja California Sur 4 Campeche 5 Coahuila 6 Colima 7 Chiapas 8 Chihuahua 9 Distrito Federal 10 Durango # … with 22 more rows set.seed(20) data_easy &lt;- tibble(x = sample(letters, 50, replace = TRUE), y = sample(1:25, 50, replace = TRUE)) data_easy %&gt;% distinct(y) # A tibble: 23 x 1 y &lt;int&gt; 1 1 2 15 3 6 4 2 5 10 6 20 7 23 8 22 9 7 10 3 # … with 13 more rows Obtener un porcentaje de los datos o un número de observaciones de manera aleatoria: Population_FEntity %&gt;% sample_frac(0.01, replace = FALSE) # A tibble: 4 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Guanajuato 4894608 50 a 54 4.03 2 Chiapas 4293414 20 a 24 9.16 3 Nayarit 952230 15 a 19 10.7 4 Chiapas 4293414 30 a 34 6.28 Population_FEntity %&gt;% sample_n(4, replace = FALSE) # A tibble: 4 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Puebla 5386250 25 a 29 7.05 2 Nayarit 952230 0 a 4 9.86 3 Durango 1509025 25 a 29 6.55 4 Coahuila 2501413 55 a 59 3.31 Obtener renglones específicos: Population_FEntity %&gt;% slice(1:3) # A tibble: 3 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 10.3 2 Baja California 2856361 0 a 4 9.41 3 Baja California Sur 512030 0 a 4 9.00 "],
["dplyrselect.html", "6.2 dplyr::select()", " 6.2 dplyr::select() La función anterior sólo trabaja con observaciones, por lo que también debe existir un análogo para las variables, dicha función es dplyr::select(), la cual permite un conjunto de funciones útiles para hacer selecciones específicas de variables. Population_FEntity %&gt;% select(`Entidad Federativa`, Rango_edad, Porcentaje) %&gt;% head() # A tibble: 6 x 3 `Entidad Federativa` Rango_edad Porcentaje &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 10.3 2 Baja California 0 a 4 9.41 3 Baja California Sur 0 a 4 9.00 4 Campeche 0 a 4 8.34 5 Coahuila 0 a 4 9.78 6 Colima 0 a 4 8.09 Lo anterior es equivalente a la siguiente instrucción: Population_FEntity %&gt;% select(!`Población Total`) %&gt;% head() # A tibble: 6 x 3 `Entidad Federativa` Rango_edad Porcentaje &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 10.3 2 Baja California 0 a 4 9.41 3 Baja California Sur 0 a 4 9.00 4 Campeche 0 a 4 8.34 5 Coahuila 0 a 4 9.78 6 Colima 0 a 4 8.09 Utilizar el operando ! se indica que dicha variable no se desea observar, dicha instrucción se pudo haber sustituido con Population_FEntity %&gt;% select(-'Población Total'). También se puede usar un rango de columnas con :. La función select tiene algunas funciones auxiliares para trabajar con texto como el uso de expresiones regulares. Algunas de estas funciones son contains(), ends_with() y start_with(). Para el uso de este tipo de filtros en observaciones, véase el paquete stringr. iris %&gt;% select(starts_with(&quot;Petal&quot;)) %&gt;% head() Petal.Length Petal.Width 1 1.4 0.2 2 1.4 0.2 3 1.3 0.2 4 1.5 0.2 5 1.4 0.2 6 1.7 0.4 Population_FEntity %&gt;% select(contains(&quot;_&quot;)) %&gt;% head() # A tibble: 6 x 1 Rango_edad &lt;chr&gt; 1 0 a 4 2 0 a 4 3 0 a 4 4 0 a 4 5 0 a 4 6 0 a 4 Finalmente, para obtener todas las columnas se puede usar la función dplyr::everything(), para obtener variables donde sus nombres estén en un grupo dplyr::one_of y para seleccionar las variables por rango dplyr::num_range(). "],
["dplyrarrange.html", "6.3 dplyr::arrange()", " 6.3 dplyr::arrange() Para ordenar una variable de forma ascendente o descendente se utiliza la función dplyr::arrange(). Al ordenar una variable, se ordenan todos los datos de acuerdo a esa variable de referencia. Population_FEntity %&gt;% arrange(`Entidad Federativa`) # A tibble: 448 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 10.3 2 Aguascalientes 1066233 5 a 9 11.0 3 Aguascalientes 1066233 10 a 14 11.1 4 Aguascalientes 1066233 15 a 19 10.9 5 Aguascalientes 1066233 20 a 24 8.27 6 Aguascalientes 1066233 25 a 29 7.34 7 Aguascalientes 1066233 30 a 34 7.85 8 Aguascalientes 1066233 35 a 39 6.23 9 Aguascalientes 1066233 40 a 44 5.19 10 Aguascalientes 1066233 45 a 49 5.49 # … with 438 more rows Además, se pueden ordenar los registros por múltiples variables. En este ejemplo se ordenan los datos de la población mexicana por la Entidad Federativa y, de manera descendente, el porcentaje de la población total por grupos quinquenales de edad. Population_FEntity %&gt;% arrange(`Entidad Federativa`, desc(Porcentaje)) # A tibble: 448 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 10 a 14 11.1 2 Aguascalientes 1066233 5 a 9 11.0 3 Aguascalientes 1066233 15 a 19 10.9 4 Aguascalientes 1066233 0 a 4 10.3 5 Aguascalientes 1066233 20 a 24 8.27 6 Aguascalientes 1066233 30 a 34 7.85 7 Aguascalientes 1066233 60 y más 7.82 8 Aguascalientes 1066233 25 a 29 7.34 9 Aguascalientes 1066233 35 a 39 6.23 10 Aguascalientes 1066233 45 a 49 5.49 # … with 438 more rows "],
["dplyrmutate.html", "6.4 dplyr::mutate()", " 6.4 dplyr::mutate() La función arrange() modificó de una forma sutil los datos, sólo el orden; pero en el caso de que se desee modificar o agregar una nueva variable, ya sea en función de los valores de otra o nuevos valores independientes, se utiliza la función dplyr::mutate(). Population_FEntity %&gt;% mutate(Var_fake = sample(1:50, size = 448, replace = TRUE)) # A tibble: 448 x 5 `Entidad Federativa` `Población Total` Rango_edad Porcentaje Var_fake &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 Aguascalientes 1066233 0 a 4 10.3 20 2 Baja California 2856361 0 a 4 9.41 11 3 Baja California Sur 512030 0 a 4 9.00 33 4 Campeche 755703 0 a 4 8.34 38 5 Coahuila 2501413 0 a 4 9.78 28 6 Colima 568642 0 a 4 8.09 3 7 Chiapas 4293414 0 a 4 11.4 16 8 Chihuahua 3241513 0 a 4 7.83 40 9 Distrito Federal 8737172 0 a 4 7.82 3 10 Durango 1509025 0 a 4 9.97 40 # … with 438 more rows En esta función se pueden aplicar funciones ya pre-establecidas, además de window functions (véase la Cheat Sheet Data Wrangling) que se pueden obtener de R o de dplyr como dplyr::lag() y dplyr::between(). Véase los siguientes ejemplos: Se modifica el porcentaje en términos correctos. Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) # A tibble: 448 x 4 `Entidad Federativa` `Población Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 0.103 2 Baja California 2856361 0 a 4 0.0941 3 Baja California Sur 512030 0 a 4 0.0900 4 Campeche 755703 0 a 4 0.0834 5 Coahuila 2501413 0 a 4 0.0978 6 Colima 568642 0 a 4 0.0809 7 Chiapas 4293414 0 a 4 0.114 8 Chihuahua 3241513 0 a 4 0.0783 9 Distrito Federal 8737172 0 a 4 0.0782 10 Durango 1509025 0 a 4 0.0997 # … with 438 more rows Se obtiene el porcentaje de población que tiene cada entidad federativa correspondiente a toda la población del país. (Recordar que la población total es 103,498,524) Population_FEntity %&gt;% mutate(Porcentaje_entidad = `Población Total`/103498524) %&gt;% select(c(`Entidad Federativa`, `Población Total`, Porcentaje_entidad)) # A tibble: 448 x 3 `Entidad Federativa` `Población Total` Porcentaje_entidad &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0.0103 2 Baja California 2856361 0.0276 3 Baja California Sur 512030 0.00495 4 Campeche 755703 0.00730 5 Coahuila 2501413 0.0242 6 Colima 568642 0.00549 7 Chiapas 4293414 0.0415 8 Chihuahua 3241513 0.0313 9 Distrito Federal 8737172 0.0844 10 Durango 1509025 0.0146 # … with 438 more rows Se obtiene el porcentaje de la población total que hay por grupo quinquenal. library(scales) Population_FEntity %&gt;% mutate(Porcentaje_entidad = `Población Total`/103498524, Porcentaje = Porcentaje/100) %&gt;% mutate(Porcentaje_quinquenal_P = percent(Porcentaje*Porcentaje_entidad, accuracy = 0.01)) %&gt;% select(`Entidad Federativa`, Rango_edad, Porcentaje_quinquenal_P) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad Porcentaje_quinquenal_P &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Aguascalientes 0 a 4 0.11% 2 Baja California 0 a 4 0.26% 3 Baja California Sur 0 a 4 0.04% 4 Campeche 0 a 4 0.06% 5 Coahuila 0 a 4 0.24% 6 Colima 0 a 4 0.04% 7 Chiapas 0 a 4 0.47% 8 Chihuahua 0 a 4 0.25% 9 Distrito Federal 0 a 4 0.66% 10 Durango 0 a 4 0.15% # … with 438 more rows Uso de funciones Student_grades %&gt;% mutate(Sobresaliente = if_else(Calificaciones&gt;=9, T, F)) # A tibble: 10 x 4 Nombre Asignatura Calificaciones Sobresaliente &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; 1 Juan M 8 FALSE 2 Carlos M 9 TRUE 3 Luis M 7 FALSE 4 Allison M 9 TRUE 5 Leticia M 8 FALSE 6 Juan Q 9 TRUE 7 Carlos Q 7 FALSE 8 Luis Q 8 FALSE 9 Allison Q 9 TRUE 10 Leticia Q 9 TRUE Agregar un índice a los datos Student_grades %&gt;% mutate(index = row_number()) # A tibble: 10 x 4 Nombre Asignatura Calificaciones index &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Juan M 8 1 2 Carlos M 9 2 3 Luis M 7 3 4 Allison M 9 4 5 Leticia M 8 5 6 Juan Q 9 6 7 Carlos Q 7 7 8 Luis Q 8 8 9 Allison Q 9 9 10 Leticia Q 9 10 Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Población&quot; = Porcentaje * `Población Total`) # A tibble: 448 x 5 `Entidad Federativa` `Población Total` Rango_edad Porcentaje Población &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 0.103 109853 2 Baja California 2856361 0 a 4 0.0941 268842 3 Baja California Sur 512030 0 a 4 0.0900 46070 4 Campeche 755703 0 a 4 0.0834 63034. 5 Coahuila 2501413 0 a 4 0.0978 244624. 6 Colima 568642 0 a 4 0.0809 45985 7 Chiapas 4293414 0 a 4 0.114 491525 8 Chihuahua 3241513 0 a 4 0.0783 253834. 9 Distrito Federal 8737172 0 a 4 0.0782 682914. 10 Durango 1509025 0 a 4 0.0997 150485 # … with 438 more rows En este último ejemplo se modifico la base de datos de la población donde puede notarse que la anterior función no elimina las variables con las que se opera, esto podría hacerse con la función select(), o bien con la función dplyr::transmute(), aunque elimina también aquellas columnas que no se utilizan. Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% transmute(&quot;Población&quot; = Porcentaje * `Población Total`) # A tibble: 448 x 1 Población &lt;dbl&gt; 1 109853 2 268842 3 46070 4 63034. 5 244624. 6 45985 7 491525 8 253834. 9 682914. 10 150485 # … with 438 more rows Así que se hará lo siguiente (Population_FEntity &lt;- Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Población&quot; = Porcentaje * `Población Total`) %&gt;% select(-Porcentaje)) # A tibble: 448 x 4 `Entidad Federativa` `Población Total` Rango_edad Población &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 2 Baja California 2856361 0 a 4 268842 3 Baja California Sur 512030 0 a 4 46070 4 Campeche 755703 0 a 4 63034. 5 Coahuila 2501413 0 a 4 244624. 6 Colima 568642 0 a 4 45985 7 Chiapas 4293414 0 a 4 491525 8 Chihuahua 3241513 0 a 4 253834. 9 Distrito Federal 8737172 0 a 4 682914. 10 Durango 1509025 0 a 4 150485 # … with 438 more rows "],
["dplyrgroup-by.html", "6.5 dplyr::group_by()", " 6.5 dplyr::group_by() Un funcionalidad muy importante es el uso de datos agrupados. Dichos grupos serán subconjuntos de datos que compartan una característica en común. Esto tiene muchas ventajas ya que se pueden obtener funciones resumen con una mayor fluidez y aplicaciones de funciones por bloques en lugar de observaciones individuales. La función para otorgar esta propiedad es dplyr::group_by() en donde sus parámetros indican que variables servirán para crear los grupos de acuerdo a los diferentes valores de esas variables. Por ejemplo, véase que es natural pensar que en los datos de la población ya vistos se tomen resúmenes por la variable Rango_edad. Population_FEntity %&gt;% group_by(Rango_edad) # A tibble: 448 x 4 # Groups: Rango_edad [14] `Entidad Federativa` `Población Total` Rango_edad Población &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 2 Baja California 2856361 0 a 4 268842 3 Baja California Sur 512030 0 a 4 46070 4 Campeche 755703 0 a 4 63034. 5 Coahuila 2501413 0 a 4 244624. 6 Colima 568642 0 a 4 45985 7 Chiapas 4293414 0 a 4 491525 8 Chihuahua 3241513 0 a 4 253834. 9 Distrito Federal 8737172 0 a 4 682914. 10 Durango 1509025 0 a 4 150485 # … with 438 more rows A simple vista no se ve algún cambio, pero internamente ya se tiene más estructura a dicha base de datos, ahora existe un atributo llamado “groups”. str(Population_FEntity %&gt;% group_by(Rango_edad)) tibble [448 × 4] (S3: grouped_df/tbl_df/tbl/data.frame) $ Entidad Federativa: chr [1:448] &quot;Aguascalientes&quot; &quot;Baja California&quot; &quot;Baja California Sur&quot; &quot;Campeche&quot; ... $ Población Total : num [1:448] 1066233 2856361 512030 755703 2501413 ... $ Rango_edad : chr [1:448] &quot;0 a 4&quot; &quot;0 a 4&quot; &quot;0 a 4&quot; &quot;0 a 4&quot; ... $ Población : num [1:448] 109853 268842 46070 63034 244624 ... - attr(*, &quot;groups&quot;)= tibble [14 × 2] (S3: tbl_df/tbl/data.frame) ..$ Rango_edad: chr [1:14] &quot;0 a 4&quot; &quot;10 a 14&quot; &quot;15 a 19&quot; &quot;20 a 24&quot; ... ..$ .rows : list&lt;int&gt; [1:14] .. ..$ : int [1:32] 1 2 3 4 5 6 7 8 9 10 ... .. ..$ : int [1:32] 65 66 67 68 69 70 71 72 73 74 ... .. ..$ : int [1:32] 97 98 99 100 101 102 103 104 105 106 ... .. ..$ : int [1:32] 129 130 131 132 133 134 135 136 137 138 ... .. ..$ : int [1:32] 161 162 163 164 165 166 167 168 169 170 ... .. ..$ : int [1:32] 193 194 195 196 197 198 199 200 201 202 ... .. ..$ : int [1:32] 225 226 227 228 229 230 231 232 233 234 ... .. ..$ : int [1:32] 257 258 259 260 261 262 263 264 265 266 ... .. ..$ : int [1:32] 289 290 291 292 293 294 295 296 297 298 ... .. ..$ : int [1:32] 33 34 35 36 37 38 39 40 41 42 ... .. ..$ : int [1:32] 321 322 323 324 325 326 327 328 329 330 ... .. ..$ : int [1:32] 353 354 355 356 357 358 359 360 361 362 ... .. ..$ : int [1:32] 385 386 387 388 389 390 391 392 393 394 ... .. ..$ : int [1:32] 417 418 419 420 421 422 423 424 425 426 ... .. ..@ ptype: int(0) ..- attr(*, &quot;.drop&quot;)= logi TRUE Entonces, al aplicar funciones con mutate, estas se harán por grupos. Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% mutate(&quot;Población Mínima&quot; = min(Población), &quot;Población Máxima&quot; = max(Población)) # A tibble: 448 x 6 # Groups: Rango_edad [14] `Entidad Federa… `Población Tota… Rango_edad Población `Población Míni… &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 45985 2 Baja California 2856361 0 a 4 268842 45985 3 Baja California… 512030 0 a 4 46070 45985 4 Campeche 755703 0 a 4 63034. 45985 5 Coahuila 2501413 0 a 4 244624. 45985 6 Colima 568642 0 a 4 45985 45985 7 Chiapas 4293414 0 a 4 491525 45985 8 Chihuahua 3241513 0 a 4 253834. 45985 9 Distrito Federal 8737172 0 a 4 682914. 45985 10 Durango 1509025 0 a 4 150485 45985 # … with 438 more rows, and 1 more variable: `Población Máxima` &lt;dbl&gt; Igual se puede agrupar por distintas variables Population_FEntity %&gt;% mutate(division = rep(c(rep(1,16),rep(2,16)), 14)) %&gt;% group_by(Rango_edad, division) %&gt;% mutate(index = row_number()) %&gt;% select(`Entidad Federativa`, Rango_edad, division, index) # A tibble: 448 x 4 # Groups: Rango_edad, division [28] `Entidad Federativa` Rango_edad division index &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 Aguascalientes 0 a 4 1 1 2 Baja California 0 a 4 1 2 3 Baja California Sur 0 a 4 1 3 4 Campeche 0 a 4 1 4 5 Coahuila 0 a 4 1 5 6 Colima 0 a 4 1 6 7 Chiapas 0 a 4 1 7 8 Chihuahua 0 a 4 1 8 9 Distrito Federal 0 a 4 1 9 10 Durango 0 a 4 1 10 # … with 438 more rows Algo interesante que se puede hacer con datos agrupados es el uso de funciones para resumir información, tales como dplyr::first(), dplyr::min(), dplyr::n(), dplyr::n_distinct() y dplyr::mean(); estas funciones también se pueden usar sin datos agrupados. Véase los siguientes ejemplos Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% summarise(min(Población)) # A tibble: 14 x 2 Rango_edad `min(Población)` &lt;chr&gt; &lt;dbl&gt; 1 0 a 4 45985 2 10 a 14 51549 3 15 a 19 55391 4 20 a 24 44808 5 25 a 29 37723 6 30 a 34 35922. 7 35 a 39 41890 8 40 a 44 37496. 9 45 a 49 30294 10 5 a 9 43193. 11 50 a 54 22129. 12 55 a 59 23534 13 60 y más 34364 14 NE 0 Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% summarise(last(Población)) # A tibble: 14 x 2 Rango_edad `last(Población)` &lt;chr&gt; &lt;dbl&gt; 1 0 a 4 127635. 2 10 a 14 165710 3 15 a 19 143317 4 20 a 24 108938 5 25 a 29 94536. 6 30 a 34 97108 7 35 a 39 92482. 8 40 a 44 85895 9 45 a 49 72674 10 5 a 9 152801 11 50 a 54 49238 12 55 a 59 53257 13 60 y más 123730 14 NE 1067. Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% summarise(&quot;Población promedio&quot; = mean(Población)) # A tibble: 14 x 2 Rango_edad `Población promedio` &lt;chr&gt; &lt;dbl&gt; 1 0 a 4 301178. 2 10 a 14 361577. 3 15 a 19 326600. 4 20 a 24 269529. 5 25 a 29 237230. 6 30 a 34 244256 7 35 a 39 225481. 8 40 a 44 197310. 9 45 a 49 169798. 10 5 a 9 336668. 11 50 a 54 130510. 12 55 a 59 127968. 13 60 y más 302126. 14 NE 4088. Otras funciones que ofrece dplyr para resumir información son dplyr::summarise_each() y dplyr::count(). La primera aplica la función resumen a cada una de las columnas y la segunda cuenta el número de valores únicos con o sin un peso establecido. Population_FEntity %&gt;% count() # A tibble: 1 x 1 n &lt;int&gt; 1 448 Para eliminar esta propiedad a los datos se utiliza la función dplyr::ungroup() y así la manipulación de datos continuará sin eliminar los resultados ya obtenidos. "],
["dplyrrename.html", "6.6 dplyr::rename", " 6.6 dplyr::rename Antes de pasar a las funciones de dplyr especializadas en las operaciones de conjuntos con bases de datos,se verá la función dplyr::rename() la cual, como indica su nombre, da un nuevo nombre a una variable existente. Population_FEntity %&gt;% rename(State = `Entidad Federativa`) # A tibble: 448 x 4 State `Población Total` Rango_edad Población &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 2 Baja California 2856361 0 a 4 268842 3 Baja California Sur 512030 0 a 4 46070 4 Campeche 755703 0 a 4 63034. 5 Coahuila 2501413 0 a 4 244624. 6 Colima 568642 0 a 4 45985 7 Chiapas 4293414 0 a 4 491525 8 Chihuahua 3241513 0 a 4 253834. 9 Distrito Federal 8737172 0 a 4 682914. 10 Durango 1509025 0 a 4 150485 # … with 438 more rows Lo cual se pudo haber hecho con mutate() y select() Population_FEntity %&gt;% mutate (State = `Entidad Federativa`) %&gt;% select(-`Entidad Federativa`) # A tibble: 448 x 4 `Población Total` Rango_edad Población State &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 1066233 0 a 4 109853 Aguascalientes 2 2856361 0 a 4 268842 Baja California 3 512030 0 a 4 46070 Baja California Sur 4 755703 0 a 4 63034. Campeche 5 2501413 0 a 4 244624. Coahuila 6 568642 0 a 4 45985 Colima 7 4293414 0 a 4 491525 Chiapas 8 3241513 0 a 4 253834. Chihuahua 9 8737172 0 a 4 682914. Distrito Federal 10 1509025 0 a 4 150485 Durango # … with 438 more rows "],
["joins-y-set-operations.html", "6.7 Joins y Set Operations", " 6.7 Joins y Set Operations Anteriormente ya se había mencionado la unión entre matrices, por renglón o columna y de la función base::merge(), las cuales tienen su optimización por parte de dplyr. Por parte de las funciones que unen registros o variables, se tienen las funciones dplyr::bind_rows() y bind_cols(). Las mismas reglas que cbind() y rbind() se deben respetar. set.seed(20) x &lt;- tibble(One_Two = sample(1:2, size = 5, replace = T), Three_Four= sample(3:4, size = 5, replace = T), Five_Six = sample(5:6, size = 5, replace = T)) y &lt;- tibble(One_Two = rep(2, 3), Three_Four = rep(4, 3), Five_Six = rep(5, 3)) bind_rows(x,y) # A tibble: 8 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 3 5 2 1 4 5 3 1 3 5 4 2 4 5 5 2 4 5 6 2 4 5 7 2 4 5 8 2 4 5 z &lt;- tibble(One_Eigth = 1:8) bind_cols(bind_rows(x,y), z) # A tibble: 8 x 4 One_Two Three_Four Five_Six One_Eigth &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; 1 2 3 5 1 2 1 4 5 2 3 1 3 5 3 4 2 4 5 4 5 2 4 5 5 6 2 4 5 6 7 2 4 5 7 8 2 4 5 8 Respecto a las operaciones de conjuntos se tienen las funciones dplyr::interset(), dplyr::union y dplyr::setdiff(). intersect(x, y) # A tibble: 1 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 4 5 union(x, y) # A tibble: 4 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 3 5 2 1 4 5 3 1 3 5 4 2 4 5 setdiff(x, y) # A tibble: 3 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 3 5 2 1 4 5 3 1 3 5 Las operaciones tipo Join son muy importantes en la extracción de información en bases de datos, dplyr por su cuenta tiene varias funciones para trabajar. dplyr::left_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x tomando la preferencia sobre a. dplyr::rigth_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x tomando la preferencia sobre b. dplyr::inner_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x considerando a y b. dplyr::full_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x sin ninguna preferencia, por lo que contiene todos los datos posibles. Para ver más claro esto, véase los siguientes ejemplos. set.seed(20) a &lt;- tibble(L = sample(LETTERS[1:5], size = 5, replace = T), N = sample(1:100, size = 5, replace = T)) b &lt;- tibble(L = sample(LETTERS[1:5], size = 5, replace = T), Lo = sample(c(T, F), size = 5, replace = T)) a # A tibble: 5 x 2 L N &lt;chr&gt; &lt;int&gt; 1 C 94 2 B 62 3 A 45 4 B 41 5 E 67 b # A tibble: 5 x 2 L Lo &lt;chr&gt; &lt;lgl&gt; 1 E TRUE 2 A TRUE 3 E TRUE 4 B TRUE 5 D FALSE left_join(a, b, by = &quot;L&quot;) # A tibble: 6 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 C 94 NA 2 B 62 TRUE 3 A 45 TRUE 4 B 41 TRUE 5 E 67 TRUE 6 E 67 TRUE right_join(a, b, by = &quot;L&quot;) # A tibble: 6 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 B 62 TRUE 2 A 45 TRUE 3 B 41 TRUE 4 E 67 TRUE 5 E 67 TRUE 6 D NA FALSE inner_join(a, b, by = &quot;L&quot;) # A tibble: 5 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 B 62 TRUE 2 A 45 TRUE 3 B 41 TRUE 4 E 67 TRUE 5 E 67 TRUE full_join(a, b, by = &quot;L&quot;) # A tibble: 7 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 C 94 NA 2 B 62 TRUE 3 A 45 TRUE 4 B 41 TRUE 5 E 67 TRUE 6 E 67 TRUE 7 D NA FALSE Y un ejemplo práctico: Tomando la base de datos de la población mexicana, se puede obtener los datos para los hombres y mujeres y modificarlos para que tengan un estructura similar a Population_FEntity. normalization &lt;- function(data){ colnames(data) &lt;- c(&quot;Entidad Federativa&quot;, &quot;Población Total&quot;, unique(Population_FEntity$Rango_edad)) data &lt;- data %&gt;% gather(key = &quot;Rango_edad&quot;, value = &quot;Porcentaje&quot;, -c(&quot;Entidad Federativa&quot;, &quot;Población Total&quot;)) %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Población&quot; = Porcentaje * `Población Total`) %&gt;% select(-Porcentaje, -`Población Total`) } Population_FEntity_M &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B43:Q74&quot;, col_names = F) (Population_FEntity_M &lt;- normalization(Population_FEntity_M)) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad Población &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 51587. 2 Baja California 0 a 4 124995. 3 Baja California Sur 0 a 4 22289. 4 Campeche 0 a 4 37749. 5 Coahuila 0 a 4 104304. 6 Colima 0 a 4 34496. 7 Chiapas 0 a 4 170085. 8 Chihuahua 0 a 4 122434. 9 Distrito Federal 0 a 4 462096. 10 Durango 0 a 4 76977. # … with 438 more rows Population_FEntity_F &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B79:Q110&quot;, col_names = F) (Population_FEntity_F &lt;- normalization(Population_FEntity_F)) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad Población &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 56336 2 Baja California 0 a 4 127107. 3 Baja California Sur 0 a 4 22569 4 Campeche 0 a 4 32170 5 Coahuila 0 a 4 115765 6 Colima 0 a 4 23751. 7 Chiapas 0 a 4 227851 8 Chihuahua 0 a 4 122055 9 Distrito Federal 0 a 4 366480 10 Durango 0 a 4 68470 # … with 438 more rows Así es fácil crear un sólo conjunto de datos donde se reúna toda la información relevante Population_FEntity &lt;- Population_FEntity %&gt;% select(-`Población Total`) Population_FEntityWS &lt;- left_join(Population_FEntity, Population_FEntity_M, by = c(&quot;Entidad Federativa&quot;, &quot;Rango_edad&quot;)) (Population_FEntityWS &lt;- left_join(Population_FEntityWS, Population_FEntity_F, by = c(&quot;Entidad Federativa&quot;, &quot;Rango_edad&quot;)) %&gt;% rename( &quot;Población Total&quot; = &quot;Población.x&quot;, &quot;PoblaciónM&quot; = &quot;Población.y&quot;, &quot;PoblaciónF&quot; = &quot;Población&quot;)) # A tibble: 448 x 5 `Entidad Federativa` Rango_edad `Población Total` PoblaciónM PoblaciónF &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 109853 51587. 56336 2 Baja California 0 a 4 268842 124995. 127107. 3 Baja California Sur 0 a 4 46070 22289. 22569 4 Campeche 0 a 4 63034. 37749. 32170 5 Coahuila 0 a 4 244624. 104304. 115765 6 Colima 0 a 4 45985 34496. 23751. 7 Chiapas 0 a 4 491525 170085. 227851 8 Chihuahua 0 a 4 253834. 122434. 122055 9 Distrito Federal 0 a 4 682914. 462096. 366480 10 Durango 0 a 4 150485 76977. 68470 # … with 438 more rows Por rango de edad ¿Qué sexo predomina en cada población? Population_FEntityWS %&gt;% mutate(PPredominante = if_else(PoblaciónM&gt;=PoblaciónF, &quot;M&quot;, &quot;F&quot;)) %&gt;% select(`Entidad Federativa`, Rango_edad, PPredominante) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad PPredominante &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Aguascalientes 0 a 4 F 2 Baja California 0 a 4 F 3 Baja California Sur 0 a 4 F 4 Campeche 0 a 4 M 5 Coahuila 0 a 4 F 6 Colima 0 a 4 M 7 Chiapas 0 a 4 F 8 Chihuahua 0 a 4 M 9 Distrito Federal 0 a 4 M 10 Durango 0 a 4 M # … with 438 more rows Por rango de edad ¿Qué sexo predomina y en que estado se encuentra dicho resultado? Population_FEntityWS %&gt;% mutate(SPredominante = if_else(PoblaciónM&gt;=PoblaciónF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, PoblaciónM, PoblaciónF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% select(`Entidad Federativa`, Rango_edad, SPredominante) # A tibble: 14 x 3 # Groups: Rango_edad [14] `Entidad Federativa` Rango_edad SPredominante &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 México 0 a 4 M 2 México 5 a 9 M 3 México 10 a 14 M 4 México 15 a 19 F 5 México 20 a 24 F 6 México 25 a 29 F 7 México 30 a 34 F 8 México 35 a 39 F 9 México 40 a 44 F 10 México 45 a 49 F 11 México 50 a 54 F 12 México 55 a 59 F 13 Distrito Federal 60 y más F 14 México NE M ¿Cuál estado tiene el mayor número de mujeres y cuál el de hombres? Population_by_sex_Mexico &lt;- Population_FEntityWS %&gt;% group_by(`Entidad Federativa`) %&gt;% summarise(SMasculino = sum(PoblaciónM), SFemenino = sum(PoblaciónF)) full_join( Population_by_sex_Mexico %&gt;% arrange(desc(SMasculino)) %&gt;% head(1) %&gt;% select(-SFemenino), Population_by_sex_Mexico %&gt;% arrange(desc(SFemenino)) %&gt;% head(1) %&gt;% select(-SMasculino), by = &quot;Entidad Federativa&quot;) # A tibble: 1 x 3 `Entidad Federativa` SMasculino SFemenino &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 México 6871269. 7305419 ¿Cuál es el rango de edad con mayor población en mujeres y hombres? Population_by_sex_age_Mexico &lt;- Population_FEntityWS %&gt;% group_by(Rango_edad) %&gt;% summarise(PoblaciónF = sum(PoblaciónF), PoblaciónM = sum(PoblaciónM)) full_join( Population_by_sex_age_Mexico %&gt;% arrange(desc(PoblaciónM)) %&gt;% head(1) %&gt;% select(-PoblaciónF), Population_by_sex_age_Mexico %&gt;% arrange(desc(PoblaciónF)) %&gt;% head(1) %&gt;% select(-PoblaciónM), by = &quot;Rango_edad&quot;) # A tibble: 1 x 3 Rango_edad PoblaciónM PoblaciónF &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 10 a 14 5881838. 5790366 Finalmente, algunos puntos extra Recordando los cinco problemas en unos datos sin limpieza, dos que quedaron pendientes Múltiples tipos de observaciones están en la misma tabla. Una sola observación esta en múltiples tablas. En el ejemplo que se ha tomado de la población mexicana tiene el primer defecto, ya que la población total bien podría quedar en una sola tabla junto con el nombre de la entidad y en otra los porcentajes de acuerdo a los rangos de edad. En general en este punto se debe tener en cuenta que cada unidad observacional debe tener su propia tabla, así logrando un técnica en bases de datos llamada normalización. Para este caso, se tendrían dos tablas Population_FEntity &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B5:Q38&quot;, col_names = TRUE) colnames(Population_FEntity)[1:2] &lt;- c(&quot;Entidad Federativa&quot;, &quot;Población Total&quot;) Population_FEntity &lt;- Population_FEntity %&gt;% gather(key = &quot;Rango_edad&quot;, value = &quot;Porcentaje&quot;, -c(&quot;Entidad Federativa&quot;, &quot;Población Total&quot;)) %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Población&quot; = Porcentaje * `Población Total`) (t1 &lt;- Population_FEntity %&gt;% select(`Entidad Federativa`, `Población Total`)) # A tibble: 462 x 2 `Entidad Federativa` `Población Total` &lt;chr&gt; &lt;dbl&gt; 1 República Mexicana 103498524 2 Aguascalientes 1066233 3 Baja California 2856361 4 Baja California Sur 512030 5 Campeche 755703 6 Coahuila 2501413 7 Colima 568642 8 Chiapas 4293414 9 Chihuahua 3241513 10 Distrito Federal 8737172 # … with 452 more rows (t2 &lt;- Population_FEntity %&gt;% select(`Entidad Federativa`, Rango_edad, Población)) # A tibble: 462 x 3 `Entidad Federativa` Rango_edad Población &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 República Mexicana 0 a 4 9637687 2 Aguascalientes 0 a 4 109853 3 Baja California 0 a 4 268842 4 Baja California Sur 0 a 4 46070 5 Campeche 0 a 4 63034. 6 Coahuila 0 a 4 244624. 7 Colima 0 a 4 45985 8 Chiapas 0 a 4 491525 9 Chihuahua 0 a 4 253834. 10 Distrito Federal 0 a 4 682914. # … with 452 more rows Para el último punto se entiende que los datos están dispersos entre distintos conjuntos de datos, por lo que usar las funciones para combinar bases de datos ayudan en la resolución de este problema. Es recomendable estudiar el paquete purrr, el cual es parte del tidyverse y ofrece una versión ideal para trabajar con funciones anónimas en data frames, ya que al tratar de aplicar alguna función de la familia apply con un data frame estos son convertidos primero a una matriz lo cual hace perder muchos de sus atributos. Así, con las funciones de la “familia” purrr::map se pueden hacer todas las aplicaciones que se pueden hacer con alguna de la familia apply e incluso algunas más. Además de que tienen una aplicación ideal con dplyr. Véase Functional Programming. Se pueden usar las librerías dtplyr, dbplyr o sparklyr como interfaz para usar la sintaxis de dplyr en data.tables, bases de datos en SQL o en Apache Spark. Recordar que la función dplyr::near() compara dos elementos numéricos en punto flotante. La función dplyr::case_when() es una versión equivalente a dplyr::if_else() pero más general tibble(x = 1:5) %&gt;% mutate(new_variable = dplyr::case_when(x == 1 ~ &quot;Hola&quot;, x == 5 ~ &quot;Adios&quot;, TRUE ~ as.character(x))) # A tibble: 5 x 2 x new_variable &lt;int&gt; &lt;chr&gt; 1 1 Hola 2 2 2 3 3 3 4 4 4 5 5 Adios dplyr proviene de la paquetería plyr la cual contiene muchas más funciones que pueden ser de utilidad en ciertas ocasiones. Ejercicios Utiliza la función dplyr::top_n(). En la siguiente página se puede aprender sobre el uso de expresiones regulares. Usando las funciones dplyr::select() y dplyr::matches() replica los resultados que se dieron como ejemplo cuando se explico la función dplyr::select(). Crea un data frame o tibble con 5 variables numéricas. Utiliza la función dplyr::mutate_each() para aplicar la función dplyr::percent_rank() en cada una de las variables. Investigar algunas funciones de purrr como reduce(), map() y accumulate(). Investiga el uso de dplyr::semi_join() y dplyr::anti_join(). Si eres meticuloso, verás que algo anda en los datos de la población. ¿Por qué? Hint: Ve la tabla que se uso para los últimos ejemplos de la sección dplyr. Obtén resultados necesarios para contestar las siguientes preguntas sobre la base de datos population que ofrece dplyr. ¿Cuantos años están registrados por país? ¿Qué países tienen mayor población por año? ¿Cuál es la edad promedio, con los años dados, de la población en cada país? ¿Qué países son aquellos que tienen más de un millón de habitantes en algún año? ¿Qué países tienen menos de un millón de habitantes en al menos un año? ¿Que país ha sido el que ha tenido la peor reducción en su población y en que año? ¿Qué país tuvo la mayor cantidad población en el año de tu nacimiento? ¿Cuál fue el año en que cada país tuvo su mayor numero de habitantes? ¿Cuál fue el año en que cada país tuvo su menor numero de habitantes? ¿Cuántos países considera la base de datos? La base de datos who de dplyr contiene la información sobre los reportes de tuberculosis en el mundo. Haz una limpieza en esta base utilizando las funciones de tidyr y obtén la siguiente información. Por país ¿Cuál fue el año con mayor número de enfermos por tuberculosis? Por país ¿Cuál de los tres diagnósticos diferentes tiene una mayor ocurrencia? ¿Cuál fue el año con mayor número de enfermos por país? ¿Qué país ha tenido el mayor número de enfermos por tuberculosis? ¿Cuál es el top-10 de países con mayor número de casos con tuberculosis? ¿Hay algún país sin casos de tuberculosis en los años registrados? ¿Cuál sexo es el más afectado, por país, con tuberculosis? ¿Cuál es el rango de edad con mayor número de casos con tuberculosis? ¿Cuál es el rango de edad con menor número de casos con tuberculosis? Por rango de edad ¿Qué sexo es el más afectado con tuberculosis? Las bases de datos who y population están relacionadas, por lo que se pueden unir para responder lo siguiente: ¿Existen países en los que el año donde se tuvo el máximo número de enfermos por tuberculosis sean los años donde se obtuvo un gran descenso en la población? La base de datos storms proporcionada por dplyr contiene la información acerca de 198 tormentas tropicales con diferentes atributos. Obtén la siguiente información. ¿Cuántos huracanes tuvieron las tres clasificaciones (Depresión Tropical, Tormenta Tropical y Huracán)? ¿Cuál año fue el que tuvo el mayor número de huracanes? ¿Cuál año fue el que tuvo el mayor número de Tormentas Tropicales? ¿Cuál es el mes con mayor actividad? ¿Qué tormenta ha sido la que tuvo mayor número de cambios en su categoría Saffir-Simpson? ¿Cuál ha sido la tormenta con mayor velocidad promedio del viento en nudos? ¿Por tormenta, cuál ha sido la velocidad máxima que alcanzo en \\(k/h\\)? Considerando que una tormenta se puede clasificar por el estatus que predomina en ella, ¿Qué tipo de tormenta es la más recurrente en el Atlántico? ¿Cuál ha sido la tormenta con mayor duración? Considerando latitud y longitud en términos enteros (pensando así en segmentos del territorio), ¿Cuál ha sido la ubicación donde se ha tenido la mayor cantidad de tormentas? Utiliza las funciones Join que proporciona dplyr con las bases de datos dplyr::band_instruments y dplyr::and_members. "],
["graficación-de-datos-ggplot.html", "Capítulo 7 Graficación de datos: Ggplot", " Capítulo 7 Graficación de datos: Ggplot Finalmente, uno de los paquetes más famosos del tidyverse es ggplot, el cual esta diseñada para representar la información obtenida de los datos mediante gráficas con un excelente control de todos los elementos gráficos tratados como objetos. Dicha paquetería está basada en el libro The Grammar of Graphics de Leland Wilkinson. Como siempre, una de las mejores fuentes rápidas para recordar alguna función o característica de ellas, es la Cheat Sheet oficial, aunque hay una enorme cantidad de ejemplos y tutoriales para esta paquetería. A criterio personal recomendaría los siguientes enlaces para estudiar más a fondo todo lo relacionado con este gran mundo que aún sigue en crecimiento. ggplot2: Elegant Graphics for Data Analysis de Handley Wickham. R Graphics Cookbook: Practical Recipes for Visualizing Data de Winston Chang. R for Data Science de Hadley Wickham. A ggplot2 Tutorial for Beautiful Plotting in R. Be Awesome in ggplot2: A Practical Guide to be Highly Effective - R software and data visualization. An Introduction to Ggplot2. Independientemente de la gráfica que se esté realizando, la idea básica en ggplot para construir una gráfica es mediante el uso de capas. Algunos que tengan experiencia en programas diseñados para la creación de imágenes entenderán que el uso de capas otorga un mayor control sobre los elementos gráficos del resultado final. Mediante cada capa se agregan elementos gráficos que proporcionan algún tipo de atributo extra a toda la imagen. Se comenzará siempre con la capa donde se adjuntarán las capas restantes. Para este ejemplo se tomará la base de datos que ya se ha estado utilizando en las anteriores secciones con el objetivo de crear una gráfica donde se represente el comportamiento de la población total a medida que avanza el rango de edad. Population_total_range &lt;- Population_FEntityWS %&gt;% mutate(Rango_edad = factor(Rango_edad, levels = unique(Rango_edad))) %&gt;% group_by(Rango_edad) %&gt;% summarise(Y = sum(`Población Total`)) ggplot(Population_total_range) Esta primera capa se puede pensar como la hoja o la superficie donde se comenzaría a realizar un dibujo. En la bibliografía que se menciono al inicio se puede encontrar más información sobre el comportamiento interno de ggplot, por ahora es bueno saber que la función ggplot y sus subsecuentes toman los datos y aplican transformaciones para traducir dicho contenido en información que pueda ser utilizada para la determinación de colores, geometrías, escalas y hasta espacio geométrico. Algo que hay que tomar en cuenta al hacer una gráfica con ggplot es el uso del operador +, el cual tendrá una función similar a %&gt;%. Con este se añadirá una capa más a toda la gráfica con la que ya se estaba trabajando. Population_total_range %&gt;% ggplot() + aes(x=Rango_edad, y=Y) En esta segunda capa se estableció mediante la función aes() aquellas variables que servirán como ejes para mapear la información. Dicha función se puede modificar en cada capa y puede ser un parámetro en la mayoría de funciones de ggplot. Ahora, sólo falta agregar los elementos gráficos para representar las observaciones dadas, es decir la geometría. Population_total_range %&gt;% ggplot(aes(x=Rango_edad, y=Y)) + geom_point() ¡Así de fácil se obtiene ya la gráfica! Faltan aplicar algunos detalles como el diseño de esta, lo cual sería añadiendo más capas. Véase que en las siguientes instrucciones la gráfica se guardo como un objeto el cual puede ser usado más adelante. graph_population &lt;- Population_total_range %&gt;% ggplot(aes(x=Rango_edad, y=Y)) + geom_point() (graph_population_per &lt;- graph_population + theme(axis.line = element_line(linetype = &quot;solid&quot;), axis.ticks = element_line(colour = &quot;gray0&quot;), panel.grid.major = element_line(colour = &quot;gray25&quot;), panel.grid.minor = element_line(colour = &quot;gray25&quot;), axis.title = element_text(colour = &quot;gray93&quot;), axis.text = element_text(colour = &quot;gray82&quot;), plot.title = element_text(colour = &quot;gray90&quot;), panel.background = element_rect(fill = &quot;gray33&quot;, size = 1.5, linetype = &quot;dashed&quot;), plot.background = element_rect(fill = &quot;gray21&quot;, colour = &quot;gray0&quot;, size = 1.6, linetype = &quot;solid&quot;))) Cada uno de los comandos anteriores son dados para cambiar solo el diseño, bien pudo hacerse todo en capas individuales con la función theme() o, como en este caso, englobar todo el diseño en una capa. Existen muchos elementos que se pueden cambiar y lo más recomendable es ver la documentación oficial de la función theme desde la página Modify components of a theme, la cual contiene ejemplos muy útiles. Dando más diseño con más capas se puede mejorar mucho la presentación de esta, ya que aún la propia gráfica en si misma no proporciona mucha información para alguien que no tenga conocimiento de la información con la que se esta trabajando. Es decir que falta agregar títulos, nombres informativos en los ejes, una mejor distribución de las etiquetas en los ejes y algunos atributos extra que ayuda en la interpretación y obtención visual más rápida de la información. (graph_population_per &lt;- graph_population_per + geom_point(color = &quot;white&quot;) + #Esta instrucción pudo colocarse la primera vez de su uso labs(x = &quot;Rango de edad&quot;, y = &quot;Población total&quot;, caption = &quot;Datos obtenidos de los tabulados básicos de la CONAPO (2020)&quot;)+ ggtitle(&quot;Población total de México por rangos de edad quinquenales en el 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7))) En la siguiente página: Ggplot title, Subtitle and caption, se puede ver un poco sobre la manipulación de títulos, subtitulos y captions. Tal vez sea tedioso estar modificando manualmente cada aspecto estético de la gráfica, por lo que se han dado algunos temas predefinidos para hacer de dicha tarea algo sencillo, estos se pueden obtener con el prefijo theme_; aquí se dejan un par de ejemplos. library(patchwork) (graph_population+ labs(x = &quot;Rango de edad&quot;, y = &quot;Población total&quot;, caption = &quot;Datos obtenidos de los tabulados básicos de la CONAPO (2020)&quot;)+ ggtitle(&quot;Población total de México por rangos de edad quinquenales en el 2020&quot;)+ scale_y_continuous(labels = scales::comma) + theme_minimal())+(graph_population+ labs(x = &quot;Rango de edad&quot;, y = &quot;Población total&quot;, caption = &quot;Datos obtenidos de los tabulados básicos de la CONAPO (2020)&quot;)+ ggtitle(&quot;Población total de México por rangos de edad quinquenales en el 2020&quot;)+ scale_y_continuous(labels = scales::comma) + theme_classic()) Lo anterior solo fue un ejemplo de como usar el paquete patchwork, el cual se menciona más adelante en una lista de paquetes útiles, por lo que no se toma en cuenta la mal distribución que se consiguió en los ejes de las gráficas anteriores. Las siguientes gráficas muestran un poco más de todas las geometrías que incluye ggplot, sin importar por el momento el diseño de dichas gráficas. (Population_total_range %&gt;% ggplot(aes(x = Rango_edad, y = Y))+geom_bar(stat = &quot;identity&quot;))+ (Population_by_sex_age_Mexico %&gt;% ggplot(aes(x = PoblaciónF))+geom_boxplot())+ (Population_by_sex_age_Mexico %&gt;% ggplot(aes(x = PoblaciónM))+geom_density()) Además de poder asignar las variables a los ejes, también se pueden usar las variables como atributos estéticos para las gráficas. Véase en el siguiente ejemplo el uso de la variable Entidad Federativa para agregar color a las barras en el siguiente gráfico de barras. .scroll-300 { max-height: 300px; } #Por rango de edad ¿Qué sexo predomina y en que estado se encuentra dicho resultado? Population_FEntityWS %&gt;% mutate(SPredominante = if_else(PoblaciónM&gt;=PoblaciónF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, PoblaciónM, PoblaciónF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% ggplot(aes(x = Rango_edad, y = `Población Total`, fill = `Entidad Federativa`))+ geom_bar(stat = &quot;identity&quot;)+ labs(x = &quot;Rango de edad&quot;, y = &quot;Población total&quot;)+ ggtitle(&quot;Población total por rangos de edad quinquenales \\n del sexo dominante en México 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7)) Bien se podría hacer más patriótica la gráfica anterior. Population_FEntityWS %&gt;% mutate(SPredominante = if_else(PoblaciónM&gt;=PoblaciónF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, PoblaciónM, PoblaciónF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% ggplot(aes(x = Rango_edad, y = `Población Total`, fill = `Entidad Federativa`, color = SPredominante))+ geom_bar(stat = &quot;identity&quot;)+ labs(x = &quot;Rango de edad&quot;, y = &quot;Población total&quot;, fill = &quot;Entidad Federativa: &quot;, color = &quot;Sexo Predominante: &quot;)+ ggtitle(&quot;Población total por rangos de edad quinquenales \\n del sexo dominante en México 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7), legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot;, panel.grid.major = element_line(linetype = &quot;blank&quot;), panel.background = element_rect(fill = &quot;gray93&quot;))+ scale_fill_manual(values = c(&quot;#CE0626&quot;,&quot;#2C6846&quot;))+ scale_color_manual(values = c(&quot;dimgrey&quot;, &quot;black&quot;)) Además se pueden usar múltiples geometrías en una gráfica. La gráfica siguiente es un gráfico de dispersión de la longitud de los sépalos contra el ancho de los sépalos en la base de datos iris agregando un poco de ruido (se agrega un poco de variación aleatoria a las ubicaciones) junto con un ajuste polinómico a los datos originales. iris %&gt;% ggplot(aes(x = Sepal.Length, y =Petal.Width))+ geom_point()+ geom_smooth()+ geom_jitter() Hay muchas más otras funciones y geometrías que se podrían explorar y que haría de este sección muy larga. Para resumir un poco, se deja una lista de paquetes y funciones que pueden ser de utilidad a la hora de graficar y que han ampliado de gran manera todo el universo de ggplot para hacerlo una de las herramientas principales para crear contenido visual a partir de una análisis de datos. Graficación interactiva Highcharter Plotly library(plotly) graph_example_interactive &lt;- Population_FEntityWS %&gt;% mutate(SPredominante = if_else(PoblaciónM&gt;=PoblaciónF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, PoblaciónM, PoblaciónF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% ggplot(aes(x = Rango_edad, y = `Población Total`, fill = `Entidad Federativa`, color = SPredominante))+ geom_bar(stat = &quot;identity&quot;)+ labs(x = &quot;Rango de edad&quot;, y = &quot;Población total&quot;, fill = &quot;Entidad Federativa: &quot;, color = &quot;Sexo Predominante: &quot;)+ ggtitle(&quot;Población total por rangos de edad quinquenales \\n del sexo dominante en México 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7), legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot;, panel.grid.major = element_line(linetype = &quot;blank&quot;), panel.background = element_rect(fill = &quot;gray93&quot;))+ scale_fill_manual(values = c(&quot;#CE0626&quot;,&quot;#2C6846&quot;))+ scale_color_manual(values = c(&quot;dimgrey&quot;, &quot;black&quot;)) ggplotly(graph_example_interactive) ggplotly(graph_population_per) 3D Aquí un ejemplo en 3D usando Plotly. rayshader. Scatterplot3d. library(&quot;scatterplot3d&quot;) scatterplot3d(iris[,1:3]) Animación animation. transformr. tweenr. gganimate. El el siguiente enlace se pueden ver algunas variaciones del siguiente ejemplo. library(gganimate) library(gapminder) #Para obtener la base de datos gapminder: Extracto de los datos de Gapminder sobre esperanza de vida, PIB per cápita y población por país. ggplot( gapminder, aes(x = gdpPercap, y=lifeExp, size = pop, colour = country) ) + geom_point(show.legend = FALSE, alpha = 0.7) + scale_color_viridis_d() + scale_size(range = c(2, 12)) + scale_x_log10() + labs(x = &quot;GDP per capita&quot;, y = &quot;Life expectancy&quot;) + transition_time(year) + labs(title = &quot;Year: {frame_time}&quot;) Colores futurevisions. wesanderson. Emoji Emoji. Otras librerías muy útiles. ggforce. cowplot. ggproto. patchwork. Faltarían muchos otros tipos de gráficas y referencias que hacer, pero una de las mejores formas de obtener más ejemplos son con galerías, algunas son las siguientes the R Graph Gallery. htmlwidgets for R - gallery. Twitter Ejercicios Investiga el uso de la función ggplot2::qplot(). ¿Qué sucede en el primer ejemplo de la sección ggplot si los datos que sirvieron para el parámetro data de dicha función fueran los siguientes: Population_total_range&lt;-Population_FEntityWS %&gt;% group_by(Rango_edad) %&gt;% summarise(Y = sum(Población Total))? Usar la función ggplot2::facet_grid() para graficar, por los cinco principales estados (los de mayor población), un gráfico de barras donde se vea la distribución por rangos quinquenales de edad de su población. Utiliza la función ggplot2::scale_function() para gráficar la función normal en el rango (-5,5). Utiliza la función latex2exp::TeX() para agregar la ecuación de la función normal en la gráfica anterior. "],
["introducción.html", "Capítulo 8 Introducción", " Capítulo 8 Introducción No sólo basta saber crear el contenido, también es muy importante si dicho material realmente comunica lo que se desea. En esta sección se revisaran algunos de los puntos más importantes sobre la forma en que se presenta la información para que el mensaje que se quiere transmitir con ellos sea comunicado mas eficientemente. Los datos, pueden ser duros es decir los datos originales o resúmenes de estos. En los resúmenes podemos tener frecuencias acumuladas, porcentajes, tablas, gráficos entre otros. Hay 4 conceptos a tener en cuenta cuando se presentan datos, estos deben ser: Correctos. Todos los datos presentados deben ser verificados previo a cualquier difusión de información Claros. Se debe tener claro el mensaje que se quiere dar con los datos y la presentación de la información debe transmitir claramente este mensaje. Concisos. La presentación debe tener sólo la información necesaria para transmitir el mensaje. Consistentes. La información debe ser consistente en la unidades usadas, asi como abreviaciones y uso de decimales. "],
["manejo-de-números.html", "Capítulo 9 Manejo de números", " Capítulo 9 Manejo de números Uno de los elementos a cuidar en la presentación de datos estadísticos es el manejo de los números. Uso de separador de miles. 128456 vs 128,456 o 128 456 Uso de separador decimal. (consistencia) 66.6, 56.7, 34,7 Nivel de comparación. (usar mismas unidades) Presupuesto de secretaria de salud es de 11,048 millones de pesos, representa un incremento de 563 mil pesos (\\(5.4\\%\\)) respecto al año pasado. El presupuesto de secretaria de salud aumento 0.6 millones (\\(5\\%\\)) siendo 11.0 millones. Justificación de los datos. Usar la misma tipografia, tamaño y número de dígitos. Justificar a la derecha cuando los datos se ponen en columnas, para alinear las unidades. Redondeo. Redondear los datos para que sean comparables al mismo nivel. Redondear para hacerlo memorable y más fácil de comunicar (14,245 a 14,000). "],
["tablas.html", "Capítulo 10 Tablas", " Capítulo 10 Tablas Posicionar los totales por renglón en una última columna, y los totales por columna en un último renglón. Los títulos deben ser reducidos. Centrar los encabezados de las columnas. Cuando la tabla tenga mas de 5 renglones, agregar espaciado cada 5 renglones (es más fácil leer en bloques) Marcar la fuente de donde se tomaron los datos. Datos temporales se ordenan cronológicamente de arriba a abajo o dercha a izquierda. "],
["tabla-de-resumen.html", "10.1 Tabla de resumen", " 10.1 Tabla de resumen Al realizar una tabla que resume datos es buena idea considerar el mesaje que se quiere transmitir así como la audiencia a la que va dirigida. Para ello las siguiente preguntas son útiles. ¿Qué números de la tabla se quiere que el lector compare? ¿Cuántos números son necesarios para transmitir el mensaje? ¿Qué tanto detalle es necesario? ¿Se puede agregar información derivada para ayudar a transmitir el mensaje? ¿Deben estar los datos presentados en algún orden? Ejemplo De una base de datos en donde se registra la exportación díaria de aguacate de los diferentes productores del país, se busca conocer la distribución de las exportaciones por estado de la república en 2019. El siguiente ejemplo presenta la salida en R de un agrupamiento por estado del total de kilogramos exportados durante 2019. Estado Volumen (Kgs) Porcentaje JALISCO 417729.8 52.12 MICHOACAN 286298.8 35.72 GUANAJUATO 96916.3 12.09 MORELOS 600 0.07 Una mejor presentación de estos datos, siguiendo las recomendaciones es: Estado Volumen (Kgs) Porcentaje JALISCO 417,730 52% MICHOACAN 286,299 36% GUANAJUATO 96,916 12% "],
["gráficos.html", "Capítulo 11 Gráficos", " Capítulo 11 Gráficos Cuando se usan gráficos por lo general se busca la comprensión de los datos sólo con el objeto visual sin ayuda de ejes, pies de página o información adicional. Al igual que con las tablas, antes de realizar un gráfico se debe tener claro el mensaje que se desea transmitir. Puntos a considerar: Acomodar los datos para maximizar el uso de texto en forma horizontal. Seleccionar el tipo de gráfico correcto según los datos y el mensaje a transmitir. Evitar colores fuertes primarios (son dominantes para el cebrebro). Cuando se grafican números, siempre empezar el eje “y” en cero. Usar la misma escala en gráficos que serán comparados. Considerar tranformar datos en diferentes escalas antes de graficarlos. Asegurarse que las escalas tengan el formato apropiado. (Redondeo, decimales, etc) Sólo usar gráficos en dos dimensiones para datos bidimensionales. "],
["gráfico-circular.html", "11.1 Gráfico circular", " 11.1 Gráfico circular En particular para los gráficos circulares se recomienda: Asegurarse que los porcentajes sumen \\(100\\%\\) Iniciar con el primer segmento a las 12 del día e ir llenando en sentido de las manecillas del reloj. Cuando se pueda, ordenar los segmentos por tamaño de mayor a menor. Evitar pies de mas de 6 segmentos. Usar tonos del mismo color para identificar proporciones de una variable. Ejemplo Usando los mismos datos de exportación díaria de aguacate. Realizaremos una representación gráfica del volumen de exportación de aguacate observada en 2019 para cada país destino. library(ggplot2) paises &lt;- c(&quot;MYANMAR (BIRMANIA)&quot;,&quot;BANGLADESH&quot;,&quot;HONG KONG&quot;,&quot;JAPON&quot;,&quot;ARABIA SAUDITA&quot;, &quot;EMIRATOS ÁRABES UNIDOS&quot;, &quot;REINO UNIDO&quot;, &quot;PAÍSES BAJOS (HOLANDA)&quot;, &quot;SINGAPUR&quot;,&quot;ESTADOS UNIDOS&quot;) vol &lt;- c(304734.62, 125240.00, 74578.50, 68925.24,55285.20,51517.44, 43760.00, 32092.50, 29610.00, 11481.36) D1 &lt;- data.frame(paises,vol) ggplot(D1, aes(x = paises, y = vol)) + labs(x=&quot;Paises de Destino&quot;, y=&quot;Volumen en Kg&quot;, title=&quot;Volumen de exportación de aguacate por pais de destino en 2019&quot;)+ geom_bar(stat = &quot;identity&quot;,fill=&quot;#f68060&quot;)+ theme(axis.text.x = element_text(angle = 90)) + scale_y_continuous(labels = scales::number) Y también presentaremos gráficamente la tabla de producción de aguacate por estado de la república que presentamos en la sección de tablas. edo &lt;- c(&quot;JALISCO&quot;,&quot;MICHOACAN&quot;,&quot;GUANAJUATO&quot;) vol &lt;- c(&quot;417,730&quot;,&quot;286,299&quot;,&quot;96,916&quot;) por &lt;- c(52,36, 12) D1 &lt;- data.frame(edo,vol,por) ggplot(D1, aes(x=&quot;&quot;, y=por, fill=edo)) + geom_bar(stat=&quot;identity&quot;, width=1,color=&quot;white&quot;) + coord_polar(&quot;y&quot;, start=0)+ theme_void()+ geom_text(aes(label = vol,x = 1), color = &quot;white&quot;, size=4, position = position_stack(vjust = 0.5))+ scale_fill_brewer(palette=&quot;Set2&quot;)+ labs(title=&quot;Producción de aguacate por estado en 2019&quot;) The R Fundation. n.d. “What Is R?” https://www.r-project.org/about.html. Wickham, Hadley. 2019. Advanced R. 2nd ed. CRC press. https://adv-r.hadley.nz. Wickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" O’Reilly Media, Inc.\". https://r4ds.had.co.nz. Wikipedia contributors. 2020. “R (Programming Language) — Wikipedia, the Free Encyclopedia.” https://en.wikipedia.org/w/index.php?title=R_(programming_language)&amp;oldid=978636340. "]
]
