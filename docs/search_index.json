[
["index.html", "Programaci√≥n en R Prefacio", " Programaci√≥n en R Sof√≠a Villers G√≥mez Carlos Fernando V√°squez Guerra David Alberto Mateos Montes de Oca Prefacio Primera edici√≥n del bookdown Programaci√≥n en R para el uso continuo en las materias de Estad√≠stica y sus relacionadas impartidas por los autores, as√≠ como para aquellos estudiantes que deseen adquirir el conocimiento pertinente del lenguaje de programaci√≥n R. Objetivos Otorgar el mayor conocimiento posible del lenguaje de programaci√≥n R a nivel b√°sico-intermedio con el que sea el lector sea capaz de manipular fuentes de informaci√≥n y crear contenido de calidad, que junto al uso del software RStudio, se logren dar soluciones atractivas a problemas que requieran este tipo de herramientas. Como bien se menciono, este material no s√≥lo est√° dirigido a los estudiantes de la Facultad de Ciencias de la Universidad Nacional Aut√≥noma de M√©xico, si no a cualquier lector que desee introducirse y adquirir conocimiento, as√≠ como las habilidades pertinentes, sobre el lenguaje de programaci√≥n R. Estructura Este libro se compone de tres diferentes secciones y a medida que estas son abarcadas, se ver√°n temas generales sobre el lenguaje R y de ciertas librer√≠as especiales dise√±adas para problemas espec√≠ficos, as√≠ como funciones especiales que faciliten ciertas tareas. En la primera de ellas se tendr√° el contenido referente a las caracter√≠sticas y funciones por default el R, sin hacer uso de alg√∫n paquete exterior a √©l. En la siguiente se estudiar√° lo correspondiente al tidyverse para lograr una programaci√≥n m√°s eficiente y adecuada para el an√°lisis de datos. Finalmente, se cubrir√° los conocimientos necesarios para la creaci√≥n de aplicaciones web interactivas gracias al paquete Shiny. De acuerdo a las necesidades del lector, los cap√≠tulos pueden ser estudiados de manera independiente aunque es recomendable tener el conocimiento previo que se tiene en el temario, ya que se puede hacer uso de funciones o conocimiento previo en secciones avanzadas. Gran parte del contenido en este libro esta basado en las publicaciones basicr y EfficientR de Rpubs. Detalles t√©cnicos Este libro fue escrito con bookdown usando RStudio. Esta versi√≥n fue escrita con: Finding R package dependencies ... Done! setting value version R version 3.6.2 (2019-12-12) os macOS Catalina 10.15.6 system x86_64, darwin15.6.0 ui X11 language (EN) collate en_US.UTF-8 ctype en_US.UTF-8 tz America/Mexico_City date 2020-09-18 Licencia This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. This is a human-readable summary of (and not a substitute for) the license. Please see https://creativecommons.org/licenses/by-sa/4.0/legalcode for the full legal text. You are free to: Share‚Äîcopy and redistribute the material in any medium or format Remix‚Äîremix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution‚ÄîYou must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike‚ÄîIf you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions‚ÄîYou may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Notices: You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation. No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material. "],
["introducci√≥n-e-instalaci√≥n.html", "Cap√≠tulo 1 Introducci√≥n e instalaci√≥n", " Cap√≠tulo 1 Introducci√≥n e instalaci√≥n R y RStudio R es un lenguaje de programaci√≥n interpretado dise√±ado para la computaci√≥n estad√≠stica y proporcionar un ambiente gr√°fico. R esta basado en el lenguaje de programaci√≥n estad√≠stico S, el cual fue desarrollado en los laboratorios Bell por John Chambers, Rick Becker y Allan Willks. Este lenguaje llamaba a subrutinas de FORTRAN aunque despu√©s, en 1988, fue reescrito en lenguaje C (Wikipedia contributors 2020). La idea de R naci√≥ en Nueva Zelanda por Ross Ihaka y Robert Gentleman con la intenci√≥n de crear un lenguaje que ayudar√° en la ense√±anza estad√≠stica de la Universidad Nueva Zelanda, esto en 1992, y fue hasta 1995 que se lanzo una primera versi√≥n estable. Ya mediados de 1997 se creo un grupo para modificar el c√≥digo fuente de este lenguaje. La mayor√≠a de las funciones en R est√°n escritas en el propio lenguaje pero, gracias al trabajo de la comunidad, se han hecho muchas implementaciones y procedimientos que est√°n escritos en C, C++ y FORTRAN para lograr una mayor eficiencia en cuanto al tiempo y memoria. A partir de 1995 se decide usar la licencia GNU para que R sea un software libre, es decir, que se puede consultar el c√≥digo fuente, se puede modificar las funciones internas, aunque no es buena idea si no se tiene un conocimiento profundo del lenguaje. R no esta dise√±ado para ser un lenguaje de programaci√≥n r√°pido, si no que su prop√≥sito es hacer un an√°lisis de datos interactivo y f√°cil para humanos. Respecto a RStudio, este es una IDE disponible desde el 2011 que permite trabajar de una manera m√°s fluida con el lenguaje de programaci√≥n R incluyendo una consola donde se puede trabajar de manera directa con el lenguaje, un editor de textos para guardar nuestro c√≥digo, crear Scripts, etc, distintos paneles para visualizar gr√°ficas, navegar en los distintos directorios donde estemos posicionados y un gran conjunto de herramientas que facilitan la integraci√≥n de librer√≠as y la creaci√≥n de documentos de distintas extensiones. En RStudio tambi√©n se puede trabajar con otros lenguajes de programaci√≥n e integrar estos con R, como por ejemplo Python; de hecho, desde el 2019 se tiene soporte para Notebooks de Jupyter. Adem√°s de que, como cualquier IDE, se puede personalizar un poco la interfaz para trabajar m√°s c√≥modamente. Fuentes: RStudio 1.1 Preview - I Only Work in Black; Theme Black. Hay que tener en cuenta los siguientes puntos: Hay una sesi√≥n de R corriendo cuando se est√° en RStudio. La consola de R es la interfaz entre R y el usuario. En la sesi√≥n hay objetos. Todo en R es un objeto: vectores, tablas, funciones, etc. Finalmente: Instala R, a free software environment for statistical computing and graphics desde el CRAN de acuerdo a tu sistema operativo; m√°s adelante se ver√° que es el CRAN. Instala el entorno de desarrollo integrado RStudio Si previamente hab√≠as instalado alguna versi√≥n de R y RStudio en tu computadora, sugerimos reinstalar ambos para tener las versiones m√°s actualizadas. Recursos adicionales Gran parte de este trabajo esta basado en los libros (Wickham 2019) y (Wickham and Grolemund 2016) entre otros, as√≠ como los sitios web oficiales de R Fundation como (The R Fundation, n.d.). Si no est√°s del todo familiarizado con el lenguaje, te recomendamos lo siguientes recursos donde podr√°s encontrar informaci√≥n √∫til sobre R y RStudio. C√≥mo usar RStudio RStudio para el aprendizaje de R R: Preguntas Frecuentes R: Instalaci√≥n y administraci√≥n R-bloggers RPubs References "],
["markdown.html", "Cap√≠tulo 2 Markdown", " Cap√≠tulo 2 Markdown Antes de comenzar a escribir c√≥digo creemos que es necesario aprender a como escribir notas a trav√©s de un RMarkdown. Markdown es un lenguaje de marcado, as√≠ como lo es HTML, creado por John Gruberque donde, mediante una sintaxis f√°cil de aprender, se pueden crear archivos de texto plano integrando elementos para mejorar el formato de este. En el caso de RMarkdown, adem√°s de la sintaxis de Markdown, se pueden integrar elementos de HTML, CSS (Cascading Style Sheets) y \\(\\LaTeX\\), con la finalidad de obtener archivos con distinta extensi√≥n, como lo son pdf, html y word. Es cierto que ciertos archivos no se podr√°n llevar de una manera directa de uno a otro, como html a pdf cuando se tienen gr√°ficas interactivas, pero siempre se tiene la posibilidad de integrar c√≥digo y resultados del lenguaje de programaci√≥n con el que se este trabajando en el tipo de archivo de salida. Uno de las primeras herramientas es Zepellin; otras aplicaciones de este estilo son: Jupyter, Typora, etc. La ayuda fundamental para un paquete de R, como generalmente va a ser si se tiene disponible, es una CheetSheet y la correspondiente a RMakdown se puede descargar del siguiente enlace Para facilitar y complementar un poco la sintaxis, aqu√≠ se enlistan algunos puntos recurrentes Se pueden agregar comentarios en MarkDown empezando &lt;!‚Äì y terminando con ‚Äì&gt;. Cuando se esta trabajando en \\(\\LaTeX\\), generalmente se agrega algo llamado pre√°mbulo al inicio de los archivos .tex donde se colocan todos los comandos para darle formato al texto, en este caso se podr√≠a agregar un pre√°mbulo agregando en el YAML en la secci√≥n includes: in_header: o se pueden agregar las librer√≠as de \\(\\LaTeX\\) directamente dentro de header_includes: &quot;usepackage[all]{xy}&quot; &quot;usepackage{enumitem}&quot; &quot;usepackage{caption}&quot; &quot;captionsetup{labelformat=empty}&quot; Es posible agregar bibliograf√≠a de un archivo .bib. Esto puede hacerse en la secci√≥n bibliography: del YAML, por ejemplo: bibliography:\"bib/library.bib\". El estilo de esta tambi√©n se puede en la secci√≥n csl:, por ejemplo: csl:acm-sig-proceedings-long-author-list.csl Hay muchas opciones que se pueden agregar de acuerdo al tipo de archivo que se este creando. Para el caso un archivo HTML se puede cambiar el tema, agregar una opci√≥n para ocultar o desglosar el c√≥digo adjunto, cambiar ancho y alto de las im√°genes, etc. Algunas opciones son las siguientes: html_document: df_print: paged (Formato para tablas) highlight: tango (Dise√±o) code_folding: hide (Esconder c√≥digo) theme: flatly (Tema) toc: yes (Tabla de contenidos o un √≠ndice) (table of contents) toc_float: yes (TOC con mejor dise√±o) fig_width: 9 (Ancho) fig_height: 5 (Largo) Donde m√≠nimo se tienen las siguientes opciones: highlight: default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, and textmate theme: default, cerulean, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti. df_print: default, kable, tibble, paged Para un archivo PDF, se tienen tambi√©n una gran cantidad de opciones para personalizar el documento pdf_document: df_print: kable (Formato para tablas) fig_caption: yes (Etiquetas a las im√°genes y gr√°ficas) number_sections: yes (Secciones) toc: yes (Tabla de contenidos o un √≠ndice) (table of contents) toc_depth: 5 (Jerarqu√≠a de subtitulos) (profundidad del √≠ndice) fig_width: 7 (Ancho) fig_height: 4 (Largo) keep_tex: true (Para devolver el archivo .tex) extra_dependencies: [‚Äúamsfonts‚Äù, ‚Äúdsfont‚Äù, ‚Äúmathrsfs‚Äù, ‚Äúbbold‚Äù] (Para m√°s librer√≠as de \\(\\LaTeX\\)) Sea cual sea formato de salida que se eliga, se pueden generalizar algunas caracter√≠sticas del archivo documentclass: book (Tipo de documento) classoption: a4paper (Tama√±o del documento) fontsize: 12pt (Tama√±o de letra) geometry: ‚Äútop=1in, left=0.9in, right=1.25in, bottom=1in‚Äù (Bordes de la p√°gina) linkcolor: blue (Color para hiperv√≠nculos) urlcolor: blue (Color para enlaces) Como ya se ha mencionado, se puede hacer una integraci√≥n con el c√≥digo que se este desarrollando, as√≠ que aqu√≠ se muestran algunas opciones generales para los bloques donde va contenido el c√≥digo llamados chunks. #```{r setup, include=FALSE} knitr::opts_chunk$set( echo = FALSE, #sirve para mostrar c√≥digo y va dentro del chunk fig.pos = &#39;H&#39;, fig.align = &#39;center&#39;, message = FALSE, warning = FALSE ) #``` Para las im√°genes se puede usar alguna funci√≥n establecida en R, o bien hacer uso de lo que MarkDown permite. V√©ase el siguiente ejemplo para insertar una imagen: ![rain of numbers](source/rain_of_numbers.jpg) Otro punto importante es que la generaci√≥n de tablas se puede obtener directamente de una ‚Äútabla‚Äù que se produzca con c√≥digo, aunque ciertas veces se puede preferir hacer una tabla de manera manual. En la p√°gina Tables Generator se pueden crear estas con una interfaz amigable y simplemente copiar y pegar el resultado aqu√≠ mismo, ya sea en formato Markdown, HTML o en \\(\\LaTeX\\). La integraci√≥n del c√≥digo en R se puede hacer mediante un chunk o mediante un ejecuci√≥n en linea, para esto hay que seguir la siguiente sintaxis: \\(`\\)r code\\(`\\), por ejemplo, este üêí fue generado a trav√©s de un comando inline. En el siguiente enlace se ve un poco m√°s sobre la nomenclatura que se tiene en YAML Finalmente, existen muchas fuentes de donde obtener informaci√≥n, aunque una de las m√°s completas es del Bookdown R Markdown: The Definitive Guide y la p√°gina oficial de RMarkdown. "],
["conocimientos-b√°sicos-de-r.html", "Cap√≠tulo 3 Conocimientos b√°sicos de R", " Cap√≠tulo 3 Conocimientos b√°sicos de R Este cap√≠tulo este destinado cien por ciento a lenguaje de programaci√≥n R sin uso de algunas otras funciones que provengan de distintos paquetes. S√≠ se har√° menci√≥n de algunos paquetes como una alternativa o mejora a diversas funciones que provengan del paquete base de R. Por lo mismo, se tratar√°n algunos conceptos te√≥ricos sobre el comportamiento de este lenguaje, as√≠ como sus estructuras, su comportamiento y se presentar√°n funciones para la creaci√≥n de gr√°ficas. Se asume que previamente se ha tenido un acercamiento al paradigma de programaci√≥n orienta a objetos por lo que tambi√©n se a√±ade contenido referente a conceptos relacionados mostrando implementaciones en este lenguaje as√≠ como desventajas que puede presentar R fuera del prop√≥sito por el que fue creado. "],
["buscando-ayuda.html", "3.1 Buscando ayuda", " 3.1 Buscando ayuda Por s√≠ mismo, R cuenta con funciones que nos permitir√°n obtener ayuda sobre R en general pero tambi√©n sobre las diferentes funciones que estemos usando para resolver alg√∫n problema. Para mostrar un manual de ayuda general en formato HTML corremos el siguiente c√≥digo en la consola: help.start() El manual ser√° mostrado en el panel de ayuda dentro de RStudio pero puede abrirse con el navegador en caso de que as√≠ lo deseemos. Supongamos ahora que dentro de nuestro flujo de trabajo estamos utilizando la func√≠√≥n log() sin embargo no estamos familiarizados con ella y deseamos obtener ayuda sobre el uso de la funci√≥n. Para a tener acceso a la documentaci√≥n de la funci√≥n podemos usar alguna de las siguientes l√≠neas de c√≥digo: help(log) ?log En el caso particular de RStudio, existe un atajo con el que podemos abrir la documentaci√≥n de cualquier funci√≥n sin necesidad de correr alguna de las l√≠neas anteriores en la consola. El atajo consiste de colocar el cursor de texto entre cualesquiera caract√©res de la funci√≥n y presionar el bot√≥n F1 de nuestro teclado. Adicionalmente tenemos las siguientes funciones: apropos(&quot;plot&quot;) help.search(&quot;plot&quot;) apropos() nos ayudar√° a encontrar las funciones que incluyan el texto (en este caso plot) en su nombre. Por otro lado, help.search() nos mostrar√° la documentaci√≥n de las funciones que incluyan el texto, en este caso plot. Como se indica, cualquiera de esas opciones te permitir√° tener acceso a la documentaci√≥n de la funciones donde podr√°s encontrar: para qu√© se usan, qu√© argumentos necesitan, lo que regresan y algunos ejemplos del uso de las mismas. En el caso de buscar informaci√≥n sobre alg√∫n paquete instalado, se pueden usar los comandos vignette(package = \"some_package\") o vignette(\"some_package\"), al igual que ?library. Algunas veces, una buena opci√≥n ser√° consultar informaci√≥n creada por diferentes autores. La siguiente es una lista de varios Bookdowns que les pueden ser de gran utilidad y de constante consulta. Al final tambi√©n se agrega la liga oficial para consultar las CheatSheets disponibles. R para Ciencia de Datos R para profesionales de los datos: una introducci√≥n R for Data Science En general RStudio Cheat Sheets Una buena parte de los errores que podamos encontrarnos en nuestros flujos de trabajo se resolver√°n al revisar la documentaci√≥n de la funci√≥n que est√© generando el error, sin embargo habr√° ocasiones en las que los errores sean m√°s complejos y la documentaci√≥n no nos dar√° una buena pista de c√≥mo remediarlos, en tal caso la mejor estrategia sera utilizar tu buscador favorito para buscar el error. Ser√° tan f√°cil c√≥mo copiar el error que la consola est√© arrojando y ponerlo en la barra de b√∫squeda de e.g. Google. Muchas veces las soluciones las encontrar√°s en Stack Overflow o en otros medios; por ejemplo, para un problema relacionado a la estad√≠stica bien podr√≠as encontrar informaci√≥n valiosa en Cross Validated. "],
["vectores-y-operaciones.html", "3.2 Vectores y operaciones", " 3.2 Vectores y operaciones Quiz√° ya hayas escuchado lo siguiente en alg√∫n lado: R es un lenguaje vectorial. El comportamiento al que hace referencia esta frase ser√° de mucha ayuda en la construcci√≥n de rutinas avanzadas de programaci√≥n que veremos m√°s adelante, por ahora la implicaci√≥n m√°s relevante reside en el hecho de que la estructura b√°sica en R ser√°n justamente vectores. 3.2.1 Vectores at√≥micos En todos los lenguajes de programaci√≥n se tienen diferentes tipos de datos primitivos; por ejemplo en Java se tiene int, long, char, byte, etc. Para Python: String, Float, Boolean, entre otros. En R se tienen 6 tipos de datos primitivos, tambi√©n conocidos como ‚Äúat√≥micos‚Äù. En R, en general todo estar√° compuesto de vectores o de estructuras hechas con vectores y los datos primitivos no son la excepci√≥n, ya que estos tambi√©n son vectores. L√≥gicos (boolean): TRUE, FALSE Enteros (integer): 5 Double (doble): 5.54 Es interesante preguntarse el porqu√©, en general, un valor en coma flotante se le llama (traducido) doble. En el siguiente enlace se hace este interrogante en la p√°gina Quora. Los enteros y double son categorizados como vectores num√©ricos(numeric). Caracteres (character): \"word\" Complejos (complex): 5 + 7i Crudos o sin procesamiento (raw): raw(5) Este tipo de dato se usa para representar una secuencia de bytes. Este tipo de dato, as√≠ como los complejos generalmente no se utilizan. En el libro A Data Scientist‚Äôs Guide to Acquiring, Cleaning, and Managing Data in R de Buttrey y Whitaker se muestra un ejemplo del uso de este tipo de vectores. NOTA: A partir de aqu√≠, v√©ase el uso de distintas funciones. Existen algunas funciones de R para saber el tipo de dato que se est√° usando: typeof(), class() y mode(). Las tres funciones tienen diferentes criterios para determinar que tipo de vector at√≥mico es con el que se est√° tratando; typeof() identifica el tipo de dato visto desde el punto de vista de R y es la funci√≥n m√°s usada,mode() es compatible con S y class() identifica el tipo de datos visto desde una POO en R (espec√≠ficamente el sistema S3). cat(paste(class(TRUE), class(5), typeof(5.54), typeof(5L), mode(&quot;word&quot;), class(charToRaw(&quot;5&quot;)), typeof(5 + 7i) ,sep = &quot;\\n&quot;)) logical numeric double integer character raw complex En la siguiente tabla se muestra las posibles salidas con todas las variables de prueba. typeof() class() mode() TRUE logical logical logical 5 double numeric numeric 5.4 double numeric numeric 5L integer integer numeric word character character character charToRaw(‚Äú5‚Äù) raw raw raw 5 + 7i complex complex complex Con lo anterior surge la siguiente pregunta: ¬øHay alguna diferencia entre un vector de tipo integer y un tipo double? En general, cuando se est√°n trabajando con datos de punto flotante, se esta considerando una aproximaci√≥n del verdadero n√∫mero, tanta aproximaci√≥n como lo permita la memoria, por lo que pueden existir errores de precisi√≥n. De hecho, una manera m√°s adecuada de comparar valores con punto decimal ser√≠a utilizando la funci√≥n dplyr::near() en lugar de ==. Despu√©s se tratar√° el tema de las funciones. Otro punto interesante es que, dependiendo del tipo de vector, se tiene un distinto representante para los valores faltantes (Missing values); para un entero se tiene NA pero con un vector tipo double se tienen NA, NaN, Inf y ‚ÄìInf. Un ejemplo de esto se puede obtener al dividir distintos n√∫meros entre 0. Para un profundizar en esto, se puede ver la documentaci√≥n oficial. Algunos enlaces √∫tiles sobre los vectores num√©ricos: What is the difference between mode and class in R?. What‚Äôs the difference between integer class and numeric class in R. 3.2.2 Otros tipos de datos Adem√°s de los vectores at√≥micos, se tienen otro tipo de vector llamado factor. Un factor es un tipo especial de dato en el cual se puede establecer una jerarqu√≠a en variables categ√≥ricas. Supongase que se tiene una variable correspondiente al tama√±o de un objeto donde los posibles valores son ‚ÄúBig‚Äù, ‚ÄúLittle‚Äù, ‚ÄúMedium‚Äù, ‚ÄúJumbo‚Äù. Intuitivamente se sabe que esta variable es categ√≥rica ordinal por lo que se desear√≠a dejar establecido esta jerarqu√≠a en el vector que contenga esta informaci√≥n. factor(c(&quot;Big&quot;, &quot;Little&quot;, &quot;Medium&quot;,&quot;Jumbo&quot;)) [1] Big Little Medium Jumbo Levels: Big Jumbo Little Medium Como se puede observar, se tiene un atributo (m√°s adelante se ver√°n los atributos de un vector) indicando los niveles del factor. Los niveles se establecieron en orden alfab√©tico pero sin ning√∫n orden realmente. Para establecer los niveles se puede dar este atributo directamente desde la creaci√≥n o modificarlo despu√©s de la creaci√≥n del factor. factor(c(&quot;Big&quot;, &quot;Little&quot;, &quot;Medium&quot;,&quot;Jumbo&quot;), levels = c(&quot;Little&quot;, &quot;Medium&quot;, &quot;Big&quot;, &quot;Jumbo&quot;)) [1] Big Little Medium Jumbo Levels: Little Medium Big Jumbo De manera an√°loga, se puede dar el orden a los niveles. factor(c(&quot;Big&quot;, &quot;Little&quot;, &quot;Medium&quot;,&quot;Jumbo&quot;), levels = c(&quot;Little&quot;, &quot;Medium&quot;, &quot;Big&quot;, &quot;Jumbo&quot;), ordered = TRUE) [1] Big Little Medium Jumbo Levels: Little &lt; Medium &lt; Big &lt; Jumbo ¬øQu√© sucede si se agregan m√°s datos pero que pertenecen a los niveles? ¬øQu√© sucede cuando no se agrega un nivel? ¬øQu√© pasar√° con los niveles en datos num√©ricos? ¬øQu√© pasar√° con los niveles en datos num√©ricos pero dados como caracteres? ¬øQu√© obtenemos al usar class() y typeof() con un factor? ¬øC√≥mo puede ayudar la funci√≥n rev() en un factor? En la siguiente liga se puede ver un poco m√°s de informaci√≥n sobre este tipo de datos. En la secci√≥n 15 del libro R para ciencia de Datos (traducci√≥n al espa√±ol de R for Data Science de Wickham y Grolemund) se mencionan algunas fuentes para aprender m√°s acerca de los factores, el cual es un tema bastante √∫til de dominar ya que existe una librer√≠a llamada forcats con la que se puede trabajar de manera adecuada estos tipos de datos que son de gran ayuda al momento de hacer alg√∫n tipo de an√°lisis descriptivo, graficaci√≥n y creaci√≥n de modelos. Aqu√≠ se enlistan los art√≠culos correspondientes. Wrangling categorical data in R stringsAsFactors: An unauthorized biography stringsAsFactors = &lt;sigh&gt; Otro tipo de dato con el que se cuenta es aquel que no est√° definido, es decir, como en Java, un objeto nulo: NULL. En las siguientes l√≠neas de c√≥digo se muestra como hacer comparaciones con este tipo de dato. is.null(NULL) [1] TRUE 0 == NULL logical(0) NA == NULL logical(0) Otro punto muy com√∫n al analizar datos es encontrarse con informaci√≥n faltante. Aqu√≠, como en otros lenguajes, los valores perdidos son distintos a un objeto no definido; ya que un valor perdido bien puede indicar un error humano al momento del registro de la informaci√≥n pero con la caracter√≠stica de que se puede inferir un posible valor para ese registro faltante. Un NA es una constante que puede ser asignada a cualquier tipo de vector a excepci√≥n de un vector de tipo raw. Al tener esta ausencia de datos se desea identificarlos de manera r√°pida y esto puede ser complicado en una base de datos con cientos o miles de registros; al igual que si se tiene el conocimiento de la existencia de estos, se desea que no afecten en operaciones o aplicaciones de funciones en el resto de los datos. V√©ase lo siguiente sum(c(1,NA,3), c(1,2,3)) [1] NA Es decir, que cuando se tiene alg√∫n valor perdido, la operaci√≥n suma (m√°s adelante se ver√° a detalle las operaciones en este lenguaje) queda determinada con NA. ¬øSucede lo mismo con otro tipo de operaciones? Como se hab√≠a mencionado, se desea que si se tiene conocimiento de la existencia de al menos un NA, este no afecte a las operaciones sum(c(1,NA,3), c(1,2,3), na.rm = TRUE) [1] 10 T√©cnicamente, existen cinco missing values para cada uno de los vectores at√≥micos (a excepci√≥n de raw claro): NA, NA_interger_, NA_real_, NA_character_ y NA_complex_, pero eso solo es de manera interna. 3.2.3 Asignaci√≥n de nombres y atributos Como en cualquier lenguaje de programaci√≥n, existen identificadores para guardar o asignar el valor de los tipos de datos primitivos o resultados y as√≠ utilizarlos posteriormente. En el caso de R, la asociaci√≥n de un nombre con un cierto valor se puede realizar mediante la funci√≥n &lt;-() y gracias a que R es un lenguaje interpretado, no es necesario declarar el tipo de dato antes de darle una instanciaci√≥n. Por ejemplo, v√©ase que en las siguientes l√≠neas de c√≥digo se asignan a algunos vectores at√≥micos un identificador. a &lt;- 5+7i b &lt;- 5L c &lt;- 10 d &lt;- TRUE e &lt;- NA Y en este caso, basta con llamar a la variable por su nombre para poder usarla. a [1] 5+7i c [1] 10 e [1] NA Tambi√©n se puede asignar un valor a una variable con el operador = pero esto no es nada recomendable ya que, por buenas pr√°cticas, en este lenguaje, se acostumbra a usar el igual para dar valores a par√°metros. ¬øQu√© pasar√° cuando se ejecute x &lt;- NULL? ¬øQu√© pasar√° si antes x ten√≠a otro tipo de dato? Aqu√≠ se dejan otros ejemplos √∫tiles, m√°s adelante se ver√° la funci√≥n assign(). roma &lt;- c(0.1, 0.2, 0.3) assign(&quot;mora&quot;, c(0.4, 0.5, 0.6)) c(0.7, 0.8, 0.9) -&gt; z mora &lt;- c(roma, 0, 0, 0, roma) N.B. Los vectores en R no solo pueden ser num√©ricos tambi√©n los hay aquellos con cadenas de texto. mora[3] [1] 0.3 mora[-3] [1] 0.1 0.2 0.0 0.0 0.0 0.1 0.2 0.3 mora[c(1,5,7)] [1] 0.1 0.0 0.1 Algo que hay que entender sobre R es que este lenguaje esta basado en el paradigma de programaci√≥n orientada a objetos, aunque tambi√©n tiene ciertas caracter√≠sticas de un lenguaje funcional. Existen muchos sistemas para hacer todo lo que se tiene conocimiento de POO en R, como lo es el encapsulamiento, herencia y polimorfismo. Aqu√≠ se evitar√° en la mayor medida posible el tema pero se har√°n menciones en la marcha de esto. Para el caso de los vectores, se tienen ciertos atributos fijos desde su creaci√≥n: la longitud y el tipo de dato. M√°s adelante, en las estructuras de datos, se detallar√° sobre este tema; por el momento, v√©ase lo siguiente a &lt;- c(1,2,3,4,5) paste0(&quot;longitud: &quot;, length(a), &quot;.Tipo de dato: &quot;, typeof(a)) [1] &quot;longitud: 5.Tipo de dato: double&quot; Aclaremos ciertas cosas: La manera m√°s r√°pida de crear un vector es con el constructor c() y agregando datos del mismo tipo dentro de √©l separados con una coma. Si v_1 es un vector de un cierto tipo y se desea hacer otro vector v_2 del mismo tipo que contenga el contenido de v_1 m√°s otros elementos ¬øSe puede hacer v_2 &lt;- c(v_1,...)? Otra forma de crear cualquier otro vector es con la funci√≥n vector(\"type\", length). En cierto sentido, usar la √∫ltima funci√≥n es una mejor manera de trabajar ya que as√≠ se reserva un espacio de memoria para un vector fijo, mientras que con c() este puede ir variando. Para crear un vector vac√≠o de una cierta longitud, la funci√≥n vector() es la ideal. Se pueden crear vectores at√≥micos de cierta longitud con sus valores por defecto al usar los constructores double(length), interger(length), character(length), etc. Arriba se creo una secuencia de n√∫meros de manera rudimentaria, ya que en R se pueden crear secuencias de n√∫meros con la funci√≥n :, por ejemplo: 1:5. Con seq_along() se puede crear tambi√©n una secuencia de n√∫meros; esta la podemos usar en lugar de 1:length(v) con v un vector. ¬øQu√© pasa en las siguientes instrucciones? y &lt;- vector(\"double\", 0); seq_along(y); 1:length(y). Finalmente, se pueden hacer secuencias cada \\(n\\) n√∫meros con la funci√≥n seq(): seq(1,10,by=2). Ya que R es un lenguaje de c√≥digo libre y orientado a objetos, podemos ver el contenido de sus funciones. Para las funciones que est√°n escritas en R podemos ejecutar directamente el nombre de la funci√≥n omitiendo los par√©ntesis. integer function (length = 0L) .Internal(vector(&quot;integer&quot;, length)) &lt;bytecode: 0x7ffd2a1470f0&gt; &lt;environment: namespace:base&gt; ¬øC√≥mo est√°n hechos los constructores para double, character, boolean y raw? ¬øC√≥mo est√°n hechos los constructores para un complejo y un factor? Muchas veces es √∫til comparar distintos tipos de variables o verificar si estas son de alg√∫n tipo en espec√≠fico. Para ello existen ciertas funciones como is.character(), is.na(), is.double(), etc. En general se tiene este tipo de funciones para cualquier objeto, incluso se tiene is.function(). En el caso de los posibles valores perdidos de un double, hay que evita usar == para verificar los posibles valores como Inf y ‚ÄìInf. En su lugar usar las funciones is.finite(), is.infinite(), e is.nan(). 3.2.4 Operaciones b√°sicas en R Es importante que existan operaciones en los lenguajes de programaci√≥n, y en este caso se tienen las m√°s comunes y algunas especiales. Adici√≥n: 5 + 7; sum(5,7). Sustracci√≥n: 5 - 7. Multiplicaci√≥n: 5*7; prod(5,7). Divisi√≥n: 5 / 7. Modulo: 5 %% 7 Divisi√≥n entera (piso): 5 %/% 7. Potencia: 5 ^ 7; 5 ** 7. Multiplicaci√≥n Matricial: %*% Al igual que los cl√°sicos operadores booleanos o relacionales TRUE &amp; TRUE. TRUE &amp; FALSE. TRUE | TRUE. TRUE | FALSE. !TRUE. TRUE == FALSE. TRUE != FALSE. En resumen, tenemos la siguiente tabla Aritm√©ticos Comparaci√≥n L√≥gicos Suma (+) Menor que (&lt;) NOT (!) Resta (-) Mayor que (&gt;) AND (&amp;) Multiplicaci√≥n (*) Menor o igual que (&lt;=) OR (|) Divisi√≥n (/) Mayor o igual que (&gt;=) Cierto (TRUE) Potencia (^) Igual (==) Falso (FALSE) Modulo (%%) Diferente (!=) Divisi√≥n entera (%/%) Ahora, lo poderoso de R es poder trabajar de manera vectorial, por lo que las operaciones act√∫an tambi√©n de manera vectorial. Los siguientes ejemplos muestran el comportamiento asociado a un lenguaje vectorial que mencionamos: v &lt;- 2*roma+mora+1 v [1] 1.3 1.6 1.9 1.2 1.4 1.6 1.3 1.6 1.9 1:5 + 2:6 [1] 3 5 7 9 11 1:5 * 2:6 [1] 2 6 12 20 30 ¬øQu√© pasar√° con las siguientes operaciones? 1:5 ^ 1:5 (1:6) ^ c(2,3) s &lt;- seq(1,10, by = 2); s + 7 sqrt(s) 1:10 + 1:5 1:10 * 1:5 1:10 * 10 Lo que sucedi√≥ arriba se conoce como reciclaje, lo cual tiene el efecto de repetir de manera ordenada los vectores m√°s peque√±os para que ambos vectores que se est√°n operando tengan la misma longitud, esto resulta muy √∫til cuando se quiere repetir ciertos par√°metros en una operaci√≥n cada \\(n\\) cantidad de pasos. Por ejemplo, si se desea obtener el cuadrado de todos los pares de n√∫meros del \\(1\\) al \\(100\\), no es necesario hacer alg√∫n proceso usando condicionales y alg√∫n bucle, sino s√≥lo operar de manera vectorial y usar reciclaje. seq(1,100)^c(1,2) [1] 1 4 3 16 5 36 7 64 9 100 11 144 [13] 13 196 15 256 17 324 19 400 21 484 23 576 [25] 25 676 27 784 29 900 31 1024 33 1156 35 1296 [37] 37 1444 39 1600 41 1764 43 1936 45 2116 47 2304 [49] 49 2500 51 2704 53 2916 55 3136 57 3364 59 3600 [61] 61 3844 63 4096 65 4356 67 4624 69 4900 71 5184 [73] 73 5476 75 5776 77 6084 79 6400 81 6724 83 7056 [85] 85 7396 87 7744 89 8100 91 8464 93 8836 95 9216 [97] 97 9604 99 10000 Hay que tener cuidado en algunos casos, por ejemplo 1:4^c(2,4). Ejercicios El siguiente vector contiene una muestra referente al genero en un grupo de personas: c('H','M','M','H','H','M','H','M','H','H','M','M','M','M','M','M','M','M','H','H','H','M','H','M','M','M', 'M','H','H','H','H','M','M','M','H','M','H','H','M','H','M','H','M','H','M','M','H','H','M','H'). Mediante la funci√≥n table() determina la frecuencia de cada categor√≠a usando un factor. Convierte el siguiente vector de caracteres en un vector num√©rico y obt√©n la suma de todos sus elementos. c('7', '50', '7', '18', '42', '37', '20', '11', '33', '38', '28', '3', '16', '40', '3', '40', '36', '37', '1', '6', '8', '23', '25', '48', '5', '22', '21', '21', '1', '5', '8', '48', '34', '16', '4'). Gu√°rdalo con el nombre v. La funci√≥n table() tambi√©n funciona con elementos num√©ricos, as√≠ que crea una tabla de frecuencias de v. Ordena el vector v de forma descendente. Se desea categorizar a v en 3 grupos (los menores a 4, los mayores o igual a 4 pero menores a 31 y los restantes), por lo que hay que hacer lo siguiente Crea distintos vectores que contengan s√≥lo los elementos que caen dentro de cada categor√≠a. Agregar nombres a los vectores de acuerdo al grupo que pertenecen. Pueden usar la funci√≥n rep(). Los nombres ser√°n el n√∫mero de grupo (Uno, Dos y Tres). Une los anteriores vectores en un nuevo vector (puede ser un factor o no). Obt√©n una tabla de frecuencias para mostrar la cantidad de elementos por cada categor√≠a. Obt√©n los nombres del vector que se obtuvo al final del punto 5 y gu√°rdalo como una nueva variable. Crea un vector num√©rico con los datos 1, 2, 3 y con nombres ‚ÄúUno‚Äù, ‚ÄúDos‚Äù y ‚ÄúTres‚Äù. Utiliza character subsetting para obtener un vector de 1, 2 y 3 con el vector de nombres que se menciono al inicio de este ejercicio. Obt√©n la ra√≠z cuadrada de los primeros 100 n√∫meros naturales. Crea un vector num√©rico y eleva cada elemento a la potencia determinada por la longitud de ese vector. Crea un vector num√©rico y eleva cada uno de sus elementos al cubo sin usar el operador ^ ni **. Con los datos del inciso 1 y con la funci√≥n seq_along(), crea un vector con los datos antes mencionados pero que sus nombres sean una indexaci√≥n de estos. Con los siguientes datos c('14', '1', '12', '27', '5', '38', '9', '29', '21', '19', '34', '18', '22', '1','26', '18','36', '28', '24','39','36', '21', '36', '28', '8', '13'), crea un vector booleano determinando que elementos son menores a 26 y con ese vector booleano concluye cuantos datos son menores a 26 y cuantos no lo son. Crea una lista con cinco elementos donde, al menos dos, deben ser listas que contengan listas a su vez. Se desea crear una lista de 10 elementos con las siguientes secuencias de n√∫meros: c(1, 2, 3, ..., 10), c(11, 12, ..., 20), ..., c(91, 92, ..., 100). Adem√°s cada elemento debe tener nombre. En la lista anterior, cambia el vector c(40, ..., 50) por c(50, 49, ..., 40) sin escribir expl√≠citamente ese vector. Agrega tu nombre como un atributo a cualquier vector anterior y a la lista del punto 13 y convierte la lista a un vector. "],
["estructuras-de-datos.html", "3.3 Estructuras de datos", " 3.3 Estructuras de datos La mayor√≠a de las bases datos contienen m√°s de una variable de acuerdo a una cantidad de observaciones y no necesariamente los datos tiene que ser del mismo tipo de dato. En caso de que se deseara ejecutar alg√∫n algoritmo para la manipulaci√≥n de estos, bien se podr√≠a tomar cada variable como un vector y ser ingeniosos y cuidadosos para relacionar todos esos vectores y obtener resultados √∫tiles. Esta manera de trabajar no es eficiente ni la m√°s recomendable, ya que se dedicar√° una mayor cantidad de tiempo a la programaci√≥n y una menor a la obtenci√≥n de resultados. Existen muchas estructuras de datos y aunque todas pueden ser adaptadas a un lenguaje de programaci√≥n, cada lenguaje tiene estructuras b√°sicas para trabajar. Java tiene los arreglos y otro tipo de estructuras en ciertas librer√≠as como listas, pilas y colas. Python tiene diccionarios y mediante la librer√≠a pandas utiliza marcos de datos (data frames). En el caso de R tambi√©n se tienen esta √∫ltima y otras m√°s. La siguiente imagen resume las estructuras de datos en R. Fuente: Hands-On Programming with R. 3.3.1 Vectores Ya se ha tratado esta estructura pero faltan algunas cosas por ver. ¬øQu√© sucede cuando se ejecuta el siguiente c√≥digo? c(TRUE, 1,2,5,9.4). Lo que sucede aqu√≠ es llamado coercion. En otros lenguajes de programaci√≥n esto puede ser entendido como promoci√≥n y casteo, pero en este caso no es necesario hacer una declaraci√≥n explicita del tipo de dato al que se desea convertir. La coerci√≥n se aplicar√° en cualquier estructura que use vectores. Fuente: Hands-On Programming with R. En la imagen anterior quedan claras las reglas que se tienen al hacer coerci√≥n. Por ejemplo, ¬øQu√© tipo de vector resultar√° en las siguientes instrucciones? c(&quot;1&quot;, &quot;2&quot;, 3) c(4, &quot;a&quot;, TRUE) 4 == &quot;4&quot; 1 &lt; FALSE &quot;a&quot; != FALSE As√≠ como se tienen funciones para verificar si un vector es de alg√∫n tipo, tambi√©n es f√°cil recordar las funciones para cambiar un tipo de dato a otro; en este caso en lugar de comenzar con el prefijo is., se usar√° as. dando as√≠ las funciones as.double(), as.character, etc. Y esto no se limita a los vectores at√≥micos, ya que ciertas estructuras se pueden convertir a otras, aunque hay que tener en cuenta que ciertos atributos pueden eliminarse o que en ciertas ocasiones no ser√° posible hacer la conversi√≥n. Finalmente, al tener una estructura que contiene datos, es de esperar una sintaxis para obtener los elementos que la componen. En el caso de los vectores, la obtenci√≥n de los elementos interiores se puede hacer mediante de diferentes maneras. Posici√≥n de un elemento: (1:10)[[3]]. (1:10)[3] ¬øCu√°l es la diferencia entre [[ o [ ? Hint: ?'[['. Posici√≥n mediante un vector: (1:10)[seq(1, 10, by = 2)]; (1:10)[c(4,5)]. Mediante filtros (subsetting) (1:10)[(1:10)&lt;4]. Con nombres. Un atributo que tienen los vectores es llamado names, el cual otorga un nombre a cada uno de los elementos interiores del vector. vec_altura &lt;- c(1.50, 1.60, 1.72, 1.55) names(vec_altura) &lt;- c(&quot;Jos√©&quot;, &quot;Ra√∫l&quot;, &quot;Cecilia&quot;, &quot;Camila&quot;) vec_altura[[&quot;Jos√©&quot;]] [1] 1.5 Por √∫ltimo, v√©ase la aplicaci√≥n tablas de b√∫squeda (Character subsetting) que otorga el subsetting en los vectores. datos_frutas &lt;- c(&quot;M&quot;, &quot;Ma&quot;, &quot;S&quot;, &quot;M&quot;, &quot;S&quot;, &quot;Ma&quot;) frutas &lt;- c(M = &quot;Manzana&quot;, Ma = &quot;Mango&quot;, S = &quot;Sand√≠a&quot;) frutas[datos_frutas] M Ma S M S Ma &quot;Manzana&quot; &quot;Mango&quot; &quot;Sand√≠a&quot; &quot;Manzana&quot; &quot;Sand√≠a&quot; &quot;Mango&quot; unname(frutas[datos_frutas]) [1] &quot;Manzana&quot; &quot;Mango&quot; &quot;Sand√≠a&quot; &quot;Manzana&quot; &quot;Sand√≠a&quot; &quot;Mango&quot; 3.3.2 Listas Las listas son una estructura de datos muy √∫til por la forma en la que esta codificada, ya que esta nos ayuda a tener vectores en su interior y de diferentes tipos. Com√∫nmente se le conoce a las listas como vectores recursivos, ya que una lista puede contener listas en su interior (las listas son otro tipo de objeto as√≠ que no hay restricciones para hacer listas de listas). Como bien indica una de las im√°genes anteriores, las listas tienen una dimensi√≥n, lo cual no se debe confundir con su longitud, la cual es la cantidad de elementos que esta contiene. El constructor por defecto es list() y el tipo es list. Se pueden dar nombres a los elementos de las listas de la siguiente manera: list(\"nombre\" = datos) No es necesario dar nombres para construir una lista list(c(1,5), 1:10) [[1]] [1] 1 5 [[2]] [1] 1 2 3 4 5 6 7 8 9 10 Los elementos internos de una lista, al tener la posibilidad de ser diferentes, se pueden tener diferentes tama√±os. list(1:2, 1:10, letters[1:5]) [[1]] [1] 1 2 [[2]] [1] 1 2 3 4 5 6 7 8 9 10 [[3]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; Se tiene la funci√≥n is.list() y as.list() como cualquier otra estructura de datos en R. Esta ser√≠a una forma de hacer una lista de listas list(list(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;), &quot;numeros&quot; = list(1:10,1:5, 10:20, -3:-5)) [[1]] [[1]][[1]] [1] &quot;a&quot; [[1]][[2]] [1] &quot;b&quot; [[1]][[3]] [1] &quot;c&quot; $numeros $numeros[[1]] [1] 1 2 3 4 5 6 7 8 9 10 $numeros[[2]] [1] 1 2 3 4 5 $numeros[[3]] [1] 10 11 12 13 14 15 16 17 18 19 20 $numeros[[4]] [1] -3 -4 -5 Como las listas y los vectores son de una dimensi√≥n, estas estructuras tiene algunas caracter√≠sticas en com√∫n; ambas tienen una longitud y puede determinarse su tipo (typeof(vector(), typeof(list())). Adem√°s en ambas se les puede asignar nombres y otros atributos que se deseen para dar meta data a las estructuras. Para dar un nuevo atributo se puede usar la funci√≥n attr(). lista_1 &lt;- list(&quot;numeros&quot; = c(1,2,3), &quot;letras&quot; = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), &quot;ambos&quot; = c(1,2,&quot;3&quot;, &quot;4&quot;)) attr(lista_1, &quot;meta&quot;) &lt;- &quot;M√°s datos&quot; attr(vec_altura, &quot;atributo_extra&quot;) &lt;- &quot;M√°s datos&quot; attributes(lista_1) $names [1] &quot;numeros&quot; &quot;letras&quot; &quot;ambos&quot; $meta [1] &quot;M√°s datos&quot; attributes(vec_altura) $names [1] &quot;Jos√©&quot; &quot;Ra√∫l&quot; &quot;Cecilia&quot; &quot;Camila&quot; $atributo_extra [1] &quot;M√°s datos&quot; Al usar la funci√≥n structure(), no es necesario usar la funci√≥n attr() para agregar un nuevo atributo. structure(seq(2,20, by = 2), paridad = &quot;Pares&quot;) [1] 2 4 6 8 10 12 14 16 18 20 attr(,&quot;paridad&quot;) [1] &quot;Pares&quot; ¬øQu√© sucede al hacer structure(seq(2,20, by = 2), comment = \"Pares\")? En general, para ver la composici√≥n de una estructura, La funci√≥n str() es de gr√°n utilidad ya que dar√° de manera resumida esta composici√≥n. str(vec_altura) Named num [1:4] 1.5 1.6 1.72 1.55 - attr(*, &quot;names&quot;)= chr [1:4] &quot;Jos√©&quot; &quot;Ra√∫l&quot; &quot;Cecilia&quot; &quot;Camila&quot; - attr(*, &quot;atributo_extra&quot;)= chr &quot;M√°s datos&quot; str(lista_1) List of 3 $ numeros: num [1:3] 1 2 3 $ letras : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; $ ambos : chr [1:4] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; - attr(*, &quot;meta&quot;)= chr &quot;M√°s datos&quot; Al poder acceder a los elementos de un vector o una lista, es sencillo cambiar el contenido de estos. lista_1[[&quot;numeros&quot;]] &lt;- 2:4 lista_1 $numeros [1] 2 3 4 $letras [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; $ambos [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; attr(,&quot;meta&quot;) [1] &quot;M√°s datos&quot; vec_altura[vec_altura&lt;1.60] &lt;- 1.50 vec_altura Jos√© Ra√∫l Cecilia Camila 1.50 1.60 1.72 1.50 attr(,&quot;atributo_extra&quot;) [1] &quot;M√°s datos&quot; El acceso a una lista puede ser de diferentes maneras Mediante el nombre del elemento: lista_1[[\"numeros\"]] o lista_1$numeros. Mediante la posici√≥n: lista[[1]] ¬øCu√°l es la diferencia entre lista[[1]] y lista[1]? lista_1$ambos &lt;- NULL str(lista_1) List of 2 $ numeros: int [1:3] 2 3 4 $ letras : chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; - attr(*, &quot;meta&quot;)= chr &quot;M√°s datos&quot; Lo anterior es un ejemplo de como borrar elementos de una lista. ¬øEsto se puede hacer con un vector? ¬øSi, no, porqu√©? ü§∑ Hint: ¬øQu√© sucede al hacer lo siguiente? v &lt;- 1:10; v[5] &lt;- \"5\". ¬øEs posible convertir una lista a un vector? S√≠, pero ¬øPor qu√© as.vector(lista_1) sigue siendo una lista? ¬øQu√© hace unlist()? ¬øQu√© atributos permanecen al hacer hacer una correcta conversi√≥n? 3.3.3 Arreglos Todos aquellos que ya hayan tenido alg√∫n acercamiento con alg√∫n lenguaje de programaci√≥n como Java, C, C++, Python, etc. conocen lo importante que pueden ser los arreglos, los cuales son una colecci√≥n de elementos con ciertas posiciones. Adem√°s del simple hecho de poder almacenar elementos en un solo objeto, es de gran importancia lograr manejar matrices para realizar distintas operaciones y obtener ciertos resultados para diferentes problemas del √°mbito cient√≠fico. Como bien se indica en el diagrama donde se presentan las diferentes estructuras de datos que tenemos disponibles en R, las matrices y los arreglos solo aceptan un s√≥lo tipo de dato como los vectores. De hecho, v√©ase que internamente, los constructores de una matriz y un arreglo (matrix() y array()) tienen que convertir, en caso de que sea necesario, el input a un vector. #matrix(): . . if (is.object(data) || !is.atomic(data)) data &lt;- as.vector(data) . . } #array(): . . data &lt;- as.vector(data) . . } Por lo que una matriz y un array los podemos considerar vectores, solo que con diferentes dimensiones. Solo para aclarar, al momento de ingresar listas o matrices a estos constructores, todo ser√° llevado a vectores y se realizar√°, en caso de ser necesario, coerci√≥n y reciclaje. ¬øQu√© sucede al ejecutar matrix(list(1,2,3,4))? Consid√©rese los siguientes puntos cuando se desea construir una matriz o cuando se trabaje con ellas. Se tienen las correspondientes funciones is.matrix() y as.matrix(). El constructor matrix() en su primer argumento solicita los datos los cuales pueden ser cualquier vector. matrix(1:10) [,1] [1,] 1 [2,] 2 [3,] 3 [4,] 4 [5,] 5 [6,] 6 [7,] 7 [8,] 8 [9,] 9 [10,] 10 Autom√°ticamente matrix() dispone de sus elementos en forma columnar. El constructor de las matrices permite agregar el n√∫mero de renglones y columnas. matrix(1:10, nrow = 5, ncol = 2) [,1] [,2] [1,] 1 6 [2,] 2 7 [3,] 3 8 [4,] 4 9 [5,] 5 10 La matriz se rellena en base a columnas, pero esto puede ser modificado. ¬øC√≥mo? [,1] [,2] [1,] 1 2 [2,] 3 4 [3,] 5 6 [4,] 7 8 [5,] 9 10 Se puede acceder a los elementos de una matriz de manera an√°loga a los vectores y listas solo que considerando las dos dimensiones. matrix(1:10, nrow = 5, ncol = 2, byrow = TRUE)[1,1] [1] 1 Si no se indica alg√∫n valor, o ambos, para alguna dimensi√≥n, R entender√° que se desea abarcar toda esa dimensi√≥n. matrix(1:10, nrow = 5, ncol = 2, byrow = TRUE)[,2] [1] 2 4 6 8 10 Tambi√©n es posible acceder mediante nombres en una matriz. En este caso existe la distinci√≥n entre renglones y columnas, y las correspondientes funciones para obtener y modificar los nombres son rownames() y colnames(). m &lt;- matrix(1:10, nrow = 5, ncol = 2, byrow = TRUE) rownames(m) &lt;- paste(&quot;Row&quot;, 1:5) colnames(m) &lt;- paste(&quot;Column&quot;, 1:2) m Column 1 Column 2 Row 1 1 2 Row 2 3 4 Row 3 5 6 Row 4 7 8 Row 5 9 10 m[&quot;Row 5&quot;,&quot;Column 2&quot;] [1] 10 Al igual que en los vectores, se puede acceder mediante vectores booleanos o expresiones que resulten en vectores booleanos. m[1,m[1,]&lt;2] [1] 1 El equivalente de length() en vectores, se divide en nrow() y ncol(); adem√°s de la funci√≥n dim() para obtener ambos resultados cat(&quot;nrow: &quot;,nrow(m), &quot;\\nncol: &quot;,ncol(m), &quot;\\ndim:&quot;, &quot;c(&quot;,dim(m),&quot;)&quot;) nrow: 5 ncol: 2 dim: c( 5 2 ) La funci√≥n dim() se puede usar para modificar la estructura de una matriz; aunque esto puede ocasionar una p√©rdida de atributos. dim(m) &lt;- c(2,5) m [,1] [,2] [,3] [,4] [,5] [1,] 1 5 9 4 8 [2,] 3 7 2 6 10 La funci√≥n anterior puede usarse tambi√©n con vectores. Al hacer esto ¬øEl resultado es una matriz? Compru√©belo. vec &lt;- 1:10 dim(vec) &lt;- c(5,2) vec [,1] [,2] [1,] 1 6 [2,] 2 7 [3,] 3 8 [4,] 4 9 [5,] 5 10 Con las funciones cbin() y rbind() se pueden unir matrices por columna o por rengl√≥n. first &lt;- 1:10 second &lt;- 2:11 cbind(first, second) first second [1,] 1 2 [2,] 2 3 [3,] 3 4 [4,] 4 5 [5,] 5 6 [6,] 6 7 [7,] 7 8 [8,] 8 9 [9,] 9 10 [10,] 10 11 Las matrices son de uso recurrente en el √°lgebra lineal, por lo que se desear√≠a realizar algunas operaciones b√°sicas entre ellas; R proporciona estas as√≠ como algunas funciones importantes. Supongamos que \\(\\mathcal{A}\\) y \\(\\mathcal{B}\\) son matrices definidas en R. Operaciones b√°sicas Adici√≥n:\\(\\mathcal{A}\\)+\\(\\mathcal{B}\\). Sustracci√≥n: \\(\\mathcal{A}\\)-\\(\\mathcal{B}\\). Multiplicaci√≥n por un escalar: \\(c\\)*\\(\\mathcal{A}\\). Producto matricial: \\(\\mathcal{A}\\)%*%\\(\\mathcal{B}\\). Funciones b√°sicas Transpuesta: t(). Diagonal: diag(). Devuelve la diagonal de una matriz o crea una matriz diagonal. Determinante: det(). Inversa: solve(). solve() tambi√©n resuelve un sistema de ecuaciones dado. Varianza: var(). Vectores y valores propios: eigen(). Hay que tener en cuenta la teor√≠a sobre estas operaciones o funciones ya que ser√° relevante las dimensiones de las matrices; por ejemplo si las matrices son cuadradas para obtener el determinante o la inversa o si las dimensiones de \\(\\mathcal{A}\\) y \\(\\mathcal{B}\\) son adecuadas para aplicar, por ejemplo, la multiplicaci√≥n entre ellas. Para ver algunas otras funciones que se pueden aplicar en las matrices v√©ase los enlaces 1 y 2. Finalmente, cuando se desea crear un arreglo con un n√∫mero mayor de dimensiones, se puede utilizar el constructor array() donde se pueden indicar las dimensiones como par√°metro, por ejemplo array(1:16, c(2,2,4)). Las operaciones b√°sicas funcionan correctamente en este tipo de estructura pero la mayor√≠a de las funciones, al menos todas las mencionadas, no trabajan bien al tratar con arreglos ya que las funciones anteriores solicitan arreglos de dos dimensiones. ¬øUna matriz es un arreglo y un arreglo es una matriz? 3.3.4 Data Frames Al trabajar con matrices se debe estar consciente de que cada uno de sus elementos es de un solo tipo, lo cual puede resultar problem√°tico al tratar con una base de datos donde se tengan datos num√©ricos y categ√≥ricos o incluso cuando se desee agregar una columna de otro tipo de objetos como lo son las gr√°ficas. Aquella estructura de datos que dos dimensiones que acepta diferentes tipos de datos por columna se le llama Data Frame. La mayor√≠a de las bases de datos se trabajan con un data frame y por convenci√≥n a las columnas se les llama variables y a los renglones observaciones. La construcci√≥n de un data frame se puede hacer mediante el constructor por defecto data.frame() donde el contenido de este es similar al de una lista, ya sea dando los nombres desde la creaci√≥n o posteriormente. Por ejemplo: data.frame(c1 = 1:5, c2 = letters[1:5], c3 = list(1,2,3,4,5), c4 = matrix(0,5,2)) c1 c2 c3.1 c3.2 c3.3 c3.4 c3.5 c4.1 c4.2 1 1 a 1 2 3 4 5 0 0 2 2 b 1 2 3 4 5 0 0 3 3 c 1 2 3 4 5 0 0 4 4 d 1 2 3 4 5 0 0 5 5 e 1 2 3 4 5 0 0 Hay que notar lo siguiente del anterior ejemplo. Los vectores son tomados de manera columnar como en las matrices. Los caracteres son considerados como factores; esto puede cambiar modificando el par√°metro stringsAsFactors del constructor. Por cada elemento de la lista se agrego una columna. Las matrices son tomadas con la misma estructura en cuanto a los renglones y columnas. Estos puntos son considerados en cuenta cuando se desea convertir alg√∫n otro objeto en data frame con la funci√≥n as.data.frame(). Se debe ser cuidadoso con el n√∫mero de observaciones en cada variable, ya que estos deben ser iguales, lo cual puede ser relevante al usar las funciones rbind() y cbind() entre data frames. En general, estas funciones deben usarse si alguno de los objetos implicados es un data frame, en caso de que alguno no lo sea y ambos sean vectores, las funciones crear√°n primero una matriz aplicando coerci√≥n y dando problemas en la construcci√≥n del data frame. El constructor de una data frame, data.frame(), es m√°s robusto que el constructor de una matriz, matrix(), ya que aqu√≠ se deben mantener las estructuras en las columnas; por ejemplo una columna de listas no deben convertirse en una columna de n√∫meros como en el caso de una matriz para una sola lista. Si se desea tener una columna de listas y no distribuir los elementos de la lista en las columnas de data frame, se puede utilizar la funci√≥n I() la cual ayuda a tratar un objeto como el mismo y as√≠ no aplicarle alg√∫n tipo de transformaci√≥n. (df &lt;- data.frame(numbers = 1:3, listas= I(list(num_list = 1:10,letras = letters,listas = list(1,2,3,4))))) numbers listas num_list 1 1, 2, 3,.... letras 2 a, b, c,.... listas 3 1, 2, 3, 4 Al igual que las listas, el acceso puede ser mediante los nombres y posici√≥n adem√°s de vectores booleanos, agregando el acceso que se aplica en las matrices. df$listas$letras [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; df[[&quot;numbers&quot;]] [1] 1 2 3 df[1,2] $num_list [1] 1 2 3 4 5 6 7 8 9 10 df[1,2]$num_list [1] 1 2 3 4 5 6 7 8 9 10 df[2,c(typeof(df$numeros), typeof(df$listas))==&quot;list&quot;] $letras [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; Es posible agregar nombres a los renglones de un data frame como en una matriz. row.names(df) &lt;- 1:3 df numbers listas 1 1 1, 2, 3,.... 2 2 a, b, c,.... 3 3 1, 2, 3, 4 ¬øQu√© sucede al usar la funci√≥n as.matrix() con el anterior data frame? ¬øSe puede cambiar la dimensi√≥n de un data frame como en una matriz usando la funci√≥n dim()? ¬øSe pueden aplicar operaciones b√°sicas entre data frames? ¬øCu√°les y en que caso? No esta de m√°s mencionar que hay otro tipo de objeto en R llamado expresiones. Estas son importantes al momento de desarrollar una funci√≥n a un nivel m√°s profesional. En este libro no se tratar√° dicho tema pero se puede estudiar a profundidad de esto en el libro Advance R. Aqu√≠ se deja un simple ejemplo de tal objeto. x &lt;- 3 y &lt;- 2.5 z &lt;- 1 exp &lt;- expression(x/(y + exp(z))) Ejercicios La siguiente instrucci√≥n genera un vector con valores num√©ricos y NA: sample(c(1:20, rep(NA,15))). El anterior vector se debe guardar con el nombre de random_NA y Usando alg√∫n ciclo, determine cuantos valores NA hay en random_NA. Utilizando los conocimientos de coerci√≥n, la funci√≥n sum() y lo que sea necesario, determinar cuantos valores NA existen en random_NA. Crea una funci√≥n que, dado un vector, se determine la cantidad de valores perdidos en √©l. Crear un funci√≥n que, dado un n√∫mero se cree una matriz que contenga solo ese n√∫mero. El n√∫mero de renglones y columnas debe tambi√©n ser dado en los par√°metros de la funci√≥n. Usando alg√∫n ciclo, crear una funci√≥n llamada suma_gauss en la que se tendr√° que simular el proceso para la suma de los primeros \\(n\\) n√∫meros en \\(\\mathbb{N}\\). No se debe utilizar la formula de manera directa. Crear una matriz, sin tener que usar alg√∫n ciclo, de 0s y 1s alternados. Aqu√≠ un ejemplo [,1] [,2] [,3] [,4] [1,] 0 1 0 1 [2,] 1 0 1 0 [3,] 0 1 0 1 [4,] 1 0 1 0 [5,] 0 1 0 1 Crear un data frame de la siguiente matriz. [,1] [,2] [,3] [,4] [,5] [1,] 1 25 81 169 289 [2,] 4 36 100 196 324 [3,] 9 49 121 225 361 [4,] 16 64 144 256 400 Crear un data frame con 5 variables y al menos 3 observaciones. La primera variable corresponder√° a nombres de una persona, las dem√°s representar√°n la edad, altura, peso y nacionalidad de cada individuo. Se puede usar la funci√≥n sample(). En el anterior data frame, agregar una sexta variable que represente los videojuegos que tiene cada usuario. Los datos deben ser los siguientes: list(juegos = c(\"Horizon-Zero-Dawn\", \"bloodborne\")), list(juegos = c(\"Mario-Kart\", \"Mario Maker\", \"Mario Odyssey\")), list(c(\"Halo\", \"Batman Arkham Knight\", \"Injustice\")). Si hacen falta m√°s datos, crearlos o replicar los ya dados. Crear un funci√≥n que regrese una lista donde cada elemento de la lista tendr√° el nombre de cada una de las estructuras y los tipos de datos ya vistos y su contenido ser√° un vector booleano indicando si, de acuerdo al par√°metro de la funci√≥n, se es de alguna clase de las ya vistas. Por ejemplo, si se da como input una matriz de caracteres, la lista resultante en la posici√≥n [[\"Matriz\"]] y en [[\"Caracter\"]] deben contener el valor TRUE. Obtener la siguiente matriz usando la funci√≥n paste(). [,1] [,2] [,3] [,4] [,5] [1,] &quot;a A&quot; &quot;e E&quot; &quot;i I&quot; &quot;m M&quot; &quot;q Q&quot; [2,] &quot;b B&quot; &quot;f F&quot; &quot;j J&quot; &quot;n N&quot; &quot;r R&quot; [3,] &quot;c C&quot; &quot;g G&quot; &quot;k K&quot; &quot;o O&quot; &quot;s S&quot; [4,] &quot;d D&quot; &quot;h H&quot; &quot;l L&quot; &quot;p P&quot; &quot;t T&quot; Del data frame del inciso 22, obtener mediante una expresi√≥n l√≥gica las columnas, que de acuerdo al primer rengl√≥n, contengan valores menores a 150. Crea una lista que contenga al menos cada una de las estructuras ya vistas. Crear una funci√≥n que, dadas dos matrices, se verifique si estas son aptas para aplicarles las operaciones fundamentales suma y sustracci√≥n y regresar dichos resultados en una lista; en caso de que sean aptas para la multiplicaci√≥n agregar este resultado a la lista de retorno. Crear un ciclo dentro de una funci√≥n donde, de acuerdo a un data frame de entrada, y utilizando la primera observaci√≥n del data frame, se determine el tipo de variable que contiene el data frame en cada columna. Finalmente todos los resultados deben ser devueltos en un vector. "],
["sentencias-de-control-ciclos-y-funciones.html", "3.4 Sentencias de control, ciclos y funciones", " 3.4 Sentencias de control, ciclos y funciones Todo el conocimiento ya obtenido no ser√≠a √∫til a largo plazo si no se tiene alguna manera de controlar el comportamiento del c√≥digo bajo ciertas circunstancias, ya sea permitiendo ciertos bloques de c√≥digo, repitiendo o ejecutando una cantidad determinada o indeterminada de veces un cierto proceso o aplicar ciertas transformaciones a los resultados. Por todas estas razones comenzaremos con la estructura de control m√°s b√°sica. 3.4.1 If &amp; If-else La estructura if() permite la ejecuci√≥n de un cierto bloque de c√≥digo si el par√°metro booleano que recibe tiene por valor TRUE, lo cual indicar√≠a que la condici√≥n necesaria para la ejecuci√≥n del bloque es v√°lida. Recordemos que un valor TRUE, y en general un booleano, se puede obtener mediante diferentes expresiones usando operadores l√≥gicos. if(boolean) { c√≥digo } Ahora, suponiendo que se desea tratar el simple problema de determinar si un usuario, de acuerdo a su edad, puede ver cierto contenido. Se puede actuar de la siguiente manera if(edad&gt;=18) { Permitir_contenido } if(edad == 17){ No_permitir_contenido } if(edad == 16){ No_permitir_contenido } . . . if(edad == 0){ No_permitir_contenido } O bien de la siguiente manera if(edad&gt;=18) { Permitir_contenido } if(edad &lt; 18){ No_permitir_contenido } En cualquiera de los dos casos es necesario tratar el complemento con otra sentencia if() lo cual no es recomendable cuando no se tenga certeza de todos los casos contrarios a la condici√≥n en el primer if. Por lo cual, para tomar el complemento, se tiene la sentencia if-else; donde si sucede la condici√≥n, se ejecuta el c√≥digo dentro de los delimitadores del if y en caso contrario (else) se ejecuta lo correspondiente para el complemento de la condici√≥n. if(edad&gt;=18) { Permitir_contenido }else{ No_permitir_contenido } Existe en R la funci√≥n ifelse() la cual permite trabajar de manera vectorial. V√©ase el siguiente ejemplo #Se crea un vector con 15 edades de personas de manera &quot;aleatoria&quot; (edades &lt;- sample(1:90, replace = T, size = 15)) [1] 29 59 7 69 30 49 61 13 23 15 28 40 34 63 28 ifelse(edades&lt;18, yes = &quot;Menor de edad&quot;, no = &quot;Mayor de edad&quot;) [1] &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Menor de edad&quot; &quot;Mayor de edad&quot; [5] &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Menor de edad&quot; [9] &quot;Mayor de edad&quot; &quot;Menor de edad&quot; &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; [13] &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; &quot;Mayor de edad&quot; Es decir, que en cada entrada del vector eval√∫a la expresi√≥n dada y en caso de ser cierta la condici√≥n, se devuelve, en este caso, el caracter ‚ÄúMenor de edad‚Äù y en caso contrario ‚ÄúMayor de edad‚Äù. V√©ase que la funci√≥n ifelse() regresa un vector. 3.4.2 For, While y Repeat Cuando un programador ve que un proceso se debe repetir una cantidad de veces, autom√°ticamente piensa en un bucle. En el caso de R se tienen los ciclos for(), while() y repeat(). Recordando que en Java los primeros dos bucles ten√≠an una estructura similar a la siguiente: for(int i = 0; i&lt;n; i++){ Ejecuci√≥n del c√≥digo n veces } while(boolean){ Ejecuci√≥n del c√≥digo hasta que el booleano sea false } En el caso de R se tendr√° una estructura un poco diferente ya que se iterar√° directamente sobre un objeto y no usando una variable auxiliar que evalu√© una expresi√≥n para obtener un booleano y determine si el ciclo termino. En el caso del ciclo while se tiene la misma sintaxis. for(elementos in objeto){ Ejecuci√≥n_del_c√≥digo } while(boolean){ Ejecuci√≥n_del_c√≥digo } V√©ase los siguientes ejemplos for(number in 1:5){ print(number + 1); } [1] 2 [1] 3 [1] 4 [1] 5 [1] 6 Se esta usando directamente cada elemento dentro del vector para ejecutar un cierto bloque de c√≥digo. Hay que aclarar que no es necesario usar el elemento con el que se est√° iterando aunque es com√∫n hacerlo. ¬øFuncionar√° con una lista o una matriz? for(letra in letters[1:5]){ print(paste(&quot;Letra &quot;, letra)) } [1] &quot;Letra a&quot; [1] &quot;Letra b&quot; [1] &quot;Letra c&quot; [1] &quot;Letra d&quot; [1] &quot;Letra e&quot; En el anterior c√≥digo se esta usando otro vector, el cual es no num√©rico, dando un mejor ejemplo de que el iterador no esta dependiendo de valores num√©ricos. edad &lt;- c(20,24,41,17,20) n_cliente &lt;- 1 control_parental &lt;- TRUE while(control_parental){ if(edad[n_cliente]&gt;=18){ print(&quot;Apto para la pel√≠cula&quot;) n_cliente &lt;- n_cliente+1 }else{ print(&quot;Menor de edad&quot;) control_parental &lt;- F } } [1] &quot;Apto para la pel√≠cula&quot; [1] &quot;Apto para la pel√≠cula&quot; [1] &quot;Apto para la pel√≠cula&quot; [1] &quot;Menor de edad&quot; Aqu√≠ se est√°n usando expresiones de control para determinar la salida del bucle. Hay que recordar que en un ciclo while se corre el peligro de entrar en un ciclo infinito, el cual ser√≠a lo deseado en algunos casos. Un ciclo que se trata con un bucle tipo for siempre puede ser tratado como uno tipo while pero no siempre el caso contrario. Y que la elecci√≥n entre un ciclo while y uno for depende de si se conoce el n√∫mero de veces que se ejecutar√° un bloque o no. ¬øExiste algo equivalente al switch-case visto en Java? Para estos dos ciclos se puede hacer uso de las sentencias break y next, las cuales permiten la interrupci√≥n de un ciclo y la exclusi√≥n de alguna iteraci√≥n. for(letra in letters){ if(letra == &quot;f&quot;) break print(letra) } [1] &quot;a&quot; [1] &quot;b&quot; [1] &quot;c&quot; [1] &quot;d&quot; [1] &quot;e&quot; Cuando se ejecuta repeat el ciclo termina sin importar la existencia de m√°s iteraciones sobre el objeto. for(letra in letters){ if(any(letra == letters[4:24])) next print(letra) } [1] &quot;a&quot; [1] &quot;b&quot; [1] &quot;c&quot; [1] &quot;y&quot; [1] &quot;z&quot; Para el caso de next, v√©ase que se salt√≥ ciertas iteraciones m√°s no termino el ciclo. Finalmente, R proporciona la estructura break, en la cual puede encontrarse cierta similitud con un ciclo while o do-while. repeat{ . . ejecuci√≥n_c√≥digo . . break } Este bucle se detiene cuando se encuentra a la sentencia break. n_saludos &lt;- 5 repeat{ print(rep(&quot;Hola&quot;, n_saludos)) #Se detiene el repeat cuando n_saludos sea igual a 1 if(n_saludos==1){ break } n_saludos &lt;- n_saludos-1 } [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; &quot;Hola&quot; [1] &quot;Hola&quot; Existe un ‚Äúproblema‚Äù con los ciclos en R debido a las configuraciones internas para el almacenamiento de objetos. Por el momento es suficiente saber que trabajar de manera vectorial o aplicar funciones que est√°n en R de manera predeterminada es una mejor y m√°s r√°pida forma de trabajar. M√°s adelante se ver√° en que casos los ciclos pueden ser ‚Äúlentos‚Äù adem√°s de otros problemas que pueden surgir, por ejemplo en la recursi√≥n, y cuando ser√° la mejor opci√≥n usar un ciclo que alguna funci√≥n que trabaje de manera vectorial. 3.4.3 Funciones Como ya se hab√≠a mencionado, R es un lenguaje de programaci√≥n orientado a objetos aunque tambi√©n tiene ciertas caracter√≠sticas de un lenguaje funcional ya que las funciones en R pueden considerarse funciones de primera clase; es decir que pueden ser asignadas a variables, ser almacenadas en ciertas estructuras como las listas, servir como par√°metros de otras funciones y ser el retorno de otras funciones. Aunque estas no pueden ser consideradas, como bien dice Handley Wickham en su libro RAdvance, puras; es decir funciones de orden superior ya que, para que una funci√≥n sea considerada de orden superior, de acuerdo a un input dado, se debe tener una √∫nica salida (inyectividad) lo cual no sucede con muchas funciones en R como sample(), runif(), print() y hasta en &lt;-(). Sin importar que las funciones no sean de orden superior, lo cual otorga cierta flexibilidad, es indudable la importancia de crear funciones para optimizar el trabajo, dar estructura, limpieza e incluso claridad; ya que al usar una funci√≥n, el resultado ser√° algo esperado sin importar su comportamiento interno; en cambio al visualizar un ciclo, este puede no quedar claro en su funcionamiento. La creaci√≥n de funciones es sencilla nombre_function &lt;- function(par√°metros){ c√≥digo } Los par√°metros pueden ser cualquier objeto e incluso funciones. En este √∫ltimo caso, a estas funciones se les llama funcionales. El retorno de una funci√≥n puede quedar expl√≠citamente dado con la funci√≥n return() aunque si no se utiliza esta funci√≥n, la √∫ltima l√≠nea de c√≥digo en la funci√≥n es considerada como el retorno de la funci√≥n. El retorno puede ser cualquier tipo de objeto e incluso pueden devolver funciones. En este √∫ltimo caso, a estas funciones se les llama function factory. Cuando una funci√≥n tiene como valor de retorno un booleano, a esta funci√≥n se le conoce como predicate y cuando una funci√≥n acepta una o m√°s funciones como par√°metros y a su vez regresa funciones, se les conoce a estas funciones como function operator. Los par√°metros de una funci√≥n pueden tener valores por defecto, los cuales pueden ser reescritos cuando se den expl√≠citamente otros valores. suma &lt;- function(v1 = c(1,2), v2 = c(3,4)){ sum(v1, v2) } suma() [1] 10 suma(v1 = 4, v2 = 1:20) [1] 214 Algo interesante de las funciones en R, al igual que en Python, es que se pueden dar una cantidad indeterminada de par√°metros si as√≠ se indica en la funci√≥n con el argumento .... V√©ase el siguiente ejemplo. #v1 y v2 vectores num√©ricos suma &lt;- function(v1, v2, ...){ sum(v1, v2, ...) } Es decir, que se est√° considerando ... como un par√°metro m√°s de la funci√≥n aunque n√≥tese que no es necesario agregar m√°s de dos variables en la funci√≥n. suma(c(1,2), 1:4) [1] 13 suma(c(1,2), 1:4, 1:20) [1] 223 Ejercicios Crear un nuevo operando y utilizarlo con dos vectores. En el siguiente enlace se puede encontrar informaci√≥n sobre la funci√≥n replicate. Teniendo en mente que la anterior funci√≥n puede remplazar a un ciclo for, realice el ejercicio 16 utilizando dicha funci√≥n. Vea que sucede al utilizar el par√°metro simplify con los valores FALSE y TRUE. Aplicar las funciones min() y max() en la matriz del ejercicio 22 sobre los renglones y columnas. Con la lista creada al momento de explicar la funci√≥n lapply(): list(a = seq_matrix, b = seq_matrix+1, c = seq_matrix+3), utilizar tal lista, la funci√≥n lapply() y una funci√≥n an√≥nima, para sumarle 5 al elemento [2,3] de cada matriz. Con base en el ejercicio anterior, hacer una funci√≥n que acepte una lista (como la del anterior ejercicio), un par√°metro tipo String; los posibles valores de este ser√°n ‚Äúsuma‚Äù, ‚Äúresta‚Äù, ‚Äúmutl‚Äù, ‚Äúdiv‚Äù; tambi√©n debe aceptar tres par√°metros num√©ricos, el primero servir√° como operando de las operaciones anteriores y los siguientes como coordenadas para ubicar el elemento en las matrices. De acuerdo a las operaciones anteriores, realizar pora cada caso con la funci√≥n lapply y una funci√≥n an√≥nima la operaci√≥n correspondiente al elemento designado por los par√°metros de la funci√≥n. Observese que sucede al ejecutar (1:10)[-1]. Obtener de la lista del ejercicio 13 los √∫ltimos 5 elementos de cada vector. Crear una funci√≥n que, dada una lista, se determine que tipo de datos son sus elementos. Imprimir una sequencia de vectores con sapply(). Crear un nuevo operando que sea capaz de concatenar un n√∫mero con una letra. Utilizar la funci√≥n del ejercicio anterior para concatenar a los elementos de una matriz de caracteres un n√∫mero. Utilizar el operando anterior para concatenar un n√∫mero a todos los elementos de la matriz del ejercicio 26. Usando la funci√≥n which(), obtener los resultados solicitados del ejercicio 11. Usando alguna funci√≥n de la familia apply y una funci√≥n an√≥nima, obtener los resultados solicitados del ejercicio 11. Obtener el m√°ximo y m√≠nimo de cada uno de los elementos en la lista del ejercicio 13. Crear una funci√≥n que acepte una matriz y devuleva una lista con dos elementos: ‚ÄúStatsColumns‚Äù y ‚ÄúStatsRows‚Äù; los cuales deben ser listas y contener los resultados de aplicar las funciones sum(), prod(), sqrt(sum()) y cumsum() por renglones y columnas. "],
["funciones-1.html", "3.5 Funciones", " 3.5 Funciones El tema de las funciones es algo extenso, por lo que se dar√° de manera resumida el contenido necesario para entender gran parte del funcionamiento de estas en R. Una de las mejores fuentes de informaci√≥n la pueden encontrar en el libro Advance R, espec√≠ficamente en los cap√≠tulos 6 y 7; para explorar m√°s sobre este tema se puede consultar la segunda parte de la misma referencia. Finalmente, se ver√° como usar vectorizaci√≥n, una de las fuertes habilidades de R, y por √∫ltimo una serie de funciones que podr√≠an ser de gran utilidad en ciertos temas. Particularmente en la programaci√≥n con R, ser√° de mucha utilidad aprender a crear funciones: funcionfactorial&lt;-function(a){ res &lt;- 1 if(a&lt;0){ return(&quot;No existen factoriales de n√∫meros negativos.&quot;) } else if(a==0){ return(res) } else{ for(i in 1:a){ res &lt;- res*i } return(res) } } 3.5.1 Funciones Una funci√≥n que crea el usuario se compone de tres partes: los formales, los cuales son los argumentos o los par√°metros de una funci√≥n y que pueden obtenerse con la funci√≥n formals(), el cuerpo, es decir el c√≥digo o las rutinas internas de las funciones que se pueden obtener con la funci√≥n body(), y un ambiente, el cual se puede obtener con la funci√≥n environment() y que b√°sicamente es un lugar donde esta almacenada la informaci√≥n necesaria para el correcto uso de las funciones; m√°s adelante se hablar√° un poco m√°s de este importante concepto. ¬øQu√© tipo de estructuras o qu√© tipo de objetos regresan las anteriores funciones? ¬øCu√°les son los tres componentes en la siguiente funci√≥n? myStrangeFunction &lt;- function(a = 1,b = 4,c,...) sum(prod(a,b), c, ...) Como ya se mencion√≥, este lenguaje toma ciertas caracter√≠sticas de un lenguaje funcional, por lo que al tratar a las funciones como objetos es de esperarse la incorporaci√≥n de atributos a estas. Uno de estos atributos es el llamado srcref (source reference), la cual imprime mejor el cuerpo de alguna funci√≥n. ¬øCon qu√© funci√≥n se agregar√≠a un atributo a una funci√≥n? ¬øC√≥mo se puede obtener el atributo srcref de myStrangeFunction? El output es el siguiente function(a = 1,b = 4,c,...) sum(prod(a,b), c, ...) R contiene ciertas funciones que son a√±adidas al momento de iniciar su interfaz, las cuales se han agregado a las distintas versiones del lenguaje y a medida que R ha evolucionado se han optimizado estas funciones internas dando un buen rendimiento para su uso cotidiano. Estas funciones son llamadas primitivas y ya se han visto algunas de estas: sum(), prod(), [(), sqrt(), etc. Algunas de las funciones primitivas est√°n implementadas y existen en el lenguaje C, lo cual da garant√≠a de un buen rendimiento. Los tres componentes que se mencionaron antes no los tienen este tipo de funciones y as√≠ es posible verificar si una funci√≥n primitiva existe principalmente en C. ¬øC√≥mo se puede ver si una funci√≥n es primitiva o no? Si las funciones primitivas otorgan un buen rendimiento ¬øPorqu√© no todas las funciones son primitivas? function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) Para utilizar, o mejor dicho llamar, a una funci√≥n, basta con escribir su nombre, colocar los argumentos separados por coma dentro de unos par√©ntesis y ¬°listo! Aunque se ha mencionado que + tambi√©n es una funci√≥n: '+'(), por lo que hay que discernir las diferentes formas de llamar a una funci√≥n. prefix: myFunction(arguments). infix: a+b. replacement: colnames(df) &lt;- names. special: [[, if, for, etc. V√©ase que las propias estructuras de control y los bucles tambi√©n son funciones y R permite modificar todo aquello que sea funci√≥n, aunque todas las formas especiales son funciones primitivas. No es recomendable sobre escribir alguna funci√≥n que ya se tenga preestablecida en R o en alguna librer√≠a, pero siempre se tiene la libertad de hacerlo en caso de que se tenga el control y la consciencia suficiente de las consecuencias. Solo para aclarar, v√©ase los siguientes puntos. Todas las funciones se pueden llamar a manera de prefijo. myFunction(a,b,c) `+`(a,b) `colnames&lt;-`(df, names) for(name in names) print(name) `for`(name, names, print(name)) Como + es una funci√≥n, es posible crear operadores usando % al inicio y al final del operador. Todos los operadores de R se pueden encontrar ejecutando ?Syntax. `%mixOperations%` &lt;- function(a,b) a+b*a/b 4 %mixOperations% 5 [1] 8 Algunas funciones √∫tiles de este estilo son %%, %*%, %/%, %in%, %o% y %x%. ¬øQu√© hacen cada una de ellas? Es an√°logo la sintaxis para crear funciones de asignaci√≥n aunque es necesario tener el formal value. `indexNames&lt;-` &lt;- function(a, value) { names(a) &lt;- as.character(seq_along(a)+value) a } x &lt;- 1:20 indexNames(x) &lt;- 3 x 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Ahora, v√©ase la siguiente funci√≥n ignoringParameters &lt;- function(x) &quot;Hello!&quot; ignoringParameters(1:30) [1] &quot;Hello!&quot; Sea cual sea el objeto que se de como par√°metro al llamar la funci√≥n, se devolver√° el mismo resultado. Esto es posible porque las funciones en R trabajan de manera ‚Äúperezosa‚Äù con sus argumentos, a esto se le llama lazy evaluation. B√°sicamente, si no es llamado en alg√∫n momento un argumento de la funci√≥n, este no es utilizado y solo cuando se llame al argumento, hasta ese momento se har√° el acceso a √©l. Esto es gracias a la t√©cnica de evaluaci√≥n lazy evaluation que utiliza R al usar una estructura de datos llamada promise donde, b√°sicamente las variables son evaluadas mediante un ambiente hasta que una expresi√≥n las utilice y este valor es guardado (cached), por ejemplo y &lt;- 7 lazilyEvaluated &lt;- function(x, lazy_var = y*a){ print(&quot;Hi!&quot;) y &lt;- 50 a &lt;- 3 print(lazy_var) x*2 } doubleVector &lt;- function(x) c(x,x) doubleVector(lazilyEvaluated(y)) [1] &quot;Hi!&quot; [1] 150 [1] 14 14 Dentro del ambiente de la funci√≥n, el nombre de la variable y tiene asociado un valor distinto y no tiene consciencia de la variable con el nombre y fuera de √©l. Al utilizar la variable y como argumento de la funci√≥n, a esta se le da el nombre de x pero se le asocia el mismo valor de y. El par√°metro lazy_var es llamado hasta print(lazy_var), donde antes se asignaron valores a las variables y y a, dando as√≠ una correcta evaluaci√≥n a lazy_var; es decir que hasta ese momento fue necesario evaluar lazy_var por lo cual no se genera alg√∫n problema. ¬øPor qu√© s√≥lo se imprimi√≥ una vez el \"Hi!\" y el valor de lazy_var? Por el valor calculado y guardado en la promise. Otra forma de llamar a una funci√≥n es usando la funci√≥n do.call(), la cual permite agregar una lista de par√°metros. do.call(myStrangeFunction, args = list(a = 2, b = 3, c = 4, 6,7,8,9)) [1] 40 Los objetos que guardemos o asignemos en nuestros flujos de trabajo ser√°n almacenados en un espacio de memoria que se llama ambiente o en ingl√©s environment. Desde RStudio podremos ver lo que se guardado en este espacio de memoria en el panel Environment. Este tema es un poco extenso por lo que hay que entender s√≥lo algunas cosas. Un ambiente en R es lo que se conoce como una cerradura (closure) en programaci√≥n. Una cerradura es una t√©cnica para almacenar la informaci√≥n necesaria y permitir la integridad de esta en una funci√≥n. Un ambiente se encarga de asociar un conjunto de nombres a un conjunto de valores, por lo que los valores no estan directamente almacenados en el ambiente, si no s√≥lo los enlaces identificados por los correspondientes nombres. En un ambiente todos los nombres son √∫nicos y no est√°n ordenados (recordar que los nombres est√°n asociados a las variables o valores para un uso posterior, por ejemplo: var &lt;- c(1,2)). Para crear un ambiente se utiliza la funci√≥n new.env(). La funci√≥n ls() permite ver todos los elementos de un ambiente. Se utiliza la funci√≥n assign() para agregar un nuevo elemento a un ambiente dado y para obtener alguno de los elementos se puede acceder con el operando $, como en una lista o con la funci√≥n get() (si no se encuentra la variable con el nombre dado, get buscar√° en los ambientes padres). Para preguntar si existe alguna variale con un nombre dado en un ambiente se utiliza la funci√≥n exists() y para eliminar una o varias referencias de variables en un ambiente se usa la funci√≥n rm(). env_test &lt;- new.env() assign(&quot;new_variable&quot;, 1:5, envir = env_test) ls(env_test) [1] &quot;new_variable&quot; env_test$new_variable [1] 1 2 3 4 5 # get(&quot;new_variable&quot;, envir = env_test) exists(&quot;new_variable&quot;, envir = env_test) [1] TRUE rm(&quot;new_variable&quot;, envir = env_test) ls(env_test) character(0) M√°s ejemplos ## Muestra los nombres de los objetos en memoria ls() ## Muestra las variables con cierta serie de caracteres en su nombre ls(pat=&quot;m&quot;) ## Muestra las variables las cuales su nombre empieza con el caracter dado ls(pat=&quot;^m&quot;) ## Muestra detalles de los objetos en memoria ls.str() ## Eliminar todas las variables de &#39;Global Environment&#39; rm(list=ls()) ## Eliminar √∫nicamente variables que empiezan con la letra m rm(list=ls(pat=&quot;^m&quot;)) ## Tipo de elementos del objeto v mode(v) ## Longitud del objeto v length(v) En un ambiente se pueden acceder a las variables que est√°n enlazas en el mismo mediante su nombre, lo cual garantiza que, si dado una variable en otro ambiente con un mismo nombre a alguna variable en el ambiente actual, estas no sean confundidas y se obtengan resultados inesperados. Cada ambiente tiene un padre, lo cual permite que existan enlaces entre las librer√≠as, permitiendo la inclusi√≥n de funciones en distintos paquetes. Para ver el ambiente padre se utiliza la funci√≥n parent.env() dando como par√°metro un ambiente. V√©ase la siguiente imagen Fuente: Advance R. El ambiente donde regularmente se trabaja es el R_Global_Environment tambi√©n llamado workspace. Cada vez que se agrega una nueva librer√≠a, el environment para esta (package environment) es colocado entre el ambiente de la √∫ltima librer√≠a cargada y el ambiente global. Para ver todos los ambientes activos de este tipo se puede usar la funci√≥n search(). Cada vez que se crea una funci√≥n, esta es enlazada con el ambiente global mediante un function environment. Cuando los ambientes son modificados, estos no son copiados; copiados en el sentido que se ver√° m√°s adelante en la secci√≥n Iteraci√≥n y Recursi√≥n. Cada funci√≥n en un paquete esta asociado con un ambiente del paquete y un ambiente especial llamado namespace environment, el cual contiene todos los enlaces a las variables de la funci√≥n, y un import environment que contiene todos los enlaces a las funciones que requiera la funci√≥n del paquete actual. Cada vez que se ejecuta una funci√≥n, se crea un execution environment donde su padre es el ambiente de la funci√≥n. Recordando un poco de lo aprendido en programaci√≥n orientada a objetos, existe la analog√≠a de que las cerraduras son una manera de simular el encapsulamiento en las funciones, y ya que las funciones son de primera clase en R, son tratadas tambi√©n como objetos. Para m√°s informaci√≥n acerca de los temas anteriores cons√∫ltese Advance R. Second Edition y Advance R. First Edition. 3.5.2 Vectorizaci√≥n Desde las estructuras de datos es f√°cil ver la importancia que tienen los vectores en R y la facilidad de usar funciones y operaciones en ellos, logrando tener un buen rendimiento, evitando ciclos y ganando comprensi√≥n en los resultados esperados. La Vectorizaci√≥n significa aplicar funciones optimizadas, en este caso escritas en C, para llegar a una soluci√≥n del problema a tratar. Esto da soluciones m√°s simples tratando a los vectores como unidad en lugar de pensar en una soluci√≥n donde se tiene que tratar cada entrada en el vector. En este √∫ltimo caso se tendr√≠a que hacer alg√∫n tipo de ciclo, en el caso de la vectorizaci√≥n los ciclos son hechos directamente en C, los cuales son m√°s r√°pidos y con menor sobre carga. Ya se han tratado algunas funciones vectorizadas, como lo son sum(), prod() y sqrt(), las cuales todas sirven con un vector. ¬øQu√© sucede con sum(list(1,2,3,4,4,5)), sum(matrix(1,ncol = 3,nrow = 6)) y sum(data.frame(x = 1:20, y = 2:21))? Dado lo anterior, ¬øSe puede obtener la suma por renglones o columnas en una matriz? ¬øSe puede hacer lo mismo en un data frame o una lista? ¬øSe puede aplicar una funci√≥n particular que trabaje de manera vectorial por renglones o columnas en un data frame? La respuesta a todo esto es ¬°S√≠! y se puede realizar todo con la familia de funciones apply. La familia apply es un conjunto de funciones que ayudan en la aplicaci√≥n vectorial de funciones sobre ciertas estructuras de datos. Para ver a detalle el funcionamiento de cada una de estas y otras funciones, puede consultarse el tutorial de DataCamp Tutorial on the R Apply Family y los enlaces que se dejan al final de esta sub-secci√≥n. Mientras tanto, v√©ase los siguientes ejemplos y funciones. La funci√≥n apply(X, MARGIN, FUN, ...) ejecuta una funci√≥n en un arreglo o una matriz X. El atributo MARGIN es utilizado para determinar si la aplicaci√≥n vectorial ser√° por renglones o columnas (MARGIN = 1 aplicar√° FUN sobre renglones, MARGIN = 2 sobre columnas y MARGIN=c(1,2) para ambos) seq_matrix &lt;- matrix(1:12, nrow = 4, ncol = 3) sum_n_times &lt;- function(x, n) sum(x*n) apply(seq_matrix, MARGIN = 1, sum) [1] 15 18 21 24 apply(seq_matrix, MARGIN = 2, FUN = sum_n_times, 5) [1] 50 130 210 En el c√≥digo anterior se utiliz√≥ la funci√≥n sum_n_times, la cual puede solo usarse para este caso y en ninguna otra ocasi√≥n. Esto puede suceder cuando se requiera un resultado especial y √∫nico, por lo que declarar y reservar un espacio en memoria para una funci√≥n y todo lo que implica podr√≠a ser un uso inadecuado del espacio disponible. Para estos casos se puede utilizar una funci√≥n an√≥nima, las cuales son conocidas como funciones lambda. seq_data_frame &lt;- data.frame(x = 1:12, y = 2:13) apply(seq_data_frame, MARGIN = 2, FUN = function(x) sum(x*5)) x y 390 450 V√©ase que se utilizo un data frame en la funci√≥n apply anterior. Esto funciona pero no es la manera correcta de hacer vectorizaci√≥n con data frames. En otro momento se ver√° el porqu√© de esto. La funci√≥n lapply acepta arreglos, data frames, vectores y listas y tiene la peculiaridad de regresar una lista. lapply(list(a = 1:20, b = 2:30), sum) $a [1] 210 $b [1] 464 lapply(list(a = list(1,2,3), b = list(4,5,6), c = list(7,8,9)), FUN = &quot;[&quot;, 2) $a $a[[1]] [1] 2 $b $b[[1]] [1] 5 $c $c[[1]] [1] 8 lapply(seq_matrix[c(1,2),c(1,2)], &quot;[&quot;, 1) [[1]] [1] 1 [[2]] [1] 2 [[3]] [1] 5 [[4]] [1] 6 lapply(list(a = seq_matrix, b = seq_matrix+1, c = seq_matrix+3), FUN = &quot;[&quot;, 1,2) $a [1] 5 $b [1] 6 $c [1] 8 V√©ase que se utilizo el operador '[' para extraer elementos de las listas y elementos de las matrices. ¬øQu√© significa el par√°metro 1 en '[ cuando se utiliz√≥ para seq_matrix[c(1,2),c(1,2)]? Hint: V√©ase la descripci√≥n del argumento X en la documentaci√≥n de lapply(). ¬øQu√© significa el par√°metro 2 en '[ cuando se utiliz√≥ para el segundo ejemplo? ¬øQu√© se obtiene en el √∫ltimo ejemplo? Otra de las funciones m√°s utilizadas es sapply(). Esta funci√≥n devuelve una salida con la estructura m√°s b√°sica posible, por lo que es com√∫n obtener vectores con esta funci√≥n. sapply() es una versi√≥n amigable de lapply() por el tipo de salida, aunque modificando el par√°metro simplify a FALSE, sapply tiene el mismo comportamiento que lapply(). sapply(list(a = 1:20, b = 2:30), function(x) sqrt(sum(x))) a b 14.49138 21.54066 sapply(list(a = 1:20, b = 2:30), function(x) sqrt(sum(x)) , simplify = FALSE) $a [1] 14.49138 $b [1] 21.54066 A√∫n falta ver las funciones tapply(), mapply() y vapply(). ¬øQu√© hace replicate()? ¬øQu√© hace which()? Aqu√≠ se enlistan algunos enlaces √∫tiles sobre este tema: Using apply, sapply, lapply in R. R Programming for Data Science R para principiantes 3.5.3 Paquetes Antes de ver un compendio de funciones √∫tiles, hay que tener en cuenta que reutilizar c√≥digo es muy importante para no perder tiempo en la resoluci√≥n de problemas; y antes de instalar librer√≠as o usar otras funciones base de R, hay que hablar sobre el CRAN. El CRAN (Comprehensive R Archive Network) es una red de servidores web y FTP (File Trasnfer Protocol) donde se almacenan versiones de c√≥digo y documentaci√≥n de R. Adem√°s proporciona los hiperv√≠nculos para muchos paquetes con diversos temas (se puede consultar todo esto en el CRAN Task Views). Como es dif√≠cil e ineficiente tener todo en un mismo lugar, se crearon copias (mirrors) al rededor del mundo donde se mantiene y da soporte a toda esta informaci√≥n. Se puede consultar en la siguiente enlace la lista de todos estos lugares. Para el caso de M√©xico, se tienen dos ubicaciones: Instituto Tecnologico Autonomo de Mexico Colegio de Postgraduados, Texcoco Para instalar paquetes se puede elegir alguna de las siguientes opciones: Instalaci√≥n directa: install.packages(&quot;tidyverse&quot;) install.packages(&quot;file:///source&quot;, repos=NULL) Mediante RStudio: Tools &gt; Install.Packages ‚Ä¶ Regularmente, los paquetes usar√°n en su codificaci√≥n funciones de otros paquetes, por lo que ser√° necesario instalar todas los paquetes de los que depende para su correcto uso. Para evitar instalar uno por uno los paquetes de los que dependa alguno, se agrega el argumento dependences=TRUE a la funci√≥n install.packages(): install.packages(...,dependeces = TRUE). Lo anterior sirve para aquellos paquetes que est√°n en el CRAN, pero si no lo est√°n o se desea instalar otra versi√≥n de los paquetes, se puede usar devtools, el cual permite instalar un paquete directamente desde su fuente, como es el caso de algunos localizados en github. install.packages(&quot;devtools&quot;) library(&quot;devtools&quot;) install_github(&quot;hadley/emo&quot;) Al instalar un paquete, este es guardado en el ordenador; ya que los paquetes no son m√°s que archivos y carpetas que pueden contener funciones en Scripts, archivos .Rsd (Bases de datos de R) entre otros. Ejemplo para el paquete actuar La ubicaci√≥n donde el paquete es guardado se le llama library y para identificar donde empieza la busqueda R al cargar un paquete se utiliza el comando .libPaths(). ¬øQu√© sucede al ejecutar lapply(.libPaths(), dir)? Para cargar un paquete se puede utilizar las funciones library() y require. Ambas funciones cargan lo contenido en los paquetes aunque existen peque√±as diferencias entre ambas. Al querer cargar un paquete que no esta instalado, library devolver√° un error y require una advertencia, adem√°s require regresa un valor booleano dependiendo si se encuentra o no la librer√≠a para cargar dicho paquete; esto puede ser √∫til dentro de funciones para preparar el workspace y sus enlaces. Por ejemplo, en la siguiente funci√≥n se instala el paquete dplyr en caso de no se tenga la librer√≠a o se carga el paquete en caso contrario. preparation &lt;- function(){ if(!require(&quot;dplyr&quot;)){ install.packages(&quot;dplyr&quot;) } } Al momento de querer usar una funci√≥n de alg√∫n paquete se puede llamar como cualquier funci√≥n, aunque puede darse el caso de que existan los mismos nombres entre dos o m√°s librer√≠as para una funci√≥n o hasta el mismo nombre para una funci√≥n que cre√≥ el usuario. En tal caso se puede especificar el paquete con el operador ::; por ejemplo stats::chisq.test(). ¬øPara qu√© sirve la funci√≥n attach() y detach? 3.5.4 Miscellaneous A continuaci√≥n se dar√° una serie de funciones y paquetes con los que se puede trabajar en ciertas ocasiones. Aqu√≠ no se mencionar√°n funciones que ‚Äúvivan‚Äù en el ‚Äútidyverse‚Äù o funciones dedicadas a elementos gr√°ficos, as√≠ como funciones relacionadas a temas avanzados de estad√≠stica y probabilidad. 3.5.4.1 Vectores base::cumsum(): Dado un vector, la funci√≥n cumsum devuelve la suma acumulada de dicho vector. Tambi√©n se tiene base::cummin(), base::cummax() y base::cumprod(). base::unique(): Esta funci√≥n elimina los elementos duplicados en un vector, data frame o un arreglo. base::sort(): La funci√≥n sort regresa de manera ordenada su input, el cual debe ser un vector o factor. base::gl(): Genera series regulares de factores dados. Ejemplos: gl(3, 5, length = 30), gl(2, 6, label = c(\"Hombre\",\"Mujer\")). base::union(), base::intersect(), base::setdiff() y base::setequal(): Funciones para realizar operaciones de conjuntos en vectores. package:vctrs: Este paquete ofrece varias funciones √∫tiles en el manejo de vectores, adem√°s de que algunas de sus funciones se pueden usar en otro tipo de estructuras de datos. 3.5.4.2 Matrices y Data frames base::rowSums()y base::rowMeans(): Con estas funciones se obtienen la suma o el promedio por rengl√≥n en una matriz. Existe el equivalente para las columnas y son m√°s r√°pidas estas funciones que al aplicar apply. ¬øQu√© hace base::rowsum()? utils::head() y utils::tail(): Funciones para obtener las primeras o √∫ltimas observaciones de un data frame; tambi√©n funciona con matrices. base::split(): Dicha funci√≥n separa en grupos de acuerdo a una variable. package:data.table: El paquete data.table contiene varias funciones para manipular data.tables, los cuales pueden obtenerse f√°cilmente con un data frame. Las funciones en este paquete son eficientes en memoria y muy r√°pidas. La funci√≥n base::expand.grid() genera un data frame con todas las posible combinaciones de vectores o factores dados como argumentos. Aqu√≠ un ejemplo: expand.grid(h = c(60, 80), w = c(100, 300), sex = c(\"Hombre\", \"Mujer\")). 3.5.4.3 Lectura y escritura En cuanto a archivos externos, en general se utilizan archivos con extensi√≥n .csv y .txt; sin embargo R no est√° limitado a este tipo de archivos. Existen una amplia variedad de formatos que se pueden leer a trav√©s de paquetes dise√±ados espec√≠ficamente para ese fin. El siguiente ejemplo muestra c√≥mo se har√≠a la lectura de un archivo con extensi√≥n .txt: datos&lt;-read.table(&quot;data.txt&quot;, # nombre del archivo (con extensi√≥n) entre comillas header = TRUE, # TRUE o FALSE, indicando si el archivo tiene como primer rengl√≥n el nombre de las columnas sep=&quot;\\t&quot; # separador de los campos ) Una vez que leemos el archivo externo en R, el objeto donde se almacenar√° la informaci√≥n ser√° de tipo data.frame. Muchas veces ser√° de nuestro inter√©s exportar objetos data.frame a archivos externos, tal objetivo lo podemos lograr con alguna de las siguientes dos opciones: write.table(datos, &quot;toma.txt&quot;, append=F, sep=&quot;\\t&quot;) write.csv(datos, &quot;toma2.csv&quot;) N:B. Como en la lectura de datos, R no est√° limitado a exportar archivos .csv o .txt tambi√©n existe una amplia variedad de formatos que podemos generar. En la siguiente lista se aclaran algunas funciones utilizadas y se a√±aden otras que pueden ser de inter√©s. base::read.csv(), base::read.delim(), base::read.table() y base::readLines(): Diferentes funciones para leer archivos de texto en distintos formatos. base::write(), base::csv() y base::table(): Funciones para exportar datos, como un data frame o una matriz, en un formato especifico. base::saveRDS(): Funci√≥n para exportar o guardar alg√∫n objeto de R. Se puede leer este objeto con la funci√≥n base::readRDS(). Estas funciones no est√°n optimizadas y existen algunas variantes para estas funciones como readr::save_rds y qs::qsave(). A√∫n as√≠, este tipo de almacenamiento de datos (en forma de bytes) es de lo m√°s confiable ya que es serializable. Se recomienda leer el post A better way of saving and loading objects in R. 3.5.4.4 Funciones estad√≠sticas y matem√°ticas base::sample(): Funci√≥n para obtener una muestra aleatoria de \\(n\\) n√∫meros y permutaciones de un conjunto dado. set.seed(): Funci√≥n para asignar la semilla para los m√©todos pseudo aleatorios posteriores. base::sd(): desviaci√≥n est√°ndar. base::var(): varianza. base::min(): m√≠nimo. base::max(): m√°ximo. base::median(): mediana. base::range(): rango. base::quantile(): cuantiles. set.seed(20) data &lt;- data.frame(v = sample(c(1:25, NA), size = 50, replace = T), w = sample(c(1:25, NA), size = 50, replace = T), x = sample(c(1:25, NA), size = 50, replace = T), y = sample(c(1:25, NA), size = 50, replace = T), z = sample(c(1:25, NA), size = 50, replace = T)) head(data) v w x y z 1 6 1 17 NA 13 2 11 15 8 11 22 3 24 6 3 15 21 4 2 2 11 8 20 5 25 6 7 3 19 6 2 10 18 25 24 data.frame(Sd = sapply(data, sd, na.rm = T), Varianza = sapply(data, var, na.rm=TRUE), Min = sapply(data, min, na.rm=TRUE), Max = sapply(data, max, na.rm=TRUE), Mediana = sapply(data, median, na.rm=TRUE), MissingValues = sapply(data, function(x) sum(is.na(x)))) Sd Varianza Min Max Mediana MissingValues v 7.359459 54.16163 2 25 14.0 0 w 7.845289 61.54857 1 25 8.0 3 x 7.646861 58.47449 1 25 10.0 1 y 7.126090 50.78116 1 25 11.0 4 z 7.176597 51.50355 1 25 14.5 2 Lo anterior es un peque√±o resumen cuantitativo de los datos generados, pero se pueden obtener con diferentes funciones como base::sumary(), base::fivenum() y Hmisc::describe(). Con los paquetes naniar y visdata se puede dar tratamiento a los valores perdidos, as√≠ como elementos gr√°ficos de resumen sobre estos. base::abs(): Valor absoluto. base::sqrt(): Ra√≠z cuadrada. base::exp(): Funci√≥n exponencial. base::log(): Logaritmo Natural. base::log2(), base::log10(), base::log(base): Logaritmo en diferente base. base::sin(), base::cos(), base::tan(), base::asin(),..: Funciones trigonom√©tricas. base::integrate(): Funci√≥n para encontrar el √°rea debajo de una curva base::uniroot(): Funci√≥n para encontrar las ra√≠ces de una funci√≥n. base::optimse(): Funci√≥n para encontrar el m√≠nimo o m√°ximo de una funci√≥n. base::lfactorial(): Esta funci√≥n calcular el logaritmo natural del factorial de un n√∫mero. base::cut(): Dicha funci√≥n establece intervalos en todo el rango de valores dados por un vector. ¬øEl resultado es un factor? base::findInterval(): Misma finalidad de la funci√≥n cut pero es m√°s r√°pido que dicha funci√≥n. 3.5.4.5 Others base::object.size(): Esta funci√≥n regresa una aproximaci√≥n de la memoria utilizada por un objeto. base::capture.output(): Dicha funci√≥n captura la salida de una funci√≥n en un caracter. base::readlines(): Lectura de una l√≠nea que el usuario ingresa desde la terminal. base::invisible() y base::withVisible(): En ciertas ocasiones se desea que el resultado de las funciones no sea impreso, en tal case se utiliza la funci√≥n invisible y para poder visualizarlo la funci√≥n withVisible(). try(), suppressWarnnings() y suppressMessages(): Con dichas funciones se puede aplicar el manejo de excepciones. V√©ase la documentaci√≥n sobre las funciones base::on.exit() y base::stop(). base::traceback(): Al momento de tener un error en alguna funci√≥n, la funci√≥n traceback puede ser utilizada para ver los errores en la pila de ejecuci√≥n. package:lobstr: Este paquete ofrece varias funciones para el manejo de objetos; como la obtenci√≥n de un identificador de la direcci√≥n de memoria que tiene un objeto, su tama√±o en bits, obtener en mejor orden el resultado de ciertas funciones; por ejemplo con lobstr::cst() se obtiene el √°rbol de la pila de llamadas obtenido por base::traceback() , el tama√±o de memoria utilizada en la sesi√≥n actual, etc. package:rlang: Las funciones de este paquete est√°n dise√±adas para trabajar con ambientes. package:profvis y package:bench: Cuando se desea optimizar el funcionamiento del c√≥digo, es com√∫n utilizar funciones para evaluar la r√°pidez de las funciones o rutinas con las que se trabaja; estos paquetes ayudan a realizar un perfilamiento del c√≥digo y a realizar microbenchmark en funciones peque√±as. V√©ase el siguiente enlace para m√°s funciones. var function (x, y = NULL, na.rm = FALSE, use) { if (missing(use)) use &lt;- if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot; na.method &lt;- pmatch(use, c(&quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;pairwise.complete.obs&quot;, &quot;everything&quot;, &quot;na.or.complete&quot;)) if (is.na(na.method)) stop(&quot;invalid &#39;use&#39; argument&quot;) if (is.data.frame(x)) x &lt;- as.matrix(x) else stopifnot(is.atomic(x)) if (is.data.frame(y)) y &lt;- as.matrix(y) else stopifnot(is.atomic(y)) .Call(C_cov, x, y, na.method, FALSE) } &lt;bytecode: 0x7ffd33de0f58&gt; &lt;environment: namespace:stats&gt; La funci√≥n anterior calcula la varianza de una variable, en este caso un vector. V√©ase que al final de la descripci√≥n se menciona la palabra bytecode, la cual resulta familiar cuando ya se trabajo en el lenguaje de programaci√≥n Java. A partir de la versi√≥n 2.14 de R, todas las funciones est√°ndar y paquetes fueron pre compilados en bytecode, lo cual otorga rapidez. Si el usuario desea compilar alguna funci√≥n en bytecode lo puede hacer con la funci√≥n compiler::cmpfun(). Si existe la inclusi√≥n del compilador bytecode en R ¬øExistir√° alg√∫n m√©todo para realizar JIT? S√≠. Ejercicios Comparar la funci√≥n del ejercicio 20 con la funci√≥n sum() con bench::mark(). Obtener la uni√≥n, intersecci√≥n y diferencia del siguiente conjunto de letras. set.seed(20) MixLetters &lt;- sample(c(LETTERS, letters),size = 30) Buscar alg√∫n data frame del paquete datasets. Guardar en una variable los primeros 10 registros y en otra los √∫ltimos 10. Verifica el siguiente resultado usando la funci√≥n integrate(). \\[ \\int_0^1sin(\\pi x)dx = \\frac{2}{\\pi} \\] Verifica con la funci√≥n integrate() que la famosa funci√≥n de densidad de una normal integra \\(1\\) en todo su rango. A continuaci√≥n se deja dicha funci√≥n y si se desea basta con usar los par√°metros de una normal est√°ndar (\\(\\sigma = 1\\) y \\(\\mu = 0\\)). \\[ f(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} \\] Utilizar la funci√≥n bench::mark() para comparar la rapidez entre las funciones rowSums() y apply(sum) en una matriz num√©rica. Obtener la suma y producto acumulado de los primeros 100 n√∫meros naturales. Dentro del repositorio de este proyecto se encuentra el archivo Data_fake.csv. Este debe cargarse en la sesi√≥n actual de R y guardarse como un data frame con el nombre de Data_fake. Del data frame Data_fake obtener por columna el m√≠nimo, m√°ximo y mediana con alguna funci√≥n de la familia apply en aquellas columnas que sea posible. Usar alguna de las funciones resumen en Data_fake. Crear una funci√≥n que acepte un data frame como input y devuelva una lista con dos elementos; el primero ser√° un data frame con solo aquellas variables que sean de tipo categ√≥ricas sobre el input y la segunda entrada de la lista de retorno un data frame con las variables num√©ricas. Utilizando la funci√≥n anterior sobre Data_fake, obtener el data frame con solo variables num√©ricas y aplicar la funci√≥n del inciso 45. An√°logo a lo anterior, obtener el data frame con solo variables num√©ricas de Data_fake y dividir cada variable en 5 intervalos. Utilizar alguna funci√≥n de la familia apply para aplicar la funci√≥n table() sobre cada una de las variables del data frame Data_fake. Con los resultados anteriores, obtener aquellos elementos que son m√°s recurrentes. "],
["iteraci√≥n-y-recursi√≥n.html", "3.6 Iteraci√≥n y Recursi√≥n", " 3.6 Iteraci√≥n y Recursi√≥n ¬øLos ciclos son lentos en R? S√≠ y no. Todo depende de como se utilice. Para comprender lo anterior, primero hay que entender como R almacena sus objetos. Para tener un entendimiento completo sobre todas las estructuras, es recomendable leer el capitulo 2 de Advance R; por el momento s√≥lo se dar√° una introducci√≥n sobre como se comportan los vectores y las listas. Como ya se habia mencionado, cuando se hace alg√∫n objeto en R, como un vector o una lista, a estos se les asigna un nombre para poder identificarlos posteriormente. V√©ase los siguientes resultados. x &lt;- 1:5 tracemem(x) [1] &quot;&lt;0x7ffd309ba070&gt;&quot; El resultado anterior es un identificador de la direcci√≥n en formato hexadecimal del vector x en memoria. y &lt;- x tracemem(y) [1] &quot;&lt;0x7ffd309ba070&gt;&quot; Ahora el nombre ‚Äúy‚Äù esta asociado con la variable x, aunque en realidad los nombres ‚Äúy‚Äù y ‚Äúx‚Äù apuntan hacia un mismo objeto y eso puede verse con los anteriores resultados. ¬øQu√© suceder√° cuando se modifique alg√∫n valor en la variable y? ¬øSe modificar√° en esa posici√≥n x? trace_vec &lt;- capture.output(y[[3]] &lt;- 10) cat(paste(c(strsplit(trace_vec[1],&quot;:&quot;)[[1]][1], strsplit(trace_vec[2],&quot;:&quot;)[[1]][1]), collapse = &quot;\\n&quot;)) tracemem[0x7ffd309ba070 -&gt; 0x7ffd31aa0798] tracemem[0x7ffd31aa0798 -&gt; 0x7ffd3191fdf8] cat(paste(c(x[[3]], y[[3]]), collapse = &quot;\\n&quot;)) 3 10 Los valores del vector x no se modificaron, solo los de y y las anteriores salidas al modificar el tercer elemento en el vector y son por lo que en R se conoce como Copy-on-modify donde b√°sicamente los vectores no son copiados hasta que estos sean modificados. La primera salida es debido a que se realizo una copia de todos los elementos de x y posteriormente se modifico en y el tercer elemento. V√©ase que x no fue alterado en la ubicaci√≥n o el identificador en memoria de este. tracemem(x) [1] &quot;&lt;0x7ffd309ba070&gt;&quot; tracemem(y) [1] &quot;&lt;0x7ffd3191fdf8&gt;&quot; ¬øSi se hubiera modificado alg√∫n elemento de x en lugar de y, qu√© hubiera sucedido? Ahora, v√©ase el caso con las listas list_mem &lt;- list(uno = 1:5, dos = 1:7) list_mem_copy &lt;- list_mem tracemem(list_mem) [1] &quot;&lt;0x7ffd2e038348&gt;&quot; tracemem(list_mem_copy) [1] &quot;&lt;0x7ffd2e038348&gt;&quot; Las listas creadas anteriormente tienen la misma direcci√≥n y no s√≥lo eso, si no que cada uno de los elementos de la lista tambi√©n son los mismos cat(paste(c(tracemem(list_mem[[1]]), tracemem(list_mem_copy[[1]]), tracemem(list_mem[[2]]), tracemem(list_mem_copy[[2]])), collapse = &quot;\\n&quot;)) &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e7b5ab0&gt; &lt;0x7ffd2e7b5ab0&gt; ¬øQu√© sucedera cuando se modifique alg√∫n elemento en list_mem? ¬øSuceder√° lo mismo que en los vectores? trace_list &lt;- capture.output(list_mem[[2]] &lt;- 2:8) cat(strsplit(trace_list[1],&quot;:&quot;)[[1]][1]) tracemem[0x7ffd2e038348 -&gt; 0x7ffd2f1f1bc8] Solo se hizo un cambio en direcci√≥n de memoria, ya que en el caso de las listas no se copia todos los elementos, solo se cambia el puntero hacia otro objeto. V√©ase que en los elementos que no se realizo alg√∫na modificaci√≥n se sigue apuntando hacia el mismo objeto. cat(paste(c(tracemem(list_mem[[1]]), tracemem(list_mem_copy[[1]]), tracemem(list_mem[[2]]), tracemem(list_mem_copy[[2]])), collapse = &quot;\\n&quot;)) &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e7b59d0&gt; &lt;0x7ffd2e5237c0&gt; &lt;0x7ffd2e7b5ab0&gt; ¬øLas direcciones de las listas list_mem y list_mem_copy ahora son diferentes? En resumen, al modificar alg√∫n elemento dentro de un vector, se cre√≥ una copia de todos los valores teniendo as√≠ dos vectores con diferentes nombres y, cuando se modifica alg√∫n elemento en las listas, solo se cambia de direcci√≥n el punto correspondiente a ese objeto y los dem√°s enlaces permanecen. Cuando se hace alg√∫n ciclo donde se este agregando o modificando alg√∫n vector, internamente se realizar√°n copias de todo el vector aunque s√≥lo un elemento sea alterado; en ese caso los ciclos iterativos son lentos, pero cuando se utiliza una lista en lugar de un vector el rendimiento mejora bastante. Hay que recordar que R no fue dise√±ado para ser r√°pido, aunque usando listas el rendimiento obtenido ser√° mejor al usar un ciclo. library(bench) library(knitr) data &lt;- data.frame(matrix(1:100000, ncol = 100)) plus2_byVector &lt;- function(x){ #Al usar m[[n]] cuando m es un data.frame, v√©ase que se estan tomando vectores for(item in 1:length(x)){ x[[item]] &lt;- x[[item]]+2 } x } kable(bench::mark(plus2_byVector(data))[c(&quot;min&quot;, &quot;median&quot;, &quot;mem_alloc&quot;, &quot;total_time&quot;)], format = &quot;markdown&quot;) min median mem_alloc total_time 1.37ms 1.64ms 1.3MB 353ms plus2_byList &lt;- function(x){ #Al convertir un data.frame en una lista, se agrega un elemento por columna x &lt;- as.list(x) for(item in 1:length(x)){ x[[item]] &lt;- x[[item]]+2 } x } kable(bench::mark(plus2_byList(data))[c(&quot;min&quot;, &quot;median&quot;, &quot;mem_alloc&quot;, &quot;total_time&quot;)], format = &quot;markdown&quot;) min median mem_alloc total_time 149¬µs 185¬µs 813KB 291ms Otro punto que hay que considerar es que no siempre existir√° una manera sencilla de usar alg√∫n funcional para remplazar a un ciclo, ya sea al modificar en alg√∫n lugar un objeto o al usar recursi√≥n, ya que en este √∫ltimo caso se depende de √≠ndices o de elementos anteriores que con un funcional no ser√≠a sencillo de resolver. En general, hay ocasiones en las que un ciclo debe permanecer expl√≠citamente para dar soluci√≥n a un problema, tal es el caso de un modificaci√≥n en una estructura en cada iteraci√≥n; esto se puede remplazar con alg√∫n funcional aunque el c√≥digo puede perder legibilidad. Otra circunstancia donde los ciclos no deben ser remplazados por un funcional son las relaciones recursivas ya que estas dependen de las posiciones dentro de una estructura, lo cual si puede ser dif√≠cil de plasmar en un funcional. Finalmente, cuando se tenga una soluci√≥n implementada con un ciclo while, ser√° complicado remplazar este por funciones como de la familia apply. En el √°mbito de la recursi√≥n, se pueden tener varios problemas y uno de los principales son la manera en que estos son tratados dentro de los lenguajes no funcionales, ya que el almacenamiento en este tipo de instrucciones puede ser demasiado. La manera en que trabajan las funciones recursivas es llamando internamente a las mismas funciones hasta llegar a un caso base, y mientras se opere con los resultados de las funciones internas, estos deben ser almacenados en la memoria y la forma en que estos son almacenados es en una pila conocida como Call Stack. Dependiendo del lenguaje de programaci√≥n la administraci√≥n de la pila de llamadas puede cambiar, aunque esta siempre tendr√° un l√≠mite de almacenamiento. En el caso de la recursi√≥n puede ser sencillo llenar esta y obtener una excepci√≥n indicando esta situaci√≥n. Para tales casos, se puede remplazar la implementaci√≥n de las funciones con diferentes t√©cnicas; una de ellas se llama Memoization en la cual se guarda, en un ambiente fuera de la pila de llamadas, los resultados que se han obtenido de las funciones recursivas. Por ejemplo, si se esta tratando el problema de tener los primeros \\(n\\) n√∫meros de fibonacci y previamente se corri√≥ fibonacci(m) donde \\(m&lt;n\\), al momento de hacer fibonacci(n) est√° buscar√° si existen registros de llamadas previas y comenzar√° desde ese punto, por lo que fibonacci(n) no tendr√° que calcular los \\(n-1\\) nuevamente, si no, solo los faltantes; por lo que, si se tiene el suficiente espacio, el problema del l√≠mite de memoria en la Call Stack quedar√° resuelto. En los siguientes enlaces se dejan algunos ejemplos de esto. Optimize your R Code using Memoization StackOverFlow:Factorial Memoization in R Otra forma de solucionar el problema de la recursi√≥n, es llevar un proceso recursivo a uno iterativo, esto puede ser complicado algunas veces y m√°s a√∫n cuando ya se tenga el proceso de manera recursiva implementado, por lo que una soluci√≥n es tomar dicha implementaci√≥n y tratarla de manera iterativa dentro de una funci√≥n, a dicha t√©cnica se le conoce como trampoline. Este t√©rmino esta relacionado con el lenguaje Lisp, pero se utiliza para identificar dicha t√©cnica. En el siguiente enlace se deja un ejemplo de esto en R. Tail Recursion in R with Trampolines Finalmente, hay que tener en cuenta que el almacenamiento de llamadas de una funci√≥n se hace en la Call Stack por que se opera con dichos resultados, por ejemplo en fibonacci(n) se debe realizar fibonacci(n-1)+fibonacci(n-2). Si de alguna manera se implementa un m√©todo recursivo sin operar con los resultados previos se podr√≠a evitar dicho problema, a esto se le conoce como Tail Call Optimization. "],
["graficaci√≥n.html", "3.7 Graficaci√≥n", " 3.7 Graficaci√≥n La comunicaci√≥n visual siempre ser√° un recurso muy importante para presentar y aclarar la informaci√≥n con la que se esta trabajando as√≠ como los resultados obtenidos. R cuenta con una gran cantidad de funciones para crear elementos gr√°ficos, principalmente en el √°mbito estad√≠stico, a partir de ciertas estructuras u objetos, las cuales se pueden personalizar y dar un mejor formato a gusto del programador. En esta secci√≥n s√≥lo se ver√°n algunas funciones y estrategias para crear objetos gr√°ficos usando las funciones que proporciona R por defecto, as√≠ como funciones de ciertos paquetes a excepci√≥n de paquetes y funciones relacionados con ggplot. Una de las funciones m√°s importantes es la funci√≥n plot(), la cual es una funci√≥n gen√©rica por lo que dependiendo del tipo de objeto u objetos que se den como par√°metros se comporta de manera distinta, esta funci√≥n devolver√° un gr√°fico relacionando dos variables (\\(x\\) y \\(y\\)) en un plano cartesiano. T√≥mese como ejemplo los datos pressure del paquete datasets. ¬øQu√© dice la documentaci√≥n acerca de estos datos? head(pressure) temperature pressure 1 0 0.0002 2 20 0.0012 3 40 0.0060 4 60 0.0300 5 80 0.0900 6 100 0.2700 plot(pressure) El anterior gr√°fico tambi√©n pudo obtenerse especificando lo que se considerar√° como variable \\(x\\) y \\(y\\) o dando una formula: plot(pressure$temperature, pressure$pressure) plot(pressure ~ temperature, data=pressure) La anterior gr√°fica contiene muchos elementos gr√°ficos, como t√≠tulos para los ejes y hasta los propios ejes, adem√°s las observaciones en los datos son dibujados como circunferencias. V√©ase en la siguiente gr√°fica que se puede modificar todo esto y agregar unos cuantos elementos gr√°ficos m√°s .scroll-300 { max-height: 300px; } plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presi√≥n&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes col.axis = &quot;#284c73&quot;, # Color para las anotaciones en los ejes fg = &quot;#9fb3c9&quot;, # Color para otros elementos gr√°ficos como los ejes type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo cex.lab = 1.1, # Tama√±o para los t√≠tulos en los ejes cex.axis = .8 # Tama√±o para los ejes #cex har√≠a proporcional el tama√±o en todo. ) Tambi√©n pueden eliminarse los ejes y el marco plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo axes = FALSE, #Eliminando ejes xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presi√≥n&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo cex.lab = 1.1 # Tama√±o para los t√≠tulos en los ejes ) Para solo eliminar el marco se puede usar frame=FALSE y para eliminar alguno de los ejes con xaxt=\"n\" o yaxt=\"n\". A√∫n se puede dar una mejor presentaci√≥n modificando el tipo de fuente plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presi√≥n&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes col.axis = &quot;#284c73&quot;, # Color para las anotaciones en los ejes fg = &quot;#9fb3c9&quot;, # Color para otros elementos gr√°ficos como los ejes type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo cex.lab = 1.1, # Tama√±o para los t√≠tulos en los ejes cex.axis = .8, # Tama√±o para los ejes font.axis = 1, # Formato para los ejes font.lab = 3, # Formato para los t√≠tulos en los ejes font.main = 4, # Formato para el t√≠tulo font.sub = 3, # Formato para el sub t√≠tulo family = &quot;Fira Sans Condensed&quot; ) Muchos de los argumentos anteriores no son espec√≠ficamente de la funci√≥n plot(), ya que dicha funci√≥n solo solicita la informaci√≥n para los ejes \\(x\\) y \\(y\\) y lo dem√°s es opcional mediante el argumento ... en el cual se pueden agregar opciones de texto y par√°metros gr√°ficos. De los anteriores las opciones de texto son los par√°metros main, sub, xlab y ylab. El tipo de gr√°fico no es exclusivamente un graphical parameter para todas las gr√°ficas, si no que es para la funci√≥n plot() en general. Los dem√°s argumentos son graphical parameters los cuales pueden ser usados en otros tipos de gr√°ficos. La gr√°fica se ve bien aunque se puede mejorar el aspecto de los ejes con la funci√≥n axis(). Para usar la funci√≥n axis primero se deben eliminar los ejes. plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presi√≥n&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo cex.lab = 1.1, # Tama√±o para los t√≠tulos en los ejes font.lab = 3, # Formato para los t√≠tulos en los ejes font.main = 4, # Formato para el t√≠tulo font.sub = 3, # Formato para el sub t√≠tulo family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) Para aclarar, el argumento side hace referencia al eje que se esta modificando, 1-below, 2-left, 3-above y 4-right. La funci√≥n axis tiene m√°s argumentos como lyt para indicar el tipo de l√≠nea sobre el eje y col para el color del eje. ¬øQu√© pasa cuando en tck se da un valor negativo? Ahora, si se desea agregar texto en la gr√°fica se puede usar la funci√≥n text() plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo xlab=&quot;Temperatura&quot;, # Eje x ylab=&quot;Presi√≥n&quot;, # Eje y col.lab = &quot;#284c73&quot;, #Color para los nombres dados en los ejes type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo cex.lab = 1.1, # Tama√±o para los t√≠tulos en los ejes font.lab = 3, # Formato para los t√≠tulos en los ejes font.main = 4, # Formato para el t√≠tulo font.sub = 3, # Formato para el sub t√≠tulo family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,810, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot; ) La funci√≥n tex() tiene otro argumento, pos, que modifican la posici√≥n del texto de acuerdo a las coordenadas dadas. Con la funci√≥n mtext() se puede modificar el t√≠tulo de los ejes o mejor dicho en cada margen de la gr√°fica con la ventaja de manipular el margen entre los ejes y los correspondientes t√≠tulos. plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo font.main = 4, # Formato para el t√≠tulo font.sub = 3, # Formato para el sub t√≠tulo family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,810, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot; ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presi√≥n&quot;, line=2.4, #Agregar margen family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Ahora, se desear√≠a que la etiqueta de ‚ÄúPresi√≥n m√°xima‚Äù apuntar√° hacia el valor m√°ximo con una flecha, adem√°s de agregar lineas para ubicar mejor las proyecciones en los ejes de dicho valor. Esto se puede lograr con las funciones arrow() y abline() plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo font.main = 4, # Formato para el t√≠tulo font.sub = 3, # Formato para el sub t√≠tulo family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,810, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posici√≥n dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presi√≥n&quot;, line=2.4, #Agregar margen family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) arrows(270,810, #Posici√≥n de inicio max(pressure$temperature)-5, max(pressure$pressure), #Posici√≥n de t√©rmino col = &quot;grey50&quot;, lwd = 1.2 #Ancho de la l√≠nea ) abline(h = max(pressure$pressure), #h es especial para l√≠neas horizontales col = &quot;gray73&quot;, lty = 3) abline(v = max(pressure$temperature),#v es especial para l√≠neas horizontales col = &quot;gray73&quot;, lty = 3) A la funci√≥n abline() tambi√©n se le puede dar la informaci√≥n en la forma \\(ax+b\\) donde el argumento a sirve para establecer la pendiente y b para el intercepto. V√©ase que las rectas dibujadas con la funci√≥n abline() cubren todo el rango de ambos ejes y en este caso se desea que estas terminen cuando lleguen a la coordenada espec√≠fica, para eso se utilizar√° la funci√≥n segments() donde sus argumentos indican las coordenadas de inicio y de final. Adem√°s el dise√±o de la flecha puede mejorar con shape::Arrows. library(shape) plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal col.main = &quot;#0e608f&quot;, # Color para el t√≠tulo sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo col.sub= &quot;grey50&quot;, # Color para el sub t√≠tulo xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo font.main = 4, # Formato para el t√≠tulo font.sub = 3, # Formato para el sub t√≠tulo family = &quot;Fira Sans Condensed&quot;, axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot;, cex.axis = .8, font.axis = 1, family = &quot;Fira Sans Condensed&quot; ) text(270,648, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, family = &quot;Fira Sans Condensed&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posici√≥n dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presi√≥n&quot;, line=2.4, #Agregar margen family = &quot;Fira Sans Condensed&quot;, cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posici√≥n de inicio max(pressure$temperature), max(pressure$pressure), #Posici√≥n de t√©rmino arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) Todos los par√°metros gr√°ficos se podr√≠an haber incluido directamente con la funci√≥n par(). En el siguiente ejemplo se ve como dicha funci√≥n ahorra c√≥digo. Hay que tener en cuenta que aveces es bueno hacer una copia donde no se tengan los par√°metros gr√°ficos alterados, esto guardando el estado actual de estos: par_default &lt;- par()y despu√©s llamando par(par_default). par(col.main = &quot;#0e608f&quot;, col.sub= &quot;grey50&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8 ) plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posici√≥n dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presi√≥n&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posici√≥n de inicio max(pressure$temperature), max(pressure$pressure), #Posici√≥n de t√©rmino arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) Se puede utilizar la funci√≥n par() para algunas caracter√≠sticas especiales como cambiar el color de fondo (background) de la gr√°fica con bg par(bg=&quot;#daeff5&quot;, col.main = &quot;#0e608f&quot;, col.sub= &quot;grey50&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8 ) plot(pressure ~ temperature, data=pressure, main = &quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, # T√≠tulo principal sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.main = 1.3, # Tama√±o para el t√≠tulo cex.sub = .8, # Tama√±o para el sub t√≠tulo axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posici√≥n dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presi√≥n&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posici√≥n de inicio max(pressure$temperature), max(pressure$pressure), #Posici√≥n de t√©rmino arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) Si se desea solo colorear el fondo del plano coordenado, v√©ase el ejemplo que se da en el siguiente link. Tambi√©n se pueden crear matrices de gr√°ficas, esto gracias al par√°metro mfrow par(mfrow=c(1,2), oma = c(0, 0, 2, 0)) par(bg=&quot;#daeff5&quot;, col.sub= &quot;grey50&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8 ) plot(pressure ~ temperature, data=pressure, sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.sub = .8, # Tama√±o para el sub t√≠tulo axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posici√≥n dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presi√≥n&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posici√≥n de inicio max(pressure$temperature), max(pressure$pressure), #Posici√≥n de t√©rmino arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) plot(pressure ~ temperature, data=pressure, sub=&quot;Ejemplo 1&quot;, # Sub t√≠tulo xlab=NA, ylab=NA, type = &quot;o&quot;, # Tipo de gr√°fico pch= 24, # s√≠mbolo para dibujar las observaciones col= &quot;#0b3666&quot;,# Color para los anteriores s√≠mbolos y lineas bg= &quot;#12b587&quot;, # Color de relleno de los anteriores elementos lty = 3, #Tipo de l√≠neas lwd = 2, # Ancho de las l√≠neas cex.sub = .8, # Tama√±o para el sub t√≠tulo axes=FALSE ) axis(side = 1, #Indicando el eje al que se le aplicar√° dise√±o at = c(-15,seq(0, 360, 45), 380), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0, 360, 45), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -40,# Coordenada para indicar donde se intersecta con el otro eje las = 0, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) axis(side = 2, #Indicando el eje al que se le aplicar√° dise√±o at = c(-40, seq(0,810, 162), 840), #Se indica donde se dar√°n las etiquetas labels = c(NA, seq(0,810, 162), NA), # Se dan expl√≠citamente las anotaciones en los ejes (en los tickmarks) pos = -15,# Coordenada para indicar donde se intersecta con el otro eje las = 2, # 0 para un eje paralelo y 2 para uno perpendicular tck = 0.03, # Ajuste de longitud de los ticks. col.axis = &quot;#284c73&quot;, fg = &quot;#9fb3c9&quot; #Color de los ticks y el marco de los ejes ) text(270,648, #Posici√≥n para el texto &quot;Presi√≥n m√°xima&quot;, cex = .8, font = 3, col = &quot;#7d522a&quot;, pos = 2 # Se coloca la etiqueta a la izquierda de la posici√≥n dada. ) mtext(side = 1,&quot;Temperatura&quot;, line=2.4, cex= 1.1, col = &quot;#284c73&quot;, font= 3 ) mtext(side = 2, #Al igual que con axis &quot;Presi√≥n&quot;, line=2.4, #Agregar margen cex= 1.1, col= &quot;#284c73&quot;, font= 3 ) Arrows(270,648, #Posici√≥n de inicio max(pressure$temperature), max(pressure$pressure), #Posici√≥n de t√©rmino arr.type=&quot;triangle&quot;, #Tipo de flecha arr.adj = 2, #Ajuste para que la punta de la flecha toque el punto seleccionado # arr.width=0.5, #Ancho de flecha arr.col = &quot;gray47&quot;,#color de la flecha col = &quot;grey50&quot;, lwd = 1.2 ) segments(max(pressure$temperature), -40, #Coordenadas del primer punto max(pressure$temperature), max(pressure$pressure), #Coordenadas del segundo punto col = &quot;gray73&quot;, lty = 3) segments(-15, max(pressure$pressure), max(pressure$temperature), max(pressure$pressure), col = &quot;gray73&quot;, lty = 3) mtext(&quot;Gr√°fico de dispersi√≥n y Lineas: Presi√≥n VS Temperatura&quot;, outer = TRUE, cex= 1.3,col = &quot;#0e608f&quot;,font = 4 ) El par√°metro oma es para modificar el margen exterior de la gr√°fica. Puede verse m√°s de esto y del argumento mar en los siguientes enlaces: Graph-gallery YaRrr Finalmente, un conjunto de funciones comunes para crear una matriz de dispersi√≥n par(bg = &quot;#e3e9ff&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8) pairs(iris, col = c(&quot;#865fd4&quot;, &quot;#b34769&quot;, &quot;#a19f4c&quot;)[ifelse(iris$Species==&quot;setosa&quot;, yes = 1, no = ifelse(iris$Species==&quot;versicolor&quot;, yes = 2, no = 3))]) Histograma, Gr√°fico de densidad, Pie Chart y Boxplot library(wesanderson) set.seed(20) datos_fic &lt;- c(sample(seq(1,2,by = 0.01), replace = T, size = 1000)) datos_fic_1 &lt;- sample(1:5, replace = T, size = 100) par(mfrow=c(2,2), bg = &quot;#e3e9ff&quot;, font.main = 4, font.sub = 3, family = &quot;Fira Sans Condensed&quot;, font.axis = 1, cex.axis = .8) hist(datos_fic, freq=TRUE, col = &quot;#2241b5&quot;, ylab = &quot;Frecuencia&quot;, main = &quot;Histograma de datos_fic&quot;) plot(density(datos_fic), col=&quot;#2241b5&quot;, main = &quot;Densidad de datos_fic&quot;, xlab = &quot;datos_fic&quot;, ylab = &quot;Densidad&quot;) pie(table(datos_fic_1), col=wes_palette(&quot;Rushmore1&quot;), clockwise=TRUE, main = &quot;Gr√°fico de pastel&quot;) boxplot(iris$Sepal.Length~iris$Species, col = c(&quot;#865fd4&quot;, &quot;#b34769&quot;, &quot;#a19f4c&quot;), xlab = &quot;Especies&quot;, ylab = &quot;Longitud del S√©palo&quot;, main = &quot;Boxplots por especie&quot;) 3.7.0.1 Comentarios finales A√∫n falta mucho por ver. Existen paquetes especiales para obtener colores. Se pueden agregar colores de tipo gradiente. Se pueden crear mapas. Existen muchas m√°s gr√°ficas estad√≠sticas. Se pueden crear gr√°ficas en 3D. Se pueden crear gr√°ficas interactivas. Se pueden crear animaciones. invest√≠guese el paquete manipulate para poder manipular las gr√°ficas base de R de manera m√°s interactiva. Adem√°s de saber crear gr√°ficas, hay que tener conocimiento sobre cuando y cuales usar. Aqu√≠ se dejan algunos enlaces que pueden ser de inter√©s: 15 questions about r plots. RGraphics-Paul Murell. Rgraphics-Chapter1. Advance graphics with R. Ejercicios Es algo tedioso estar copiando y pegando el mismo contenido para hacer una gr√°fica. Investiga una forma para guardar una gr√°fica como las vistas en esta secci√≥n como un objeto para usarlo posteriormente. Investiga como agregar una leyenda en la siguiente gr√°fica x&lt;-1:40; square = x^2; fourth = x^4 plot(x, square, type=&quot;b&quot;, col=&quot;#cc5252&quot;, xlab=&quot;x&quot;, ylab=&quot;y&quot;, pch=19) lines(x, fourth, pch=19, col=&quot;#e0773f&quot;, type=&quot;b&quot;) Investiga la funci√≥n expression() para agregar en la anterior gr√°fica las respectivas ecuaciones (\\(y = x^2\\), \\(y = x^4\\)). Crear una gr√°fica donde se tenga el histograma y la gr√°fica de densidad para el siguiente vector num√©rico: rnorm(1000, 5, 0.4). En la gr√°fica anterior, agrega con la funci√≥n curve() la ecuaci√≥n del ejercicio 50 con \\(\\mu = 5\\) y \\(\\sigma = 0.4\\) Se puede agregar texto en una gr√°fica con el estilo de Latex, es decir, en \\(esta \\ forma \\ junto \\ con \\ ecuaciones \\ como \\sum_{x = 20}^{40}x^2\\cdot\\log(x)\\). Lee el siguiente post y crea una gr√°fica agregando alguna ecuaci√≥n en ella. Escribe el c√≥digo necesario para crear la siguiente gr√°fica Escribe el c√≥digo necesario para crear la siguiente gr√°fica. Hint: Utiliza alguna de las funciones que se explican en Low-level plotting functions: YaRrr! The Pirate‚Äôs Guide to R Utiliza la funci√≥n curve para gr√°ficar la funci√≥n \\(sin(x)\\), \\(cos(x)\\) y \\(tan(x)\\) en una sola gr√°fica. El rango debe abarcar tanto n√∫meros negativos como positivos. Con las funciones rect(), polygon() y symbol(), crea la siguiente gr√°fica. Crea una gr√°fica con las siguientes ecuaciones par√°metricas con \\(t\\in[0,2\\pi]\\) \\[ \\begin{split} x &amp;= 16 cos^3(t)\\\\ y &amp;= 13 cos(t)-5cos(2t)-2cos(3t)-cos(4t) \\end{split} \\] Grafica 1000 puntos con dos vectores de n√∫meros pseudo aleatorios entre 0 y 1 y utiliza la funci√≥n rainbow para otorgarles color. Crea una representaci√≥n geom√©tricas de la integral \\(\\int_0^\\pi sen(x)dx\\) Crea una gr√°fica del las funciones \\(sen(x)\\) y \\(cos(x)\\) agregando anotaciones cada \\(\\frac{\\pi}{2}\\) e indicando que ecuaci√≥n corresponde a cada gr√°fica. Crea una gr√°fica para comparar las funciones \\(sen(x)\\), \\(2sen(x)\\) y \\(sen(\\frac{x}{2})\\). Crea una representaci√≥n geom√©trica de la funci√≥n \\(sen(x)\\) y \\(cos(x)\\) en una circunferencia. Referencias y bibliograf√≠a adicional Wickham and Grolemund. 2017. R for Data Science. https://r4ds.had.co.nz Versi√≥n en espa√±ol: https://es.r4ds.hadley.nz Grolemund, Garrett.2014. Hands-On Programming with R. https://rstudio-education.github.io/hopr/ Mendoza, Vega. R para principiantes. https://bookdown.org/jboscomendoza/r-principiantes4/ Wickham and Grolemund. 2019. Advanced R. Second Edition. https://adv-r.hadley.nz Chang, W. (2012). R graphics cookbook: practical recipes for visualizing data. \" O‚ÄôReilly Media, Inc.\". Rahlf, T. (2019). Data Visualisation with R: 111 Examples. Springer Nature. Murrell, P. (2018). R graphics. CRC Press. "],
["tidyverse.html", "Cap√≠tulo 4 Tidyverse", " Cap√≠tulo 4 Tidyverse La mayor√≠a del contenido visto en Introducci√≥n a R se ha enfocado al uso del lenguaje R y al uso de ciertas funciones sin considerar su rendimiento. Como bien se menciono en su momento, R no esta dise√±ado para ser r√°pido; lo que a trav√©s de los a√±os ha sido un tema de inter√©s a medida que la informaci√≥n aumenta y las necesidades por analizar y ejecutar procesos que traten con grandes cantidades de datos. Por tales razones, el uso de paquetes que est√©n dise√±ados para trabajar de manera eficiente ha sido fundamental en la mayor√≠a de lenguajes de programaci√≥n; tal es el caso del Tidyverse. Como bien se especifica en su p√°gina oficial, ‚ÄúThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures‚Äù. Estos paquetes est√°n enfocados a tener un mejor flujo de escritura, a tener un mejor entendimiento de la estructura de los procesos, dar funciones que solucionen problemas comunes y, como ya se menciono, mejorar el rendimiento de las funciones. Dentro de este conjunto de paquetes se encuentran funciones para leer distintos tipos de archivos como aquellos con extensi√≥n .csv y .xls, adem√°s aquellas para reconocer archivos dados por SPSS, Stata y SAS, manipular archivos JSON, XML, dar una interfaz para trabajar con APIs, hacer web scraping y tener comunicaci√≥n con diferentes administradores de bases de datos como SQL, MariaDB, etc. Se tienen paquetes especializados en la manipulaci√≥n y limpieza de datos, tambi√©n para crear modelos con estos, dar caracter√≠sticas especiales como catalogar y tratar a ciertas variables como fechas y factores, aplicar t√©cnicas de expresiones regulares en dichos datos, aplicar funciones optimizadas que pueden remplazar a las de la familia apply y crear gr√°ficas profesionales con una mayor fluidez. Aqu√≠ se ver√°n solo algunos de los paquetes que componen todo este ‚Äúuniverso limpio‚Äù y se comenzar√° con un operador fundamental proporcionado por el paquete magritt: %&gt;%, el cual se podr√° utilizar casi siempre en R. Dicho operador tiene por nombre pipe, el cual tiene un uso similar al dado en otros lenguajes de programaci√≥n como Python: . y bash: |. Este tiene como objetivo encadenar procesos de tal forma que el resultado dado en la cadena sirve como input del siguiente eslab√≥n en dicha cadena, lo cual ayuda a evitar el anidamiento de funciones, minimizar la cantidad de objetos locales y facilitar la lectura e implementaci√≥n de una secuencia de operaciones. Supongase que se desea resolver la tarea sencilla de aplicar una cantidad definida de operaciones sobre un n√∫mero; por ejemplo, obtener la ra√≠z cuadrada del logaritmo natural de un n√∫mero multiplicado por el cuadrado de otro, a dicho valor sumarlo con los primeros 10 naturales y, finalmente, obtener la ra√≠z cuadrada de dicho resultado. Esto se puede resolver de la siguiente manera; supongamos que los n√∫meros son 10 y 20. sqrt(sum(sqrt(log(prod(10, 20^2))), 1:10)) [1] 7.607887 En tal caso se tuvo que anidar las funciones para aplicar estas cada resultado obtenido. Con %&gt;% la soluci√≥n se ve de esta forma library(magrittr) 10 %&gt;% # 10 prod(20^2) %&gt;% #se multiplica por 20^2 log() %&gt;% #se obtiene el logaritmo de dicho n√∫mero sqrt() %&gt;% #Se obtiene la ra√≠z cuadrada sum(1:10) %&gt;% #A eso se le suman los primeros 10 naturales sqrt() #Se obtiene la ra√≠z cuadrada. [1] 7.607887 La anterior soluci√≥n tiene una estructura m√°s fiel a como se fue resolviendo el problema poco a poco sin tiene que escribir hacia la izquierda para aplicar resultados de funciones anidadas. M√°s adelante se ver√° que el uso de dicho operador resulta fundamental para ahorra tiempo al momento de escribir c√≥digo. Otro ejemplo: matrix(1:100, ncol = 5, byrow = 20) %&gt;% #Creaci√≥n de una matriz con los primeros 100 naturales. rowSums(10) %&gt;% #Se suma por rengl√≥n a√±adiendo 10 unidades a dicho resultado. as.matrix() %&gt;% #Se convierte dicho resultado a matriz. scale() %&gt;% #Se normalizan los datos. sum() #Se comprueba que estos sumen media cero. [1] 0 Como la mayor√≠a de la informaci√≥n que se utilizar√° se tendr√° que cargar con alguna librer√≠a, aqu√≠ se dejan algunos ejemplos de algunas funciones √∫tiles en la lectura de informaci√≥n. La funci√≥n read_csv() es una de las m√°s comunes para leer archivos separados por comas, en la cual se puede dar el path del archivo o la direcci√≥n URL de dichos datos. En este caso se esta utilizando unos datos donde se relaciona la informaci√≥n sobre exceso de velocidad de ciertos autom√≥viles y se√±ales de advertencia. Para m√°s informaci√≥n cons√∫ltese el siguiente enlace. .scroll-300 { max-height: 300px; } library(readr) library(tibble) (amis &lt;- readr::read_csv(&quot;Data/amis.csv&quot;) %&gt;% head(10)) # A tibble: 10 x 5 X1 speed period warning pair &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 26 1 1 1 2 2 26 1 1 1 3 3 26 1 1 1 4 4 26 1 1 1 5 5 27 1 1 1 6 6 28 1 1 1 7 7 28 1 1 1 8 8 28 1 1 1 9 9 28 1 1 1 10 10 29 1 1 1 readr::read_csv(&quot;https://vincentarelbundock.github.io/Rdatasets/csv/boot/amis.csv&quot;) %&gt;% head(10) # A tibble: 10 x 5 X1 speed period warning pair &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 26 1 1 1 2 2 26 1 1 1 3 3 26 1 1 1 4 4 26 1 1 1 5 5 27 1 1 1 6 6 28 1 1 1 7 7 28 1 1 1 8 8 28 1 1 1 9 9 28 1 1 1 10 10 29 1 1 1 En caso de que se desee leer un archivo por alg√∫n otro delimitador, se puede usar la funci√≥n read_delim() y en el caso de tener archivos donde el delimitador sea ‚Äú\\t‚Äù usar la funci√≥n read_tsv(). Los datos que se utilizan son proporcionados por el US Census Bureau, los cuales fueron indirectamente obtenidos del siguiente enlance. library(readxl) (US_Census_Bureau &lt;- readr::read_delim(&quot;Data/US Census Bureau.txt&quot;, delim = &quot;|&quot;)) # A tibble: 54 x 11 X1 `1900` `1901` `1902` `1903` `1904` `1905` `1906` `1907` `1908` `1909` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 U.S. 76094 77585 79160 80632 82165 83820 85437 87000 88709 90,492 2 Northe‚Ä¶ 21059 21401 21815 22248 22716 23214 23769 24320 24879 25,440 3 North_‚Ä¶ 26359 26722 27126 27446 27830 28203 28524 28868 29187 29,530 4 South 24565 25114 25599 26055 26492 27003 27475 27879 28406 28,963 5 West 4112 4351 4620 4882 5127 5398 5671 5934 6234 6,557 6 AL 1830 1907 1935 1957 1978 2012 2045 2058 2070 2,108 7 AR 1314 1341 1360 1384 1419 1447 1465 1484 1513 1,545 8 AZ 124 131 138 144 151 158 167 176 186 196 9 CA 1490 1550 1623 1702 1792 1893 1976 2054 2161 2,282 10 CO 543 581 621 652 659 680 707 733 757 775 # ‚Ä¶ with 44 more rows read_tsv(&quot;Data/US Census Bureautsv.txt&quot;) # A tibble: 54 x 11 X1 `1900` `1901` `1902` `1903` `1904` `1905` `1906` `1907` `1908` `1909` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 U.S. 76094 77585 79160 80632 82165 83820 85437 87000 88709 90,492 2 Northe‚Ä¶ 21059 21401 21815 22248 22716 23214 23769 24320 24879 25,440 3 North_‚Ä¶ 26359 26722 27126 27446 27830 28203 28524 28868 29187 29,530 4 South 24565 25114 25599 26055 26492 27003 27475 27879 28406 28,963 5 West 4112 4351 4620 4882 5127 5398 5671 5934 6234 6,557 6 AL 1830 1907 1935 1957 1978 2012 2045 2058 2070 2,108 7 AR 1314 1341 1360 1384 1419 1447 1465 1484 1513 1,545 8 AZ 124 131 138 144 151 158 167 176 186 196 9 CA 1490 1550 1623 1702 1792 1893 1976 2054 2161 2,282 10 CO 543 581 621 652 659 680 707 733 757 775 # ‚Ä¶ with 44 more rows El paquete readxl esta dise√±o para leer archivos excel. La siguiente informaci√≥n proporciona la poblaci√≥n por sexo y entidad federativa seg√∫n grupos de edad quinquenales de acuerdo a los tabulados b√°sicos de la CONAPO. (Population_FEntity &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B5:Q38&quot;)) # A tibble: 33 x 16 ...1 ...2 `0 a 4` `5 a 9` `10 a 14` `15 a 19` `20 a 24` `25 a 29` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Rep√∫‚Ä¶ 1.03e8 9.31 10.4 11.2 10.1 8.33 7.33 2 Agua‚Ä¶ 1.07e6 10.3 11.0 11.1 10.9 8.27 7.34 3 Baja‚Ä¶ 2.86e6 9.41 10.3 11.1 10.7 8.43 7.82 4 Baja‚Ä¶ 5.12e5 9.00 8.44 10.1 10.8 8.75 7.37 5 Camp‚Ä¶ 7.56e5 8.34 10.4 12.7 9.52 9.23 7.74 6 Coah‚Ä¶ 2.50e6 9.78 10.1 10.6 9.96 8.31 7.11 7 Coli‚Ä¶ 5.69e5 8.09 8.43 10.0 11.0 9.29 7.11 8 Chia‚Ä¶ 4.29e6 11.4 11.8 13.2 11.0 9.16 7.15 9 Chih‚Ä¶ 3.24e6 7.83 10.2 11.0 9.49 7.71 6.03 10 Dist‚Ä¶ 8.74e6 7.82 8.82 8.09 8.19 7.86 7.89 # ‚Ä¶ with 23 more rows, and 8 more variables: `30 a 34` &lt;dbl&gt;, `35 a 39` &lt;dbl&gt;, # `40 a 44` &lt;dbl&gt;, `45 a 49` &lt;dbl&gt;, `50 a 54` &lt;dbl&gt;, `55 a 59` &lt;dbl&gt;, `60 y # m√°s` &lt;dbl&gt;, NE &lt;dbl&gt; Algo que hay que tener en cuenta al trabajar con los paquetes del tidyverse es el uso de tibbles en lugar de data frames. class(amis) [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Un tibble es una versi√≥n moderna de un data frame que trabaja de manera perezosa (es decir, que realiza menos operaciones) evitando problemas comunes y supuestos que un data frame puede llegar a asumir. Por ejemplo, los tibbles no coercionan autom√°ticamente los caracteres a factores, no crean nombres para las observaciones y no cambia los nombres de columnas que sean nombres no sint√°cticos, por ejemplo tibble(&quot;:)&quot; = &quot;feliz&quot;, &quot;:(&quot;=&quot;triste&quot;) # A tibble: 1 x 2 `:)` `:(` &lt;chr&gt; &lt;chr&gt; 1 feliz triste data.frame(&quot;:)&quot; = &quot;feliz&quot;, &quot;:(&quot;=&quot;triste&quot;) X.. X...1 1 feliz triste Se pueden utilizar variables desde la construcci√≥n del tibble (t &lt;- tibble(x = 1:20, y = x-1)) # A tibble: 20 x 2 x y &lt;int&gt; &lt;dbl&gt; 1 1 0 2 2 1 3 3 2 4 4 3 5 5 4 6 6 5 7 7 6 8 8 7 9 9 8 10 10 9 11 11 10 12 12 11 13 13 12 14 14 13 15 15 14 16 16 15 17 17 16 18 18 17 19 19 18 20 20 19 ¬øQu√© sucede al ejecutar data.frame(x = 1:20, y = x-1)? Adem√°s se tienen diferencias respecto a la impresi√≥n entre un tibble y un data frame, un tibble permite agregar listas directamente sin tener que usar la funci√≥n I() y los tibbles nunca hacen emparejamiento parcial. t2 &lt;- tibble(xy=1:20, z = 1:20) d2 &lt;- data.frame(xy = 1:20, z = 1:20) str(t2$x) NULL str(d2$x) int [1:20] 1 2 3 4 5 6 7 8 9 10 ... Finalmente, los tibbles permiten hacer substracciones con el operador pipe. #t$x t %&gt;% .$x [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #t[[&quot;x&quot;]] t %&gt;% .[[&quot;x&quot;]] [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ¬øQu√© hace la funci√≥n tribble()? "],
["limpieza-de-datos-tidyr.html", "Cap√≠tulo 5 Limpieza de datos: Tidyr", " Cap√≠tulo 5 Limpieza de datos: Tidyr En un an√°lisis de datos, gran parte del tiempo que se utiliza es dando un grado de limpieza a estos, para as√≠ ya solo obtener informaci√≥n resumen, aplicar modelos o manipularlos para descubrir algo en ellos. De acuerdo a las fuentes que se consulten, esto puede tomar hasta un 80% del tiempo que se dispone, por lo que es evidente la necesidad de tener funciones que ayuden con dicha tarea. La limpieza de datos var√≠a dependiendo de los fines, pero para Hadley Wickham (Chief Scientist en RStudio y alguien importante en desarrollo y mantenimiento del tidyverse) tener una limpieza en los datos requiere de ciertas caracter√≠sticas. La informaci√≥n completa se puede encontrar en art√≠culo de Hadley, Tidy Data, pero b√°sicamente se tienen 3 puntos importantes para considerar que los datos son limpios. Cada variable forma una columna. Cada observaci√≥n forma un rengl√≥n. Cada valor debe tener su propia celda. Las siguientes gr√°ficas representan dichos puntos sobre un subconjunto de Iris. * { box-sizing: border-box; } .column { float: left; width: 33.33%; padding: 5px; } /* Clearfix (clear floats) */ .row::after { content: \"\"; clear: both; display: table; } Con lo anterior establecido y suponiendo que se esta analizando una peque√±a base de datos correspondientes a las calificaciones de ciertos alumnos ¬øCu√°l de las siguientes estructuras es correcta? Colocando las observaciones respecto a los nombres Matem√°ticas Qu√≠mica Juan 8 9 Carlos 9 7 Luis 7 8 Allison 9 9 Leticia 8 9 Colocando las observaciones respecto a la materia Juan Carlos Luis Allison Leticia Matem√°ticas 8 9 7 9 8 Qu√≠mica 9 7 8 9 9 De hecho, ninguna de las dos opciones anteriores es correcta. De acuerdo a los principios anteriores para tener datos limpios, cada variable debe formar una columna, lo cual no sucede en este caso, ya que las variables aqu√≠ son estudiante o el nombre, la materia y las calificaciones. Es decir, que las configuraci√≥n correcta es la siguiente Nombre Asignatura Calificaciones Juan Matem√°ticas 8 Carlos Matem√°ticas 9 Luis Matem√°ticas 7 Allison Matem√°ticas 9 Leticia Matem√°ticas 8 Juan Qu√≠mica 9 Carlos Qu√≠mica 7 Luis Qu√≠mica 8 Allison Qu√≠mica 9 Leticia Qu√≠mica 9 Esto es uno de los tantos ejemplos que se pueden dar cuando se trabajando con datos. En el momento en que se identifican estos problemas, se deber√° usar toda la creatividad para resolverlos y obtener una estructura con la que ya se pueda trabajar. El paquete tidyr ayudar√° con la mayor√≠a de estos. Como recomendaci√≥n, se aconseja tener a la mano siempre la respectiva Cheat Sheet que pueda ser de utilidad, en este caso de la librer√≠a tidyr se pueden consultar Data import y Data Wrangling; las respectivas traducciones al espa√±ol se pueden encontrar en la p√°gina oficial de Cheat Sheets de RStudio. Como bien dice Hadley en Tidy Data, hay cinco problemas comunes en los messy datasets: Los encabezados son valores y no nombres de dichas variables. M√∫ltiples variables est√°n contenidas en una sola. Existen variables que est√°n almacenadas tanto en renglones como columnas. M√∫ltiples tipos de observaciones est√°n en la misma tabla. Una sola observaci√≥n esta en m√∫ltiples tablas. En la secci√≥n anterior se presentaron los datos para la poblaci√≥n por sexo y entidad federativa seg√∫n grupos de edad quinquenales de acuerdo a los tabulados b√°sicos de la CONAPO .scroll-300 { max-height: 300px; } colnames(Population_FEntity)[1:2] &lt;- c(&quot;Entidad Federativa&quot;, &quot;Poblaci√≥n Total&quot;) Population_FEntity # A tibble: 33 x 16 `Entidad Federa‚Ä¶ `Poblaci√≥n Tota‚Ä¶ `0 a 4` `5 a 9` `10 a 14` `15 a 19` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Rep√∫blica Mexic‚Ä¶ 103498524 9.31 10.4 11.2 10.1 2 Aguascalientes 1066233 10.3 11.0 11.1 10.9 3 Baja California 2856361 9.41 10.3 11.1 10.7 4 Baja California‚Ä¶ 512030 9.00 8.44 10.1 10.8 5 Campeche 755703 8.34 10.4 12.7 9.52 6 Coahuila 2501413 9.78 10.1 10.6 9.96 7 Colima 568642 8.09 8.43 10.0 11.0 8 Chiapas 4293414 11.4 11.8 13.2 11.0 9 Chihuahua 3241513 7.83 10.2 11.0 9.49 10 Distrito Federal 8737172 7.82 8.82 8.09 8.19 # ‚Ä¶ with 23 more rows, and 10 more variables: `20 a 24` &lt;dbl&gt;, `25 a 29` &lt;dbl&gt;, # `30 a 34` &lt;dbl&gt;, `35 a 39` &lt;dbl&gt;, `40 a 44` &lt;dbl&gt;, `45 a 49` &lt;dbl&gt;, `50 a # 54` &lt;dbl&gt;, `55 a 59` &lt;dbl&gt;, `60 y m√°s` &lt;dbl&gt;, NE &lt;dbl&gt; En las primeras dos columnas se cambiaron los nombres con las herramientas que hasta este momento se tienen. V√©ase que las dem√°s columnas representan rangos de edad, por lo que se tiene el primer problema en los messy datasets. De hecho, en estos datos las variables son la Entidad Federativa, la Poblaci√≥n Total, el Rango de Edad y el Porcentaje de la poblaci√≥n total en ese rango de edad. En estos casos se dice los datos son anchos, y lo que se desea es que estos est√©n en un formato largo (ancho por la cantidad de columnas y largo por la cantidad de observaciones). Para tales casos se utiliza la funci√≥n tidyr::gather() la cual recibe como par√°metros m√∫ltiples columnas y colapsa la informaci√≥n de estas en dos variables. (Population_FEntity &lt;- gather(data = Population_FEntity, key = &quot;Rango_edad&quot;, value = &quot;Porcentaje&quot;, -c(&quot;Entidad Federativa&quot;, &quot;Poblaci√≥n Total&quot;))) # A tibble: 462 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Rep√∫blica Mexicana 103498524 0 a 4 9.31 2 Aguascalientes 1066233 0 a 4 10.3 3 Baja California 2856361 0 a 4 9.41 4 Baja California Sur 512030 0 a 4 9.00 5 Campeche 755703 0 a 4 8.34 6 Coahuila 2501413 0 a 4 9.78 7 Colima 568642 0 a 4 8.09 8 Chiapas 4293414 0 a 4 11.4 9 Chihuahua 3241513 0 a 4 7.83 10 Distrito Federal 8737172 0 a 4 7.82 # ‚Ä¶ with 452 more rows Con lo anterior se logro tener una mejor estructura en los datos, con lo cual f√°cilmente se podr√≠an crear gr√°ficas, modelos y estad√≠sticas de resumen por Entidad Federativa o por rango de edad. Despu√©s de tener la informaci√≥n con una estructura adecuada, la imaginaci√≥n es el √∫nico limitante. En el siguiente cap√≠tulo se ver√° como manipular internamente los datos para que se tenga una mejor sem√°ntica en ellos. Si se desea por alg√∫n motivo, lo cual puede suceder, tener los datos en formato ancho, se puede usar la funci√≥n complementaria la cual es tidyr::spread() Population_FEntity %&gt;% spread(key = &quot;Rango_edad&quot;,value = &quot;Porcentaje&quot;) # A tibble: 33 x 16 `Entidad Federa‚Ä¶ `Poblaci√≥n Tota‚Ä¶ `0 a 4` `10 a 14` `15 a 19` `20 a 24` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 10.3 11.1 10.9 8.27 2 Baja California 2856361 9.41 11.1 10.7 8.43 3 Baja California‚Ä¶ 512030 9.00 10.1 10.8 8.75 4 Campeche 755703 8.34 12.7 9.52 9.23 5 Chiapas 4293414 11.4 13.2 11.0 9.16 6 Chihuahua 3241513 7.83 11.0 9.49 7.71 7 Coahuila 2501413 9.78 10.6 9.96 8.31 8 Colima 568642 8.09 10.0 11.0 9.29 9 Distrito Federal 8737172 7.82 8.09 8.19 7.86 10 Durango 1509025 9.97 11.8 10.3 8.11 # ‚Ä¶ with 23 more rows, and 10 more variables: `25 a 29` &lt;dbl&gt;, `30 a 34` &lt;dbl&gt;, # `35 a 39` &lt;dbl&gt;, `40 a 44` &lt;dbl&gt;, `45 a 49` &lt;dbl&gt;, `5 a 9` &lt;dbl&gt;, `50 a # 54` &lt;dbl&gt;, `55 a 59` &lt;dbl&gt;, `60 y m√°s` &lt;dbl&gt;, NE &lt;dbl&gt; Finalmente: Un equivalente de la funci√≥n tidyr:: gather() la proporciona el paquete reshape con su funci√≥n melt(). Para la funci√≥n tidyr:: spread() se tiene la funci√≥n reshape::dcast(). Depende de la versi√≥n que se utilice, las funciones gather() y spread() podr√≠an haber sido remplazadas por las funciones tidyr::pivot_longer() y pivot_wider() respectivamente. En otros lenguajes de programaci√≥n, a estas t√©cnicas se les conoce como pivoteo. Para ver un ejemplo del segundo punto, sup√≥ngase que los datos vistos al inicio donde se relacionaban las calificaciones de ciertos alumnos tienen originalmente la siguiente estructura # A tibble: 10 x 2 Nombre `A/C` &lt;chr&gt; &lt;chr&gt; 1 Juan M8 2 Carlos M9 3 Luis M7 4 Allison M9 5 Leticia M8 6 Juan Q9 7 Carlos Q7 8 Luis Q8 9 Allison Q9 10 Leticia Q9 En tal caso, la segunda variable contiene la informaci√≥n tanto de la materia como de la calificaci√≥n. Aqu√≠ la funci√≥n tidyr::separate() es de gran ayuda (Student_grades &lt;- Student_grades %&gt;% separate(col = &quot;A/C&quot;, into = c(&quot;Asignatura&quot;, &quot;Calificaciones&quot;), sep = 1)) # A tibble: 10 x 3 Nombre Asignatura Calificaciones &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Juan M 8 2 Carlos M 9 3 Luis M 7 4 Allison M 9 5 Leticia M 8 6 Juan Q 9 7 Carlos Q 7 8 Luis Q 8 9 Allison Q 9 10 Leticia Q 9 En el argumento sep se da la posici√≥n dentro del texto para separar los datos. En el caso en que se desee tener el caso inverso, se utiliza la funci√≥n tidyr::unite() Student_grades %&gt;% unite(&quot;A/C&quot;, c(&quot;Asignatura&quot;, &quot;Calificaciones&quot;), sep = &quot;&quot;) # A tibble: 10 x 2 Nombre `A/C` &lt;chr&gt; &lt;chr&gt; 1 Juan M8 2 Carlos M9 3 Luis M7 4 Allison M9 5 Leticia M8 6 Juan Q9 7 Carlos Q7 8 Luis Q8 9 Allison Q9 10 Leticia Q9 Otro ejemplo lo proporciona la Cheat Sheet Data Wrangling. # A tibble: 10,010 x 11 name date hour lat long status category wind pressure ts_diameter &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 Amy 1975‚Ä¶ 0 27.5 -79 tropi‚Ä¶ -1 25 1013 NA 2 Amy 1975‚Ä¶ 6 28.5 -79 tropi‚Ä¶ -1 25 1013 NA 3 Amy 1975‚Ä¶ 12 29.5 -79 tropi‚Ä¶ -1 25 1013 NA 4 Amy 1975‚Ä¶ 18 30.5 -79 tropi‚Ä¶ -1 25 1013 NA 5 Amy 1975‚Ä¶ 0 31.5 -78.8 tropi‚Ä¶ -1 25 1012 NA 6 Amy 1975‚Ä¶ 6 32.4 -78.7 tropi‚Ä¶ -1 25 1012 NA 7 Amy 1975‚Ä¶ 12 33.3 -78 tropi‚Ä¶ -1 25 1011 NA 8 Amy 1975‚Ä¶ 18 34 -77 tropi‚Ä¶ -1 30 1006 NA 9 Amy 1975‚Ä¶ 0 34.4 -75.8 tropi‚Ä¶ 0 35 1004 NA 10 Amy 1975‚Ä¶ 6 34 -74.8 tropi‚Ä¶ 0 40 1002 NA # ‚Ä¶ with 10,000 more rows, and 1 more variable: hu_diameter &lt;dbl&gt; separate(storms, col = date ,into = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), sep = c(4, 5)) # A tibble: 10,010 x 13 name year month day hour lat long status category wind pressure &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; 1 Amy 1975 6 27 0 27.5 -79 tropi‚Ä¶ -1 25 1013 2 Amy 1975 6 27 6 28.5 -79 tropi‚Ä¶ -1 25 1013 3 Amy 1975 6 27 12 29.5 -79 tropi‚Ä¶ -1 25 1013 4 Amy 1975 6 27 18 30.5 -79 tropi‚Ä¶ -1 25 1013 5 Amy 1975 6 28 0 31.5 -78.8 tropi‚Ä¶ -1 25 1012 6 Amy 1975 6 28 6 32.4 -78.7 tropi‚Ä¶ -1 25 1012 7 Amy 1975 6 28 12 33.3 -78 tropi‚Ä¶ -1 25 1011 8 Amy 1975 6 28 18 34 -77 tropi‚Ä¶ -1 30 1006 9 Amy 1975 6 29 0 34.4 -75.8 tropi‚Ä¶ 0 35 1004 10 Amy 1975 6 29 6 34 -74.8 tropi‚Ä¶ 0 40 1002 # ‚Ä¶ with 10,000 more rows, and 2 more variables: ts_diameter &lt;dbl&gt;, # hu_diameter &lt;dbl&gt; Se tiene un equivalente para separar en renglones: tidyr::separate_rows() Un equivalente la funci√≥n separate() esta dada por reshape::colsplit(). En el caso que se tenga el problema donde algunas variables esten almacenadas tanto en renglones como columnas se debe tratar el problema como lo anterior visto, primero abstraerse al problema de juntar las columnas necesarias en dos variables con la funci√≥n gather() para posteriormente separar las variables que lo requieran con la funci√≥n separate(). Para los √∫ltimos dos casos se necesita hacer uso de unas funciones del paquete dplyr, el cual ser ver√° en la siguiente secci√≥n. Por el momento, se pueden ver otras funciones √∫tiles de tidyr, como aquellas que ayudan en la obtenci√≥n de diferentes operaciones de conjuntos en los datos. df &lt;- data_frame(x = 1:2, y = 2:1) tidyr::expand_grid(df, z = 1:3) # A tibble: 6 x 3 x y z &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 1 2 1 2 1 2 2 3 1 2 3 4 2 1 1 5 2 1 2 6 2 1 3 La funci√≥n tidyr::expand_grid() crea un tibble de todas las combinaciones de sus inputs, estos pueden ser data frames o tibbles, matrices y hasta vectores. Se puede entender a esta funci√≥n como el producto cartesiano de dos conjuntos. x &lt;- data_frame(x = letters[5:7]) y &lt;- data_frame(c(3,3,1)) crossing(x, y) # A tibble: 6 x 2 x `c(3, 3, 1)` &lt;chr&gt; &lt;dbl&gt; 1 e 1 2 e 3 3 f 1 4 f 3 5 g 1 6 g 3 La funci√≥n tidyr::crossing() regresa un tibble y tiene un comportamiento similar a expand_grid() con la diferencia de eliminar registros duplicados. set.seed(20) x &lt;- data_frame(sample(letters[1:3], size = 5, replace = T)) y &lt;- data_frame(y = sample(1:3, size = 5, replace = T)) tidyr::nesting(x, y) # A tibble: 4 x 2 `sample(letters[1:3], size = 5, replace = T)` y &lt;chr&gt; &lt;int&gt; 1 a 1 2 b 2 3 c 1 4 c 2 La funci√≥n tidyr::nesting() encuentra las posibles combinaciones entre los datos, es decir, las combinaciones entre los datos de entrada si estos se unieran en uno solo. set.seed(20) reduced_iris &lt;- iris %&gt;% head() df &lt;- reduced_iris[sample(1:6, size = 10, replace = T),] df %&gt;% tidyr::expand(Petal.Length) # A tibble: 3 x 1 Petal.Length &lt;dbl&gt; 1 1.3 2 1.4 3 1.7 La funci√≥n tidyr::expand() genera todas las combinaciones de variables que se encuentran en un data set. ¬øQu√© sucede al ejecutar df %&gt;% tidyr::expand(Sepal.Width, Petal.Width)? ¬øY al ejecutar df %&gt;% tidyr::expand(nesting(Sepal.Width, Petal.Width))? Otras funciones √∫tiles son las siguientes tidyr::nest(). Dicha funci√≥n anida un data frame o un subconjunto de este en listas y coloca estos como observaciones; esto puede ser muy √∫til en la aplicaci√≥n de modelos. tidyr::unnest(). Funci√≥n inversa a tidyr::nest(). tidyr::replace_na(). Dicha funci√≥n encuentra los valores perdidos en un data set y los cambia por un valor dado. Ejercicios En la secci√≥n Limpieza de datos: Tidyr se vieron varios ejemplos donde se mencionaba que estos ven√≠an como sugerencias de las respectivas Cheat Sheets. Dichos datos fueron manipulados para ver el uso de las funciones que se estaban presentando. Obt√©n la estructura de los datos a los cuales se les aplicaron dichas funciones. Investigar otras funciones de tidyr como chop(), complete() y pack(). "],
["manipulaci√≥n-de-datos-dplyr.html", "Cap√≠tulo 6 Manipulaci√≥n de datos: Dplyr", " Cap√≠tulo 6 Manipulaci√≥n de datos: Dplyr As√≠ como es de importante la limpieza en un an√°lisis de datos, lo es la manipulaci√≥n de estos, ya que la informaci√≥n que contienen debe ser extra√≠da y ser√° poco probable que se vean a simple vista. Para dichas tareas el paquete dplyr, parte del tidyverse, es una de las mejores opciones. dplyr tiene tres metas principales: Identificar los verbos de manipulaci√≥n m√°s importantes en la manipulaci√≥n de datos y hacerlos f√°cil de usar en R. Esto mediante un conjunto de funciones que se ver√°n en esta secci√≥n. Proporcionar un gran rendimiento en datos alojados en memoria utilizando c√≥digo en C++ mediante la librer√≠a Rcpp en sus funciones. Usar la misma interfaz para trabajar con los datos sin importar cuando y como est√©n almacenados (data frame, data table o en una base de datos). Para este paquete se puede obtener su Cheat Sheet oficial y es mencionada en otras como Data import y Data Wrangling. Tambi√©n se puede usar el comando vignette(\"dplyr\", package=\"dplyr\") para ver una gu√≠a con ejemplos de este paquete donde utilizan una base de datos de Star Wars obtenida directamente de su API. Para este caso, se tomar√° las bases de datos que ya se utilizaron en la secci√≥n anterior para ver el funcionamiento de algunas de las funciones de dplyr. "],
["dplyrfilter.html", "6.1 dplyr::filter()", " 6.1 dplyr::filter() Las funciones en dplyr son vectorizadas, por lo que podemos estar seguros que se esta trabajando de manera adecuada. Es com√∫n pensar en una funci√≥n vectorizada como un remplazo eficiente de un ciclo con una operaci√≥n dada; para este caso, filtrar un conjunto de datos puede ser tedioso mediante ciclos anidados y es lo que se puede remplazar con la funci√≥n dplyr::filter(). En la base de datos donde se re√∫ne la informaci√≥n correspondiente a la poblaci√≥n de M√©xico por rangos de edad quinquenales, es evidente que se puede obtener la poblaci√≥n total de todo el territorio con la suma de las cantidades dadas por cada estado, as√≠ que este registro ser√° eliminado. .scroll-300 { max-height: 300px; } (Population_FEntity &lt;- Population_FEntity %&gt;% filter(`Entidad Federativa`!=&quot;Rep√∫blica Mexicana&quot;)) # A tibble: 448 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 10.3 2 Baja California 2856361 0 a 4 9.41 3 Baja California Sur 512030 0 a 4 9.00 4 Campeche 755703 0 a 4 8.34 5 Coahuila 2501413 0 a 4 9.78 6 Colima 568642 0 a 4 8.09 7 Chiapas 4293414 0 a 4 11.4 8 Chihuahua 3241513 0 a 4 7.83 9 Distrito Federal 8737172 0 a 4 7.82 10 Durango 1509025 0 a 4 9.97 # ‚Ä¶ with 438 more rows V√©ase que dplyr::filter() utiliz√≥ la variable Entidad Federativa y elimino los registros que no cumplieran con la condici√≥n dada: !=\"Rep√∫blica Mexicana\", al igual que se hubiera hecho con un condicional if() en ciclos anidados. En esta funci√≥n se pueden aplicar los operados l√≥gicos conocidos ==, &lt;=, %in%, etc. Adem√°s de los operados de conjuntos como |, &amp; y xor(). En el siguiente ejemplo solo se toman aquellos estados donde el rango de edad sea 25 a 29 a√±os y tengan un porcentaje de su poblaci√≥n total en dicha edad entre 7.5 y 8.5. Population_FEntity %&gt;% filter(Rango_edad == &quot;25 a 29&quot; &amp; Porcentaje &gt;= 7.5 &amp; Porcentaje &lt; 8.5) # A tibble: 9 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Baja California 2856361 25 a 29 7.82 2 Campeche 755703 25 a 29 7.74 3 Distrito Federal 8737172 25 a 29 7.89 4 Jalisco 6754506 25 a 29 7.80 5 M√©xico 14174039 25 a 29 8.42 6 Nuevo Le√≥n 4199361 25 a 29 7.74 7 Quintana Roo 1135436 25 a 29 8.45 8 Tabasco 1991059 25 a 29 7.65 9 Yucat√°n 1820537 25 a 29 7.98 Como el resultado es un tibble, bien podr√≠a utilizarse las veces que se desee la funci√≥n utilizando %&gt;% a los resultados previos. En este caso no se tienen valores perdidos pero es bueno recordar que la funci√≥n is.na() regresa un vector booleano indicando si en el input dado se tienen valores perdidos, por lo que podr√≠a usarse con la funci√≥n filter() para detectar dichos valores de una manera r√°pida. Adem√°s de obtener un subconjunto de los datos con filter(), dplyr ofrece otras funciones √∫tiles para obtener un subconjunto espec√≠fico de datos. Obtener valores distintos en toda la base o por algunas variables espec√≠ficas: Population_FEntity %&gt;% distinct(`Entidad Federativa`) # A tibble: 32 x 1 `Entidad Federativa` &lt;chr&gt; 1 Aguascalientes 2 Baja California 3 Baja California Sur 4 Campeche 5 Coahuila 6 Colima 7 Chiapas 8 Chihuahua 9 Distrito Federal 10 Durango # ‚Ä¶ with 22 more rows set.seed(20) data_easy &lt;- tibble(x = sample(letters, 50, replace = TRUE), y = sample(1:25, 50, replace = TRUE)) data_easy %&gt;% distinct(y) # A tibble: 23 x 1 y &lt;int&gt; 1 1 2 15 3 6 4 2 5 10 6 20 7 23 8 22 9 7 10 3 # ‚Ä¶ with 13 more rows Obtener un porcentaje de los datos o un n√∫mero de observaciones de manera aleatoria: Population_FEntity %&gt;% sample_frac(0.01, replace = FALSE) # A tibble: 4 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Guanajuato 4894608 50 a 54 4.03 2 Chiapas 4293414 20 a 24 9.16 3 Nayarit 952230 15 a 19 10.7 4 Chiapas 4293414 30 a 34 6.28 Population_FEntity %&gt;% sample_n(4, replace = FALSE) # A tibble: 4 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Puebla 5386250 25 a 29 7.05 2 Nayarit 952230 0 a 4 9.86 3 Durango 1509025 25 a 29 6.55 4 Coahuila 2501413 55 a 59 3.31 Obtener renglones espec√≠ficos: Population_FEntity %&gt;% slice(1:3) # A tibble: 3 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 10.3 2 Baja California 2856361 0 a 4 9.41 3 Baja California Sur 512030 0 a 4 9.00 "],
["dplyrselect.html", "6.2 dplyr::select()", " 6.2 dplyr::select() La funci√≥n anterior s√≥lo trabaja con observaciones, por lo que tambi√©n debe existir un an√°logo para las variables, dicha funci√≥n es dplyr::select(), la cual permite un conjunto de funciones √∫tiles para hacer selecciones espec√≠ficas de variables. Population_FEntity %&gt;% select(`Entidad Federativa`, Rango_edad, Porcentaje) %&gt;% head() # A tibble: 6 x 3 `Entidad Federativa` Rango_edad Porcentaje &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 10.3 2 Baja California 0 a 4 9.41 3 Baja California Sur 0 a 4 9.00 4 Campeche 0 a 4 8.34 5 Coahuila 0 a 4 9.78 6 Colima 0 a 4 8.09 Lo anterior es equivalente a la siguiente instrucci√≥n: Population_FEntity %&gt;% select(!`Poblaci√≥n Total`) %&gt;% head() # A tibble: 6 x 3 `Entidad Federativa` Rango_edad Porcentaje &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 10.3 2 Baja California 0 a 4 9.41 3 Baja California Sur 0 a 4 9.00 4 Campeche 0 a 4 8.34 5 Coahuila 0 a 4 9.78 6 Colima 0 a 4 8.09 Utilizar el operando ! se indica que dicha variable no se desea observar, dicha instrucci√≥n se pudo haber sustituido con Population_FEntity %&gt;% select(-'Poblaci√≥n Total'). Tambi√©n se puede usar un rango de columnas con :. La funci√≥n select tiene algunas funciones auxiliares para trabajar con texto como el uso de expresiones regulares. Algunas de estas funciones son contains(), ends_with() y start_with(). Para el uso de este tipo de filtros en observaciones, v√©ase el paquete stringr. iris %&gt;% select(starts_with(&quot;Petal&quot;)) %&gt;% head() Petal.Length Petal.Width 1 1.4 0.2 2 1.4 0.2 3 1.3 0.2 4 1.5 0.2 5 1.4 0.2 6 1.7 0.4 Population_FEntity %&gt;% select(contains(&quot;_&quot;)) %&gt;% head() # A tibble: 6 x 1 Rango_edad &lt;chr&gt; 1 0 a 4 2 0 a 4 3 0 a 4 4 0 a 4 5 0 a 4 6 0 a 4 Finalmente, para obtener todas las columnas se puede usar la funci√≥n dplyr::everything(), para obtener variables donde sus nombres est√©n en un grupo dplyr::one_of y para seleccionar las variables por rango dplyr::num_range(). "],
["dplyrarrange.html", "6.3 dplyr::arrange()", " 6.3 dplyr::arrange() Para ordenar una variable de forma ascendente o descendente se utiliza la funci√≥n dplyr::arrange(). Al ordenar una variable, se ordenan todos los datos de acuerdo a esa variable de referencia. Population_FEntity %&gt;% arrange(`Entidad Federativa`) # A tibble: 448 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 10.3 2 Aguascalientes 1066233 5 a 9 11.0 3 Aguascalientes 1066233 10 a 14 11.1 4 Aguascalientes 1066233 15 a 19 10.9 5 Aguascalientes 1066233 20 a 24 8.27 6 Aguascalientes 1066233 25 a 29 7.34 7 Aguascalientes 1066233 30 a 34 7.85 8 Aguascalientes 1066233 35 a 39 6.23 9 Aguascalientes 1066233 40 a 44 5.19 10 Aguascalientes 1066233 45 a 49 5.49 # ‚Ä¶ with 438 more rows Adem√°s, se pueden ordenar los registros por m√∫ltiples variables. En este ejemplo se ordenan los datos de la poblaci√≥n mexicana por la Entidad Federativa y, de manera descendente, el porcentaje de la poblaci√≥n total por grupos quinquenales de edad. Population_FEntity %&gt;% arrange(`Entidad Federativa`, desc(Porcentaje)) # A tibble: 448 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 10 a 14 11.1 2 Aguascalientes 1066233 5 a 9 11.0 3 Aguascalientes 1066233 15 a 19 10.9 4 Aguascalientes 1066233 0 a 4 10.3 5 Aguascalientes 1066233 20 a 24 8.27 6 Aguascalientes 1066233 30 a 34 7.85 7 Aguascalientes 1066233 60 y m√°s 7.82 8 Aguascalientes 1066233 25 a 29 7.34 9 Aguascalientes 1066233 35 a 39 6.23 10 Aguascalientes 1066233 45 a 49 5.49 # ‚Ä¶ with 438 more rows "],
["dplyrmutate.html", "6.4 dplyr::mutate()", " 6.4 dplyr::mutate() La funci√≥n arrange() modific√≥ de una forma sutil los datos, s√≥lo el orden; pero en el caso de que se desee modificar o agregar una nueva variable, ya sea en funci√≥n de los valores de otra o nuevos valores independientes, se utiliza la funci√≥n dplyr::mutate(). Population_FEntity %&gt;% mutate(Var_fake = sample(1:50, size = 448, replace = TRUE)) # A tibble: 448 x 5 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje Var_fake &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 Aguascalientes 1066233 0 a 4 10.3 20 2 Baja California 2856361 0 a 4 9.41 11 3 Baja California Sur 512030 0 a 4 9.00 33 4 Campeche 755703 0 a 4 8.34 38 5 Coahuila 2501413 0 a 4 9.78 28 6 Colima 568642 0 a 4 8.09 3 7 Chiapas 4293414 0 a 4 11.4 16 8 Chihuahua 3241513 0 a 4 7.83 40 9 Distrito Federal 8737172 0 a 4 7.82 3 10 Durango 1509025 0 a 4 9.97 40 # ‚Ä¶ with 438 more rows En esta funci√≥n se pueden aplicar funciones ya pre-establecidas, adem√°s de window functions (v√©ase la Cheat Sheet Data Wrangling) que se pueden obtener de R o de dplyr como dplyr::lag() y dplyr::between(). V√©ase los siguientes ejemplos: Se modifica el porcentaje en t√©rminos correctos. Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) # A tibble: 448 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 0.103 2 Baja California 2856361 0 a 4 0.0941 3 Baja California Sur 512030 0 a 4 0.0900 4 Campeche 755703 0 a 4 0.0834 5 Coahuila 2501413 0 a 4 0.0978 6 Colima 568642 0 a 4 0.0809 7 Chiapas 4293414 0 a 4 0.114 8 Chihuahua 3241513 0 a 4 0.0783 9 Distrito Federal 8737172 0 a 4 0.0782 10 Durango 1509025 0 a 4 0.0997 # ‚Ä¶ with 438 more rows Se obtiene el porcentaje de poblaci√≥n que tiene cada entidad federativa correspondiente a toda la poblaci√≥n del pa√≠s. (Recordar que la poblaci√≥n total es 103,498,524) Population_FEntity %&gt;% mutate(Porcentaje_entidad = `Poblaci√≥n Total`/103498524) %&gt;% select(c(`Entidad Federativa`, `Poblaci√≥n Total`, Porcentaje_entidad)) # A tibble: 448 x 3 `Entidad Federativa` `Poblaci√≥n Total` Porcentaje_entidad &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0.0103 2 Baja California 2856361 0.0276 3 Baja California Sur 512030 0.00495 4 Campeche 755703 0.00730 5 Coahuila 2501413 0.0242 6 Colima 568642 0.00549 7 Chiapas 4293414 0.0415 8 Chihuahua 3241513 0.0313 9 Distrito Federal 8737172 0.0844 10 Durango 1509025 0.0146 # ‚Ä¶ with 438 more rows Se obtiene el porcentaje de la poblaci√≥n total que hay por grupo quinquenal. library(scales) Population_FEntity %&gt;% mutate(Porcentaje_entidad = `Poblaci√≥n Total`/103498524, Porcentaje = Porcentaje/100) %&gt;% mutate(Porcentaje_quinquenal_P = percent(Porcentaje*Porcentaje_entidad, accuracy = 0.01)) %&gt;% select(`Entidad Federativa`, Rango_edad, Porcentaje_quinquenal_P) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad Porcentaje_quinquenal_P &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Aguascalientes 0 a 4 0.11% 2 Baja California 0 a 4 0.26% 3 Baja California Sur 0 a 4 0.04% 4 Campeche 0 a 4 0.06% 5 Coahuila 0 a 4 0.24% 6 Colima 0 a 4 0.04% 7 Chiapas 0 a 4 0.47% 8 Chihuahua 0 a 4 0.25% 9 Distrito Federal 0 a 4 0.66% 10 Durango 0 a 4 0.15% # ‚Ä¶ with 438 more rows Uso de funciones Student_grades %&gt;% mutate(Sobresaliente = if_else(Calificaciones&gt;=9, T, F)) # A tibble: 10 x 4 Nombre Asignatura Calificaciones Sobresaliente &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; 1 Juan M 8 FALSE 2 Carlos M 9 TRUE 3 Luis M 7 FALSE 4 Allison M 9 TRUE 5 Leticia M 8 FALSE 6 Juan Q 9 TRUE 7 Carlos Q 7 FALSE 8 Luis Q 8 FALSE 9 Allison Q 9 TRUE 10 Leticia Q 9 TRUE Agregar un √≠ndice a los datos Student_grades %&gt;% mutate(index = row_number()) # A tibble: 10 x 4 Nombre Asignatura Calificaciones index &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Juan M 8 1 2 Carlos M 9 2 3 Luis M 7 3 4 Allison M 9 4 5 Leticia M 8 5 6 Juan Q 9 6 7 Carlos Q 7 7 8 Luis Q 8 8 9 Allison Q 9 9 10 Leticia Q 9 10 Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Poblaci√≥n&quot; = Porcentaje * `Poblaci√≥n Total`) # A tibble: 448 x 5 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Porcentaje Poblaci√≥n &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 0.103 109853 2 Baja California 2856361 0 a 4 0.0941 268842 3 Baja California Sur 512030 0 a 4 0.0900 46070 4 Campeche 755703 0 a 4 0.0834 63034. 5 Coahuila 2501413 0 a 4 0.0978 244624. 6 Colima 568642 0 a 4 0.0809 45985 7 Chiapas 4293414 0 a 4 0.114 491525 8 Chihuahua 3241513 0 a 4 0.0783 253834. 9 Distrito Federal 8737172 0 a 4 0.0782 682914. 10 Durango 1509025 0 a 4 0.0997 150485 # ‚Ä¶ with 438 more rows En este √∫ltimo ejemplo se modifico la base de datos de la poblaci√≥n donde puede notarse que la anterior funci√≥n no elimina las variables con las que se opera, esto podr√≠a hacerse con la funci√≥n select(), o bien con la funci√≥n dplyr::transmute(), aunque elimina tambi√©n aquellas columnas que no se utilizan. Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% transmute(&quot;Poblaci√≥n&quot; = Porcentaje * `Poblaci√≥n Total`) # A tibble: 448 x 1 Poblaci√≥n &lt;dbl&gt; 1 109853 2 268842 3 46070 4 63034. 5 244624. 6 45985 7 491525 8 253834. 9 682914. 10 150485 # ‚Ä¶ with 438 more rows As√≠ que se har√° lo siguiente (Population_FEntity &lt;- Population_FEntity %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Poblaci√≥n&quot; = Porcentaje * `Poblaci√≥n Total`) %&gt;% select(-Porcentaje)) # A tibble: 448 x 4 `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Poblaci√≥n &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 2 Baja California 2856361 0 a 4 268842 3 Baja California Sur 512030 0 a 4 46070 4 Campeche 755703 0 a 4 63034. 5 Coahuila 2501413 0 a 4 244624. 6 Colima 568642 0 a 4 45985 7 Chiapas 4293414 0 a 4 491525 8 Chihuahua 3241513 0 a 4 253834. 9 Distrito Federal 8737172 0 a 4 682914. 10 Durango 1509025 0 a 4 150485 # ‚Ä¶ with 438 more rows "],
["dplyrgroup-by.html", "6.5 dplyr::group_by()", " 6.5 dplyr::group_by() Un funcionalidad muy importante es el uso de datos agrupados. Dichos grupos ser√°n subconjuntos de datos que compartan una caracter√≠stica en com√∫n. Esto tiene muchas ventajas ya que se pueden obtener funciones resumen con una mayor fluidez y aplicaciones de funciones por bloques en lugar de observaciones individuales. La funci√≥n para otorgar esta propiedad es dplyr::group_by() en donde sus par√°metros indican que variables servir√°n para crear los grupos de acuerdo a los diferentes valores de esas variables. Por ejemplo, v√©ase que es natural pensar que en los datos de la poblaci√≥n ya vistos se tomen res√∫menes por la variable Rango_edad. Population_FEntity %&gt;% group_by(Rango_edad) # A tibble: 448 x 4 # Groups: Rango_edad [14] `Entidad Federativa` `Poblaci√≥n Total` Rango_edad Poblaci√≥n &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 2 Baja California 2856361 0 a 4 268842 3 Baja California Sur 512030 0 a 4 46070 4 Campeche 755703 0 a 4 63034. 5 Coahuila 2501413 0 a 4 244624. 6 Colima 568642 0 a 4 45985 7 Chiapas 4293414 0 a 4 491525 8 Chihuahua 3241513 0 a 4 253834. 9 Distrito Federal 8737172 0 a 4 682914. 10 Durango 1509025 0 a 4 150485 # ‚Ä¶ with 438 more rows A simple vista no se ve alg√∫n cambio, pero internamente ya se tiene m√°s estructura a dicha base de datos, ahora existe un atributo llamado ‚Äúgroups‚Äù. str(Population_FEntity %&gt;% group_by(Rango_edad)) tibble [448 √ó 4] (S3: grouped_df/tbl_df/tbl/data.frame) $ Entidad Federativa: chr [1:448] &quot;Aguascalientes&quot; &quot;Baja California&quot; &quot;Baja California Sur&quot; &quot;Campeche&quot; ... $ Poblaci√≥n Total : num [1:448] 1066233 2856361 512030 755703 2501413 ... $ Rango_edad : chr [1:448] &quot;0 a 4&quot; &quot;0 a 4&quot; &quot;0 a 4&quot; &quot;0 a 4&quot; ... $ Poblaci√≥n : num [1:448] 109853 268842 46070 63034 244624 ... - attr(*, &quot;groups&quot;)= tibble [14 √ó 2] (S3: tbl_df/tbl/data.frame) ..$ Rango_edad: chr [1:14] &quot;0 a 4&quot; &quot;10 a 14&quot; &quot;15 a 19&quot; &quot;20 a 24&quot; ... ..$ .rows : list&lt;int&gt; [1:14] .. ..$ : int [1:32] 1 2 3 4 5 6 7 8 9 10 ... .. ..$ : int [1:32] 65 66 67 68 69 70 71 72 73 74 ... .. ..$ : int [1:32] 97 98 99 100 101 102 103 104 105 106 ... .. ..$ : int [1:32] 129 130 131 132 133 134 135 136 137 138 ... .. ..$ : int [1:32] 161 162 163 164 165 166 167 168 169 170 ... .. ..$ : int [1:32] 193 194 195 196 197 198 199 200 201 202 ... .. ..$ : int [1:32] 225 226 227 228 229 230 231 232 233 234 ... .. ..$ : int [1:32] 257 258 259 260 261 262 263 264 265 266 ... .. ..$ : int [1:32] 289 290 291 292 293 294 295 296 297 298 ... .. ..$ : int [1:32] 33 34 35 36 37 38 39 40 41 42 ... .. ..$ : int [1:32] 321 322 323 324 325 326 327 328 329 330 ... .. ..$ : int [1:32] 353 354 355 356 357 358 359 360 361 362 ... .. ..$ : int [1:32] 385 386 387 388 389 390 391 392 393 394 ... .. ..$ : int [1:32] 417 418 419 420 421 422 423 424 425 426 ... .. ..@ ptype: int(0) ..- attr(*, &quot;.drop&quot;)= logi TRUE Entonces, al aplicar funciones con mutate, estas se har√°n por grupos. Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% mutate(&quot;Poblaci√≥n M√≠nima&quot; = min(Poblaci√≥n), &quot;Poblaci√≥n M√°xima&quot; = max(Poblaci√≥n)) # A tibble: 448 x 6 # Groups: Rango_edad [14] `Entidad Federa‚Ä¶ `Poblaci√≥n Tota‚Ä¶ Rango_edad Poblaci√≥n `Poblaci√≥n M√≠ni‚Ä¶ &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 45985 2 Baja California 2856361 0 a 4 268842 45985 3 Baja California‚Ä¶ 512030 0 a 4 46070 45985 4 Campeche 755703 0 a 4 63034. 45985 5 Coahuila 2501413 0 a 4 244624. 45985 6 Colima 568642 0 a 4 45985 45985 7 Chiapas 4293414 0 a 4 491525 45985 8 Chihuahua 3241513 0 a 4 253834. 45985 9 Distrito Federal 8737172 0 a 4 682914. 45985 10 Durango 1509025 0 a 4 150485 45985 # ‚Ä¶ with 438 more rows, and 1 more variable: `Poblaci√≥n M√°xima` &lt;dbl&gt; Igual se puede agrupar por distintas variables Population_FEntity %&gt;% mutate(division = rep(c(rep(1,16),rep(2,16)), 14)) %&gt;% group_by(Rango_edad, division) %&gt;% mutate(index = row_number()) %&gt;% select(`Entidad Federativa`, Rango_edad, division, index) # A tibble: 448 x 4 # Groups: Rango_edad, division [28] `Entidad Federativa` Rango_edad division index &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 Aguascalientes 0 a 4 1 1 2 Baja California 0 a 4 1 2 3 Baja California Sur 0 a 4 1 3 4 Campeche 0 a 4 1 4 5 Coahuila 0 a 4 1 5 6 Colima 0 a 4 1 6 7 Chiapas 0 a 4 1 7 8 Chihuahua 0 a 4 1 8 9 Distrito Federal 0 a 4 1 9 10 Durango 0 a 4 1 10 # ‚Ä¶ with 438 more rows Algo interesante que se puede hacer con datos agrupados es el uso de funciones para resumir informaci√≥n, tales como dplyr::first(), dplyr::min(), dplyr::n(), dplyr::n_distinct() y dplyr::mean(); estas funciones tambi√©n se pueden usar sin datos agrupados. V√©ase los siguientes ejemplos Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% summarise(min(Poblaci√≥n)) # A tibble: 14 x 2 Rango_edad `min(Poblaci√≥n)` &lt;chr&gt; &lt;dbl&gt; 1 0 a 4 45985 2 10 a 14 51549 3 15 a 19 55391 4 20 a 24 44808 5 25 a 29 37723 6 30 a 34 35922. 7 35 a 39 41890 8 40 a 44 37496. 9 45 a 49 30294 10 5 a 9 43193. 11 50 a 54 22129. 12 55 a 59 23534 13 60 y m√°s 34364 14 NE 0 Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% summarise(last(Poblaci√≥n)) # A tibble: 14 x 2 Rango_edad `last(Poblaci√≥n)` &lt;chr&gt; &lt;dbl&gt; 1 0 a 4 127635. 2 10 a 14 165710 3 15 a 19 143317 4 20 a 24 108938 5 25 a 29 94536. 6 30 a 34 97108 7 35 a 39 92482. 8 40 a 44 85895 9 45 a 49 72674 10 5 a 9 152801 11 50 a 54 49238 12 55 a 59 53257 13 60 y m√°s 123730 14 NE 1067. Population_FEntity %&gt;% group_by(Rango_edad) %&gt;% summarise(&quot;Poblaci√≥n promedio&quot; = mean(Poblaci√≥n)) # A tibble: 14 x 2 Rango_edad `Poblaci√≥n promedio` &lt;chr&gt; &lt;dbl&gt; 1 0 a 4 301178. 2 10 a 14 361577. 3 15 a 19 326600. 4 20 a 24 269529. 5 25 a 29 237230. 6 30 a 34 244256 7 35 a 39 225481. 8 40 a 44 197310. 9 45 a 49 169798. 10 5 a 9 336668. 11 50 a 54 130510. 12 55 a 59 127968. 13 60 y m√°s 302126. 14 NE 4088. Otras funciones que ofrece dplyr para resumir informaci√≥n son dplyr::summarise_each() y dplyr::count(). La primera aplica la funci√≥n resumen a cada una de las columnas y la segunda cuenta el n√∫mero de valores √∫nicos con o sin un peso establecido. Population_FEntity %&gt;% count() # A tibble: 1 x 1 n &lt;int&gt; 1 448 Para eliminar esta propiedad a los datos se utiliza la funci√≥n dplyr::ungroup() y as√≠ la manipulaci√≥n de datos continuar√° sin eliminar los resultados ya obtenidos. "],
["dplyrrename.html", "6.6 dplyr::rename", " 6.6 dplyr::rename Antes de pasar a las funciones de dplyr especializadas en las operaciones de conjuntos con bases de datos,se ver√° la funci√≥n dplyr::rename() la cual, como indica su nombre, da un nuevo nombre a una variable existente. Population_FEntity %&gt;% rename(State = `Entidad Federativa`) # A tibble: 448 x 4 State `Poblaci√≥n Total` Rango_edad Poblaci√≥n &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 1066233 0 a 4 109853 2 Baja California 2856361 0 a 4 268842 3 Baja California Sur 512030 0 a 4 46070 4 Campeche 755703 0 a 4 63034. 5 Coahuila 2501413 0 a 4 244624. 6 Colima 568642 0 a 4 45985 7 Chiapas 4293414 0 a 4 491525 8 Chihuahua 3241513 0 a 4 253834. 9 Distrito Federal 8737172 0 a 4 682914. 10 Durango 1509025 0 a 4 150485 # ‚Ä¶ with 438 more rows Lo cual se pudo haber hecho con mutate() y select() Population_FEntity %&gt;% mutate (State = `Entidad Federativa`) %&gt;% select(-`Entidad Federativa`) # A tibble: 448 x 4 `Poblaci√≥n Total` Rango_edad Poblaci√≥n State &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 1066233 0 a 4 109853 Aguascalientes 2 2856361 0 a 4 268842 Baja California 3 512030 0 a 4 46070 Baja California Sur 4 755703 0 a 4 63034. Campeche 5 2501413 0 a 4 244624. Coahuila 6 568642 0 a 4 45985 Colima 7 4293414 0 a 4 491525 Chiapas 8 3241513 0 a 4 253834. Chihuahua 9 8737172 0 a 4 682914. Distrito Federal 10 1509025 0 a 4 150485 Durango # ‚Ä¶ with 438 more rows "],
["joins-y-set-operations.html", "6.7 Joins y Set Operations", " 6.7 Joins y Set Operations Anteriormente ya se hab√≠a mencionado la uni√≥n entre matrices, por rengl√≥n o columna y de la funci√≥n base::merge(), las cuales tienen su optimizaci√≥n por parte de dplyr. Por parte de las funciones que unen registros o variables, se tienen las funciones dplyr::bind_rows() y bind_cols(). Las mismas reglas que cbind() y rbind() se deben respetar. set.seed(20) x &lt;- tibble(One_Two = sample(1:2, size = 5, replace = T), Three_Four= sample(3:4, size = 5, replace = T), Five_Six = sample(5:6, size = 5, replace = T)) y &lt;- tibble(One_Two = rep(2, 3), Three_Four = rep(4, 3), Five_Six = rep(5, 3)) bind_rows(x,y) # A tibble: 8 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 3 5 2 1 4 5 3 1 3 5 4 2 4 5 5 2 4 5 6 2 4 5 7 2 4 5 8 2 4 5 z &lt;- tibble(One_Eigth = 1:8) bind_cols(bind_rows(x,y), z) # A tibble: 8 x 4 One_Two Three_Four Five_Six One_Eigth &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; 1 2 3 5 1 2 1 4 5 2 3 1 3 5 3 4 2 4 5 4 5 2 4 5 5 6 2 4 5 6 7 2 4 5 7 8 2 4 5 8 Respecto a las operaciones de conjuntos se tienen las funciones dplyr::interset(), dplyr::union y dplyr::setdiff(). intersect(x, y) # A tibble: 1 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 4 5 union(x, y) # A tibble: 4 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 3 5 2 1 4 5 3 1 3 5 4 2 4 5 setdiff(x, y) # A tibble: 3 x 3 One_Two Three_Four Five_Six &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 3 5 2 1 4 5 3 1 3 5 Las operaciones tipo Join son muy importantes en la extracci√≥n de informaci√≥n en bases de datos, dplyr por su cuenta tiene varias funciones para trabajar. dplyr::left_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x tomando la preferencia sobre a. dplyr::rigth_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x tomando la preferencia sobre b. dplyr::inner_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x considerando a y b. dplyr::full_join(a, b, by = x): Une las bases de datos de acuerdo a la variable x sin ninguna preferencia, por lo que contiene todos los datos posibles. Para ver m√°s claro esto, v√©ase los siguientes ejemplos. set.seed(20) a &lt;- tibble(L = sample(LETTERS[1:5], size = 5, replace = T), N = sample(1:100, size = 5, replace = T)) b &lt;- tibble(L = sample(LETTERS[1:5], size = 5, replace = T), Lo = sample(c(T, F), size = 5, replace = T)) a # A tibble: 5 x 2 L N &lt;chr&gt; &lt;int&gt; 1 C 94 2 B 62 3 A 45 4 B 41 5 E 67 b # A tibble: 5 x 2 L Lo &lt;chr&gt; &lt;lgl&gt; 1 E TRUE 2 A TRUE 3 E TRUE 4 B TRUE 5 D FALSE left_join(a, b, by = &quot;L&quot;) # A tibble: 6 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 C 94 NA 2 B 62 TRUE 3 A 45 TRUE 4 B 41 TRUE 5 E 67 TRUE 6 E 67 TRUE right_join(a, b, by = &quot;L&quot;) # A tibble: 6 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 B 62 TRUE 2 A 45 TRUE 3 B 41 TRUE 4 E 67 TRUE 5 E 67 TRUE 6 D NA FALSE inner_join(a, b, by = &quot;L&quot;) # A tibble: 5 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 B 62 TRUE 2 A 45 TRUE 3 B 41 TRUE 4 E 67 TRUE 5 E 67 TRUE full_join(a, b, by = &quot;L&quot;) # A tibble: 7 x 3 L N Lo &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 1 C 94 NA 2 B 62 TRUE 3 A 45 TRUE 4 B 41 TRUE 5 E 67 TRUE 6 E 67 TRUE 7 D NA FALSE Y un ejemplo pr√°ctico: Tomando la base de datos de la poblaci√≥n mexicana, se puede obtener los datos para los hombres y mujeres y modificarlos para que tengan un estructura similar a Population_FEntity. normalization &lt;- function(data){ colnames(data) &lt;- c(&quot;Entidad Federativa&quot;, &quot;Poblaci√≥n Total&quot;, unique(Population_FEntity$Rango_edad)) data &lt;- data %&gt;% gather(key = &quot;Rango_edad&quot;, value = &quot;Porcentaje&quot;, -c(&quot;Entidad Federativa&quot;, &quot;Poblaci√≥n Total&quot;)) %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Poblaci√≥n&quot; = Porcentaje * `Poblaci√≥n Total`) %&gt;% select(-Porcentaje, -`Poblaci√≥n Total`) } Population_FEntity_M &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B43:Q74&quot;, col_names = F) (Population_FEntity_M &lt;- normalization(Population_FEntity_M)) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad Poblaci√≥n &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 51587. 2 Baja California 0 a 4 124995. 3 Baja California Sur 0 a 4 22289. 4 Campeche 0 a 4 37749. 5 Coahuila 0 a 4 104304. 6 Colima 0 a 4 34496. 7 Chiapas 0 a 4 170085. 8 Chihuahua 0 a 4 122434. 9 Distrito Federal 0 a 4 462096. 10 Durango 0 a 4 76977. # ‚Ä¶ with 438 more rows Population_FEntity_F &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B79:Q110&quot;, col_names = F) (Population_FEntity_F &lt;- normalization(Population_FEntity_F)) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad Poblaci√≥n &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 56336 2 Baja California 0 a 4 127107. 3 Baja California Sur 0 a 4 22569 4 Campeche 0 a 4 32170 5 Coahuila 0 a 4 115765 6 Colima 0 a 4 23751. 7 Chiapas 0 a 4 227851 8 Chihuahua 0 a 4 122055 9 Distrito Federal 0 a 4 366480 10 Durango 0 a 4 68470 # ‚Ä¶ with 438 more rows As√≠ es f√°cil crear un s√≥lo conjunto de datos donde se re√∫na toda la informaci√≥n relevante Population_FEntity &lt;- Population_FEntity %&gt;% select(-`Poblaci√≥n Total`) Population_FEntityWS &lt;- left_join(Population_FEntity, Population_FEntity_M, by = c(&quot;Entidad Federativa&quot;, &quot;Rango_edad&quot;)) (Population_FEntityWS &lt;- left_join(Population_FEntityWS, Population_FEntity_F, by = c(&quot;Entidad Federativa&quot;, &quot;Rango_edad&quot;)) %&gt;% rename( &quot;Poblaci√≥n Total&quot; = &quot;Poblaci√≥n.x&quot;, &quot;Poblaci√≥nM&quot; = &quot;Poblaci√≥n.y&quot;, &quot;Poblaci√≥nF&quot; = &quot;Poblaci√≥n&quot;)) # A tibble: 448 x 5 `Entidad Federativa` Rango_edad `Poblaci√≥n Total` Poblaci√≥nM Poblaci√≥nF &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Aguascalientes 0 a 4 109853 51587. 56336 2 Baja California 0 a 4 268842 124995. 127107. 3 Baja California Sur 0 a 4 46070 22289. 22569 4 Campeche 0 a 4 63034. 37749. 32170 5 Coahuila 0 a 4 244624. 104304. 115765 6 Colima 0 a 4 45985 34496. 23751. 7 Chiapas 0 a 4 491525 170085. 227851 8 Chihuahua 0 a 4 253834. 122434. 122055 9 Distrito Federal 0 a 4 682914. 462096. 366480 10 Durango 0 a 4 150485 76977. 68470 # ‚Ä¶ with 438 more rows Por rango de edad ¬øQu√© sexo predomina en cada poblaci√≥n? Population_FEntityWS %&gt;% mutate(PPredominante = if_else(Poblaci√≥nM&gt;=Poblaci√≥nF, &quot;M&quot;, &quot;F&quot;)) %&gt;% select(`Entidad Federativa`, Rango_edad, PPredominante) # A tibble: 448 x 3 `Entidad Federativa` Rango_edad PPredominante &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Aguascalientes 0 a 4 F 2 Baja California 0 a 4 F 3 Baja California Sur 0 a 4 F 4 Campeche 0 a 4 M 5 Coahuila 0 a 4 F 6 Colima 0 a 4 M 7 Chiapas 0 a 4 F 8 Chihuahua 0 a 4 M 9 Distrito Federal 0 a 4 M 10 Durango 0 a 4 M # ‚Ä¶ with 438 more rows Por rango de edad ¬øQu√© sexo predomina y en que estado se encuentra dicho resultado? Population_FEntityWS %&gt;% mutate(SPredominante = if_else(Poblaci√≥nM&gt;=Poblaci√≥nF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, Poblaci√≥nM, Poblaci√≥nF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% select(`Entidad Federativa`, Rango_edad, SPredominante) # A tibble: 14 x 3 # Groups: Rango_edad [14] `Entidad Federativa` Rango_edad SPredominante &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 M√©xico 0 a 4 M 2 M√©xico 5 a 9 M 3 M√©xico 10 a 14 M 4 M√©xico 15 a 19 F 5 M√©xico 20 a 24 F 6 M√©xico 25 a 29 F 7 M√©xico 30 a 34 F 8 M√©xico 35 a 39 F 9 M√©xico 40 a 44 F 10 M√©xico 45 a 49 F 11 M√©xico 50 a 54 F 12 M√©xico 55 a 59 F 13 Distrito Federal 60 y m√°s F 14 M√©xico NE M ¬øCu√°l estado tiene el mayor n√∫mero de mujeres y cu√°l el de hombres? Population_by_sex_Mexico &lt;- Population_FEntityWS %&gt;% group_by(`Entidad Federativa`) %&gt;% summarise(SMasculino = sum(Poblaci√≥nM), SFemenino = sum(Poblaci√≥nF)) full_join( Population_by_sex_Mexico %&gt;% arrange(desc(SMasculino)) %&gt;% head(1) %&gt;% select(-SFemenino), Population_by_sex_Mexico %&gt;% arrange(desc(SFemenino)) %&gt;% head(1) %&gt;% select(-SMasculino), by = &quot;Entidad Federativa&quot;) # A tibble: 1 x 3 `Entidad Federativa` SMasculino SFemenino &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 M√©xico 6871269. 7305419 ¬øCu√°l es el rango de edad con mayor poblaci√≥n en mujeres y hombres? Population_by_sex_age_Mexico &lt;- Population_FEntityWS %&gt;% group_by(Rango_edad) %&gt;% summarise(Poblaci√≥nF = sum(Poblaci√≥nF), Poblaci√≥nM = sum(Poblaci√≥nM)) full_join( Population_by_sex_age_Mexico %&gt;% arrange(desc(Poblaci√≥nM)) %&gt;% head(1) %&gt;% select(-Poblaci√≥nF), Population_by_sex_age_Mexico %&gt;% arrange(desc(Poblaci√≥nF)) %&gt;% head(1) %&gt;% select(-Poblaci√≥nM), by = &quot;Rango_edad&quot;) # A tibble: 1 x 3 Rango_edad Poblaci√≥nM Poblaci√≥nF &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 10 a 14 5881838. 5790366 Finalmente, algunos puntos extra Recordando los cinco problemas en unos datos sin limpieza, dos que quedaron pendientes M√∫ltiples tipos de observaciones est√°n en la misma tabla. Una sola observaci√≥n esta en m√∫ltiples tablas. En el ejemplo que se ha tomado de la poblaci√≥n mexicana tiene el primer defecto, ya que la poblaci√≥n total bien podr√≠a quedar en una sola tabla junto con el nombre de la entidad y en otra los porcentajes de acuerdo a los rangos de edad. En general en este punto se debe tener en cuenta que cada unidad observacional debe tener su propia tabla, as√≠ logrando un t√©cnica en bases de datos llamada normalizaci√≥n. Para este caso, se tendr√≠an dos tablas Population_FEntity &lt;- readxl::read_xls(&quot;Data/Population_Sex_FEntity.xls&quot;, range = &quot;B5:Q38&quot;, col_names = TRUE) colnames(Population_FEntity)[1:2] &lt;- c(&quot;Entidad Federativa&quot;, &quot;Poblaci√≥n Total&quot;) Population_FEntity &lt;- Population_FEntity %&gt;% gather(key = &quot;Rango_edad&quot;, value = &quot;Porcentaje&quot;, -c(&quot;Entidad Federativa&quot;, &quot;Poblaci√≥n Total&quot;)) %&gt;% mutate(Porcentaje = Porcentaje/100) %&gt;% mutate(&quot;Poblaci√≥n&quot; = Porcentaje * `Poblaci√≥n Total`) (t1 &lt;- Population_FEntity %&gt;% select(`Entidad Federativa`, `Poblaci√≥n Total`)) # A tibble: 462 x 2 `Entidad Federativa` `Poblaci√≥n Total` &lt;chr&gt; &lt;dbl&gt; 1 Rep√∫blica Mexicana 103498524 2 Aguascalientes 1066233 3 Baja California 2856361 4 Baja California Sur 512030 5 Campeche 755703 6 Coahuila 2501413 7 Colima 568642 8 Chiapas 4293414 9 Chihuahua 3241513 10 Distrito Federal 8737172 # ‚Ä¶ with 452 more rows (t2 &lt;- Population_FEntity %&gt;% select(`Entidad Federativa`, Rango_edad, Poblaci√≥n)) # A tibble: 462 x 3 `Entidad Federativa` Rango_edad Poblaci√≥n &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Rep√∫blica Mexicana 0 a 4 9637687 2 Aguascalientes 0 a 4 109853 3 Baja California 0 a 4 268842 4 Baja California Sur 0 a 4 46070 5 Campeche 0 a 4 63034. 6 Coahuila 0 a 4 244624. 7 Colima 0 a 4 45985 8 Chiapas 0 a 4 491525 9 Chihuahua 0 a 4 253834. 10 Distrito Federal 0 a 4 682914. # ‚Ä¶ with 452 more rows Para el √∫ltimo punto se entiende que los datos est√°n dispersos entre distintos conjuntos de datos, por lo que usar las funciones para combinar bases de datos ayudan en la resoluci√≥n de este problema. Es recomendable estudiar el paquete purrr, el cual es parte del tidyverse y ofrece una versi√≥n ideal para trabajar con funciones an√≥nimas en data frames, ya que al tratar de aplicar alguna funci√≥n de la familia apply con un data frame estos son convertidos primero a una matriz lo cual hace perder muchos de sus atributos. As√≠, con las funciones de la ‚Äúfamilia‚Äù purrr::map se pueden hacer todas las aplicaciones que se pueden hacer con alguna de la familia apply e incluso algunas m√°s. Adem√°s de que tienen una aplicaci√≥n ideal con dplyr. V√©ase Functional Programming. Se pueden usar las librer√≠as dtplyr, dbplyr o sparklyr como interfaz para usar la sintaxis de dplyr en data.tables, bases de datos en SQL o en Apache Spark. Recordar que la funci√≥n dplyr::near() compara dos elementos num√©ricos en punto flotante. La funci√≥n dplyr::case_when() es una versi√≥n equivalente a dplyr::if_else() pero m√°s general tibble(x = 1:5) %&gt;% mutate(new_variable = dplyr::case_when(x == 1 ~ &quot;Hola&quot;, x == 5 ~ &quot;Adios&quot;, TRUE ~ as.character(x))) # A tibble: 5 x 2 x new_variable &lt;int&gt; &lt;chr&gt; 1 1 Hola 2 2 2 3 3 3 4 4 4 5 5 Adios dplyr proviene de la paqueter√≠a plyr la cual contiene muchas m√°s funciones que pueden ser de utilidad en ciertas ocasiones. Ejercicios Utiliza la funci√≥n dplyr::top_n(). En la siguiente p√°gina se puede aprender sobre el uso de expresiones regulares. Usando las funciones dplyr::select() y dplyr::matches() replica los resultados que se dieron como ejemplo cuando se explico la funci√≥n dplyr::select(). Crea un data frame o tibble con 5 variables num√©ricas. Utiliza la funci√≥n dplyr::mutate_each() para aplicar la funci√≥n dplyr::percent_rank() en cada una de las variables. Investigar algunas funciones de purrr como reduce(), map() y accumulate(). Investiga el uso de dplyr::semi_join() y dplyr::anti_join(). Si eres meticuloso, ver√°s que algo anda en los datos de la poblaci√≥n. ¬øPor qu√©? Hint: Ve la tabla que se uso para los √∫ltimos ejemplos de la secci√≥n dplyr. Obt√©n resultados necesarios para contestar las siguientes preguntas sobre la base de datos population que ofrece dplyr. ¬øCuantos a√±os est√°n registrados por pa√≠s? ¬øQu√© pa√≠ses tienen mayor poblaci√≥n por a√±o? ¬øCu√°l es la edad promedio, con los a√±os dados, de la poblaci√≥n en cada pa√≠s? ¬øQu√© pa√≠ses son aquellos que tienen m√°s de un mill√≥n de habitantes en alg√∫n a√±o? ¬øQu√© pa√≠ses tienen menos de un mill√≥n de habitantes en al menos un a√±o? ¬øQue pa√≠s ha sido el que ha tenido la peor reducci√≥n en su poblaci√≥n y en que a√±o? ¬øQu√© pa√≠s tuvo la mayor cantidad poblaci√≥n en el a√±o de tu nacimiento? ¬øCu√°l fue el a√±o en que cada pa√≠s tuvo su mayor numero de habitantes? ¬øCu√°l fue el a√±o en que cada pa√≠s tuvo su menor numero de habitantes? ¬øCu√°ntos pa√≠ses considera la base de datos? La base de datos who de dplyr contiene la informaci√≥n sobre los reportes de tuberculosis en el mundo. Haz una limpieza en esta base utilizando las funciones de tidyr y obt√©n la siguiente informaci√≥n. Por pa√≠s ¬øCu√°l fue el a√±o con mayor n√∫mero de enfermos por tuberculosis? Por pa√≠s ¬øCu√°l de los tres diagn√≥sticos diferentes tiene una mayor ocurrencia? ¬øCu√°l fue el a√±o con mayor n√∫mero de enfermos por pa√≠s? ¬øQu√© pa√≠s ha tenido el mayor n√∫mero de enfermos por tuberculosis? ¬øCu√°l es el top-10 de pa√≠ses con mayor n√∫mero de casos con tuberculosis? ¬øHay alg√∫n pa√≠s sin casos de tuberculosis en los a√±os registrados? ¬øCu√°l sexo es el m√°s afectado, por pa√≠s, con tuberculosis? ¬øCu√°l es el rango de edad con mayor n√∫mero de casos con tuberculosis? ¬øCu√°l es el rango de edad con menor n√∫mero de casos con tuberculosis? Por rango de edad ¬øQu√© sexo es el m√°s afectado con tuberculosis? Las bases de datos who y population est√°n relacionadas, por lo que se pueden unir para responder lo siguiente: ¬øExisten pa√≠ses en los que el a√±o donde se tuvo el m√°ximo n√∫mero de enfermos por tuberculosis sean los a√±os donde se obtuvo un gran descenso en la poblaci√≥n? La base de datos storms proporcionada por dplyr contiene la informaci√≥n acerca de 198 tormentas tropicales con diferentes atributos. Obt√©n la siguiente informaci√≥n. ¬øCu√°ntos huracanes tuvieron las tres clasificaciones (Depresi√≥n Tropical, Tormenta Tropical y Hurac√°n)? ¬øCu√°l a√±o fue el que tuvo el mayor n√∫mero de huracanes? ¬øCu√°l a√±o fue el que tuvo el mayor n√∫mero de Tormentas Tropicales? ¬øCu√°l es el mes con mayor actividad? ¬øQu√© tormenta ha sido la que tuvo mayor n√∫mero de cambios en su categor√≠a Saffir-Simpson? ¬øCu√°l ha sido la tormenta con mayor velocidad promedio del viento en nudos? ¬øPor tormenta, cu√°l ha sido la velocidad m√°xima que alcanzo en \\(k/h\\)? Considerando que una tormenta se puede clasificar por el estatus que predomina en ella, ¬øQu√© tipo de tormenta es la m√°s recurrente en el Atl√°ntico? ¬øCu√°l ha sido la tormenta con mayor duraci√≥n? Considerando latitud y longitud en t√©rminos enteros (pensando as√≠ en segmentos del territorio), ¬øCu√°l ha sido la ubicaci√≥n donde se ha tenido la mayor cantidad de tormentas? Utiliza las funciones Join que proporciona dplyr con las bases de datos dplyr::band_instruments y dplyr::and_members. "],
["graficaci√≥n-de-datos-ggplot.html", "Cap√≠tulo 7 Graficaci√≥n de datos: Ggplot", " Cap√≠tulo 7 Graficaci√≥n de datos: Ggplot Finalmente, uno de los paquetes m√°s famosos del tidyverse es ggplot, el cual esta dise√±ada para representar la informaci√≥n obtenida de los datos mediante gr√°ficas con un excelente control de todos los elementos gr√°ficos tratados como objetos. Dicha paqueter√≠a est√° basada en el libro The Grammar of Graphics de Leland Wilkinson. Como siempre, una de las mejores fuentes r√°pidas para recordar alguna funci√≥n o caracter√≠stica de ellas, es la Cheat Sheet oficial, aunque hay una enorme cantidad de ejemplos y tutoriales para esta paqueter√≠a. A criterio personal recomendar√≠a los siguientes enlaces para estudiar m√°s a fondo todo lo relacionado con este gran mundo que a√∫n sigue en crecimiento. ggplot2: Elegant Graphics for Data Analysis de Handley Wickham. R Graphics Cookbook: Practical Recipes for Visualizing Data de Winston Chang. R for Data Science de Hadley Wickham. A ggplot2 Tutorial for Beautiful Plotting in R. Be Awesome in ggplot2: A Practical Guide to be Highly Effective - R software and data visualization. An Introduction to Ggplot2. Independientemente de la gr√°fica que se est√© realizando, la idea b√°sica en ggplot para construir una gr√°fica es mediante el uso de capas. Algunos que tengan experiencia en programas dise√±ados para la creaci√≥n de im√°genes entender√°n que el uso de capas otorga un mayor control sobre los elementos gr√°ficos del resultado final. Mediante cada capa se agregan elementos gr√°ficos que proporcionan alg√∫n tipo de atributo extra a toda la imagen. Se comenzar√° siempre con la capa donde se adjuntar√°n las capas restantes. Para este ejemplo se tomar√° la base de datos que ya se ha estado utilizando en las anteriores secciones con el objetivo de crear una gr√°fica donde se represente el comportamiento de la poblaci√≥n total a medida que avanza el rango de edad. Population_total_range &lt;- Population_FEntityWS %&gt;% mutate(Rango_edad = factor(Rango_edad, levels = unique(Rango_edad))) %&gt;% group_by(Rango_edad) %&gt;% summarise(Y = sum(`Poblaci√≥n Total`)) ggplot(Population_total_range) Esta primera capa se puede pensar como la hoja o la superficie donde se comenzar√≠a a realizar un dibujo. En la bibliograf√≠a que se menciono al inicio se puede encontrar m√°s informaci√≥n sobre el comportamiento interno de ggplot, por ahora es bueno saber que la funci√≥n ggplot y sus subsecuentes toman los datos y aplican transformaciones para traducir dicho contenido en informaci√≥n que pueda ser utilizada para la determinaci√≥n de colores, geometr√≠as, escalas y hasta espacio geom√©trico. Algo que hay que tomar en cuenta al hacer una gr√°fica con ggplot es el uso del operador +, el cual tendr√° una funci√≥n similar a %&gt;%. Con este se a√±adir√° una capa m√°s a toda la gr√°fica con la que ya se estaba trabajando. Population_total_range %&gt;% ggplot() + aes(x=Rango_edad, y=Y) En esta segunda capa se estableci√≥ mediante la funci√≥n aes() aquellas variables que servir√°n como ejes para mapear la informaci√≥n. Dicha funci√≥n se puede modificar en cada capa y puede ser un par√°metro en la mayor√≠a de funciones de ggplot. Ahora, s√≥lo falta agregar los elementos gr√°ficos para representar las observaciones dadas, es decir la geometr√≠a. Population_total_range %&gt;% ggplot(aes(x=Rango_edad, y=Y)) + geom_point() ¬°As√≠ de f√°cil se obtiene ya la gr√°fica! Faltan aplicar algunos detalles como el dise√±o de esta, lo cual ser√≠a a√±adiendo m√°s capas. V√©ase que en las siguientes instrucciones la gr√°fica se guardo como un objeto el cual puede ser usado m√°s adelante. graph_population &lt;- Population_total_range %&gt;% ggplot(aes(x=Rango_edad, y=Y)) + geom_point() (graph_population_per &lt;- graph_population + theme(axis.line = element_line(linetype = &quot;solid&quot;), axis.ticks = element_line(colour = &quot;gray0&quot;), panel.grid.major = element_line(colour = &quot;gray25&quot;), panel.grid.minor = element_line(colour = &quot;gray25&quot;), axis.title = element_text(colour = &quot;gray93&quot;), axis.text = element_text(colour = &quot;gray82&quot;), plot.title = element_text(colour = &quot;gray90&quot;), panel.background = element_rect(fill = &quot;gray33&quot;, size = 1.5, linetype = &quot;dashed&quot;), plot.background = element_rect(fill = &quot;gray21&quot;, colour = &quot;gray0&quot;, size = 1.6, linetype = &quot;solid&quot;))) Cada uno de los comandos anteriores son dados para cambiar solo el dise√±o, bien pudo hacerse todo en capas individuales con la funci√≥n theme() o, como en este caso, englobar todo el dise√±o en una capa. Existen muchos elementos que se pueden cambiar y lo m√°s recomendable es ver la documentaci√≥n oficial de la funci√≥n theme desde la p√°gina Modify components of a theme, la cual contiene ejemplos muy √∫tiles. Dando m√°s dise√±o con m√°s capas se puede mejorar mucho la presentaci√≥n de esta, ya que a√∫n la propia gr√°fica en si misma no proporciona mucha informaci√≥n para alguien que no tenga conocimiento de la informaci√≥n con la que se esta trabajando. Es decir que falta agregar t√≠tulos, nombres informativos en los ejes, una mejor distribuci√≥n de las etiquetas en los ejes y algunos atributos extra que ayuda en la interpretaci√≥n y obtenci√≥n visual m√°s r√°pida de la informaci√≥n. (graph_population_per &lt;- graph_population_per + geom_point(color = &quot;white&quot;) + #Esta instrucci√≥n pudo colocarse la primera vez de su uso labs(x = &quot;Rango de edad&quot;, y = &quot;Poblaci√≥n total&quot;, caption = &quot;Datos obtenidos de los tabulados b√°sicos de la CONAPO (2020)&quot;)+ ggtitle(&quot;Poblaci√≥n total de M√©xico por rangos de edad quinquenales en el 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7))) En la siguiente p√°gina: Ggplot title, Subtitle and caption, se puede ver un poco sobre la manipulaci√≥n de t√≠tulos, subtitulos y captions. Tal vez sea tedioso estar modificando manualmente cada aspecto est√©tico de la gr√°fica, por lo que se han dado algunos temas predefinidos para hacer de dicha tarea algo sencillo, estos se pueden obtener con el prefijo theme_; aqu√≠ se dejan un par de ejemplos. library(patchwork) (graph_population+ labs(x = &quot;Rango de edad&quot;, y = &quot;Poblaci√≥n total&quot;, caption = &quot;Datos obtenidos de los tabulados b√°sicos de la CONAPO (2020)&quot;)+ ggtitle(&quot;Poblaci√≥n total de M√©xico por rangos de edad quinquenales en el 2020&quot;)+ scale_y_continuous(labels = scales::comma) + theme_minimal())+(graph_population+ labs(x = &quot;Rango de edad&quot;, y = &quot;Poblaci√≥n total&quot;, caption = &quot;Datos obtenidos de los tabulados b√°sicos de la CONAPO (2020)&quot;)+ ggtitle(&quot;Poblaci√≥n total de M√©xico por rangos de edad quinquenales en el 2020&quot;)+ scale_y_continuous(labels = scales::comma) + theme_classic()) Lo anterior solo fue un ejemplo de como usar el paquete patchwork, el cual se menciona m√°s adelante en una lista de paquetes √∫tiles, por lo que no se toma en cuenta la mal distribuci√≥n que se consigui√≥ en los ejes de las gr√°ficas anteriores. Las siguientes gr√°ficas muestran un poco m√°s de todas las geometr√≠as que incluye ggplot, sin importar por el momento el dise√±o de dichas gr√°ficas. (Population_total_range %&gt;% ggplot(aes(x = Rango_edad, y = Y))+geom_bar(stat = &quot;identity&quot;))+ (Population_by_sex_age_Mexico %&gt;% ggplot(aes(x = Poblaci√≥nF))+geom_boxplot())+ (Population_by_sex_age_Mexico %&gt;% ggplot(aes(x = Poblaci√≥nM))+geom_density()) Adem√°s de poder asignar las variables a los ejes, tambi√©n se pueden usar las variables como atributos est√©ticos para las gr√°ficas. V√©ase en el siguiente ejemplo el uso de la variable Entidad Federativa para agregar color a las barras en el siguiente gr√°fico de barras. .scroll-300 { max-height: 300px; } #Por rango de edad ¬øQu√© sexo predomina y en que estado se encuentra dicho resultado? Population_FEntityWS %&gt;% mutate(SPredominante = if_else(Poblaci√≥nM&gt;=Poblaci√≥nF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, Poblaci√≥nM, Poblaci√≥nF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% ggplot(aes(x = Rango_edad, y = `Poblaci√≥n Total`, fill = `Entidad Federativa`))+ geom_bar(stat = &quot;identity&quot;)+ labs(x = &quot;Rango de edad&quot;, y = &quot;Poblaci√≥n total&quot;)+ ggtitle(&quot;Poblaci√≥n total por rangos de edad quinquenales \\n del sexo dominante en M√©xico 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7)) Bien se podr√≠a hacer m√°s patri√≥tica la gr√°fica anterior. Population_FEntityWS %&gt;% mutate(SPredominante = if_else(Poblaci√≥nM&gt;=Poblaci√≥nF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, Poblaci√≥nM, Poblaci√≥nF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% ggplot(aes(x = Rango_edad, y = `Poblaci√≥n Total`, fill = `Entidad Federativa`, color = SPredominante))+ geom_bar(stat = &quot;identity&quot;)+ labs(x = &quot;Rango de edad&quot;, y = &quot;Poblaci√≥n total&quot;, fill = &quot;Entidad Federativa: &quot;, color = &quot;Sexo Predominante: &quot;)+ ggtitle(&quot;Poblaci√≥n total por rangos de edad quinquenales \\n del sexo dominante en M√©xico 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7), legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot;, panel.grid.major = element_line(linetype = &quot;blank&quot;), panel.background = element_rect(fill = &quot;gray93&quot;))+ scale_fill_manual(values = c(&quot;#CE0626&quot;,&quot;#2C6846&quot;))+ scale_color_manual(values = c(&quot;dimgrey&quot;, &quot;black&quot;)) Adem√°s se pueden usar m√∫ltiples geometr√≠as en una gr√°fica. La gr√°fica siguiente es un gr√°fico de dispersi√≥n de la longitud de los s√©palos contra el ancho de los s√©palos en la base de datos iris agregando un poco de ruido (se agrega un poco de variaci√≥n aleatoria a las ubicaciones) junto con un ajuste polin√≥mico a los datos originales. iris %&gt;% ggplot(aes(x = Sepal.Length, y =Petal.Width))+ geom_point()+ geom_smooth()+ geom_jitter() Hay muchas m√°s otras funciones y geometr√≠as que se podr√≠an explorar y que har√≠a de este secci√≥n muy larga. Para resumir un poco, se deja una lista de paquetes y funciones que pueden ser de utilidad a la hora de graficar y que han ampliado de gran manera todo el universo de ggplot para hacerlo una de las herramientas principales para crear contenido visual a partir de una an√°lisis de datos. Graficaci√≥n interactiva Highcharter Plotly library(plotly) graph_example_interactive &lt;- Population_FEntityWS %&gt;% mutate(SPredominante = if_else(Poblaci√≥nM&gt;=Poblaci√≥nF, &quot;M&quot;, &quot;F&quot;)) %&gt;% mutate(S = if_else(SPredominante == &quot;M&quot;, Poblaci√≥nM, Poblaci√≥nF)) %&gt;% group_by(Rango_edad) %&gt;% top_n(1, S) %&gt;% ggplot(aes(x = Rango_edad, y = `Poblaci√≥n Total`, fill = `Entidad Federativa`, color = SPredominante))+ geom_bar(stat = &quot;identity&quot;)+ labs(x = &quot;Rango de edad&quot;, y = &quot;Poblaci√≥n total&quot;, fill = &quot;Entidad Federativa: &quot;, color = &quot;Sexo Predominante: &quot;)+ ggtitle(&quot;Poblaci√≥n total por rangos de edad quinquenales \\n del sexo dominante en M√©xico 2020&quot;)+ theme(axis.text.x = element_text(angle = 25))+ scale_y_continuous(labels = scales::comma) + theme(text = element_text(size=12, family = &quot;Leelawadee UI Semilight&quot;), axis.title = element_text(size = 9.6), axis.text = element_text(size = 9), plot.title = element_text(hjust = 0.5), plot.caption = element_text(colour = &quot;gray99&quot;, size = 7), legend.position = &quot;top&quot;, legend.direction = &quot;horizontal&quot;, panel.grid.major = element_line(linetype = &quot;blank&quot;), panel.background = element_rect(fill = &quot;gray93&quot;))+ scale_fill_manual(values = c(&quot;#CE0626&quot;,&quot;#2C6846&quot;))+ scale_color_manual(values = c(&quot;dimgrey&quot;, &quot;black&quot;)) ggplotly(graph_example_interactive) ggplotly(graph_population_per) 3D Aqu√≠ un ejemplo en 3D usando Plotly. rayshader. Scatterplot3d. library(&quot;scatterplot3d&quot;) scatterplot3d(iris[,1:3]) Animaci√≥n animation. transformr. tweenr. gganimate. El el siguiente enlace se pueden ver algunas variaciones del siguiente ejemplo. library(gganimate) library(gapminder) #Para obtener la base de datos gapminder: Extracto de los datos de Gapminder sobre esperanza de vida, PIB per c√°pita y poblaci√≥n por pa√≠s. ggplot( gapminder, aes(x = gdpPercap, y=lifeExp, size = pop, colour = country) ) + geom_point(show.legend = FALSE, alpha = 0.7) + scale_color_viridis_d() + scale_size(range = c(2, 12)) + scale_x_log10() + labs(x = &quot;GDP per capita&quot;, y = &quot;Life expectancy&quot;) + transition_time(year) + labs(title = &quot;Year: {frame_time}&quot;) Colores futurevisions. wesanderson. Emoji Emoji. Otras librer√≠as muy √∫tiles. ggforce. cowplot. ggproto. patchwork. Faltar√≠an muchos otros tipos de gr√°ficas y referencias que hacer, pero una de las mejores formas de obtener m√°s ejemplos son con galer√≠as, algunas son las siguientes the R Graph Gallery. htmlwidgets for R - gallery. Twitter Ejercicios Investiga el uso de la funci√≥n ggplot2::qplot(). ¬øQu√© sucede en el primer ejemplo de la secci√≥n ggplot si los datos que sirvieron para el par√°metro data de dicha funci√≥n fueran los siguientes: Population_total_range&lt;-Population_FEntityWS %&gt;% group_by(Rango_edad) %&gt;% summarise(Y = sum(Poblaci√≥n Total))? Usar la funci√≥n ggplot2::facet_grid() para graficar, por los cinco principales estados (los de mayor poblaci√≥n), un gr√°fico de barras donde se vea la distribuci√≥n por rangos quinquenales de edad de su poblaci√≥n. Utiliza la funci√≥n ggplot2::scale_function() para gr√°ficar la funci√≥n normal en el rango (-5,5). Utiliza la funci√≥n latex2exp::TeX() para agregar la ecuaci√≥n de la funci√≥n normal en la gr√°fica anterior. "],
["introducci√≥n.html", "Cap√≠tulo 8 Introducci√≥n", " Cap√≠tulo 8 Introducci√≥n No s√≥lo basta saber crear el contenido, tambi√©n es muy importante si dicho material realmente comunica lo que se desea. En esta secci√≥n se revisaran algunos de los puntos m√°s importantes sobre la forma en que se presenta la informaci√≥n para que el mensaje que se quiere transmitir con ellos sea comunicado mas eficientemente. Los datos, pueden ser duros es decir los datos originales o res√∫menes de estos. En los res√∫menes podemos tener frecuencias acumuladas, porcentajes, tablas, gr√°ficos entre otros. Hay 4 conceptos a tener en cuenta cuando se presentan datos, estos deben ser: Correctos. Todos los datos presentados deben ser verificados previo a cualquier difusi√≥n de informaci√≥n Claros. Se debe tener claro el mensaje que se quiere dar con los datos y la presentaci√≥n de la informaci√≥n debe transmitir claramente este mensaje. Concisos. La presentaci√≥n debe tener s√≥lo la informaci√≥n necesaria para transmitir el mensaje. Consistentes. La informaci√≥n debe ser consistente en la unidades usadas, asi como abreviaciones y uso de decimales. "],
["manejo-de-n√∫meros.html", "Cap√≠tulo 9 Manejo de n√∫meros", " Cap√≠tulo 9 Manejo de n√∫meros Uno de los elementos a cuidar en la presentaci√≥n de datos estad√≠sticos es el manejo de los n√∫meros. Uso de separador de miles. 128456 vs 128,456 o 128 456 Uso de separador decimal. (consistencia) 66.6, 56.7, 34,7 Nivel de comparaci√≥n. (usar mismas unidades) Presupuesto de secretaria de salud es de 11,048 millones de pesos, representa un incremento de 563 mil pesos (\\(5.4\\%\\)) respecto al a√±o pasado. El presupuesto de secretaria de salud aumento 0.6 millones (\\(5\\%\\)) siendo 11.0 millones. Justificaci√≥n de los datos. Usar la misma tipografia, tama√±o y n√∫mero de d√≠gitos. Justificar a la derecha cuando los datos se ponen en columnas, para alinear las unidades. Redondeo. Redondear los datos para que sean comparables al mismo nivel. Redondear para hacerlo memorable y m√°s f√°cil de comunicar (14,245 a 14,000). "],
["tablas.html", "Cap√≠tulo 10 Tablas", " Cap√≠tulo 10 Tablas Posicionar los totales por rengl√≥n en una √∫ltima columna, y los totales por columna en un √∫ltimo rengl√≥n. Los t√≠tulos deben ser reducidos. Centrar los encabezados de las columnas. Cuando la tabla tenga mas de 5 renglones, agregar espaciado cada 5 renglones (es m√°s f√°cil leer en bloques) Marcar la fuente de donde se tomaron los datos. Datos temporales se ordenan cronol√≥gicamente de arriba a abajo o dercha a izquierda. "],
["tabla-de-resumen.html", "10.1 Tabla de resumen", " 10.1 Tabla de resumen Al realizar una tabla que resume datos es buena idea considerar el mesaje que se quiere transmitir as√≠ como la audiencia a la que va dirigida. Para ello las siguiente preguntas son √∫tiles. ¬øQu√© n√∫meros de la tabla se quiere que el lector compare? ¬øCu√°ntos n√∫meros son necesarios para transmitir el mensaje? ¬øQu√© tanto detalle es necesario? ¬øSe puede agregar informaci√≥n derivada para ayudar a transmitir el mensaje? ¬øDeben estar los datos presentados en alg√∫n orden? Ejemplo De una base de datos en donde se registra la exportaci√≥n d√≠aria de aguacate de los diferentes productores del pa√≠s, se busca conocer la distribuci√≥n de las exportaciones por estado de la rep√∫blica en 2019. El siguiente ejemplo presenta la salida en R de un agrupamiento por estado del total de kilogramos exportados durante 2019. Estado Volumen (Kgs) Porcentaje JALISCO 417729.8 52.12 MICHOACAN 286298.8 35.72 GUANAJUATO 96916.3 12.09 MORELOS 600 0.07 Una mejor presentaci√≥n de estos datos, siguiendo las recomendaciones es: Estado Volumen (Kgs) Porcentaje JALISCO 417,730 52% MICHOACAN 286,299 36% GUANAJUATO 96,916 12% "],
["gr√°ficos.html", "Cap√≠tulo 11 Gr√°ficos", " Cap√≠tulo 11 Gr√°ficos Cuando se usan gr√°ficos por lo general se busca la comprensi√≥n de los datos s√≥lo con el objeto visual sin ayuda de ejes, pies de p√°gina o informaci√≥n adicional. Al igual que con las tablas, antes de realizar un gr√°fico se debe tener claro el mensaje que se desea transmitir. Puntos a considerar: Acomodar los datos para maximizar el uso de texto en forma horizontal. Seleccionar el tipo de gr√°fico correcto seg√∫n los datos y el mensaje a transmitir. Evitar colores fuertes primarios (son dominantes para el cebrebro). Cuando se grafican n√∫meros, siempre empezar el eje ‚Äúy‚Äù en cero. Usar la misma escala en gr√°ficos que ser√°n comparados. Considerar tranformar datos en diferentes escalas antes de graficarlos. Asegurarse que las escalas tengan el formato apropiado. (Redondeo, decimales, etc) S√≥lo usar gr√°ficos en dos dimensiones para datos bidimensionales. "],
["gr√°fico-circular.html", "11.1 Gr√°fico circular", " 11.1 Gr√°fico circular En particular para los gr√°ficos circulares se recomienda: Asegurarse que los porcentajes sumen \\(100\\%\\) Iniciar con el primer segmento a las 12 del d√≠a e ir llenando en sentido de las manecillas del reloj. Cuando se pueda, ordenar los segmentos por tama√±o de mayor a menor. Evitar pies de mas de 6 segmentos. Usar tonos del mismo color para identificar proporciones de una variable. Ejemplo Usando los mismos datos de exportaci√≥n d√≠aria de aguacate. Realizaremos una representaci√≥n gr√°fica del volumen de exportaci√≥n de aguacate observada en 2019 para cada pa√≠s destino. library(ggplot2) paises &lt;- c(&quot;MYANMAR (BIRMANIA)&quot;,&quot;BANGLADESH&quot;,&quot;HONG KONG&quot;,&quot;JAPON&quot;,&quot;ARABIA SAUDITA&quot;, &quot;EMIRATOS √ÅRABES UNIDOS&quot;, &quot;REINO UNIDO&quot;, &quot;PA√çSES BAJOS (HOLANDA)&quot;, &quot;SINGAPUR&quot;,&quot;ESTADOS UNIDOS&quot;) vol &lt;- c(304734.62, 125240.00, 74578.50, 68925.24,55285.20,51517.44, 43760.00, 32092.50, 29610.00, 11481.36) D1 &lt;- data.frame(paises,vol) ggplot(D1, aes(x = paises, y = vol)) + labs(x=&quot;Paises de Destino&quot;, y=&quot;Volumen en Kg&quot;, title=&quot;Volumen de exportaci√≥n de aguacate por pais de destino en 2019&quot;)+ geom_bar(stat = &quot;identity&quot;,fill=&quot;#f68060&quot;)+ theme(axis.text.x = element_text(angle = 90)) + scale_y_continuous(labels = scales::number) Y tambi√©n presentaremos gr√°ficamente la tabla de producci√≥n de aguacate por estado de la rep√∫blica que presentamos en la secci√≥n de tablas. edo &lt;- c(&quot;JALISCO&quot;,&quot;MICHOACAN&quot;,&quot;GUANAJUATO&quot;) vol &lt;- c(&quot;417,730&quot;,&quot;286,299&quot;,&quot;96,916&quot;) por &lt;- c(52,36, 12) D1 &lt;- data.frame(edo,vol,por) ggplot(D1, aes(x=&quot;&quot;, y=por, fill=edo)) + geom_bar(stat=&quot;identity&quot;, width=1,color=&quot;white&quot;) + coord_polar(&quot;y&quot;, start=0)+ theme_void()+ geom_text(aes(label = vol,x = 1), color = &quot;white&quot;, size=4, position = position_stack(vjust = 0.5))+ scale_fill_brewer(palette=&quot;Set2&quot;)+ labs(title=&quot;Producci√≥n de aguacate por estado en 2019&quot;) The R Fundation. n.d. ‚ÄúWhat Is R?‚Äù https://www.r-project.org/about.html. Wickham, Hadley. 2019. Advanced R. 2nd ed. CRC press. https://adv-r.hadley.nz. Wickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" O‚ÄôReilly Media, Inc.\". https://r4ds.had.co.nz. Wikipedia contributors. 2020. ‚ÄúR (Programming Language) ‚Äî Wikipedia, the Free Encyclopedia.‚Äù https://en.wikipedia.org/w/index.php?title=R_(programming_language)&amp;oldid=978636340. "]
]
